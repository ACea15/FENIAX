{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Finite Element models 4 Nonlinear Intrinsic Aeroelastics in JAX [FENIAX]","text":"<p>FENIAX is an aeroelastic toolbox  written in Python using JAX. It acts as a post-processor of commercial software such as MSC Nastran. </p> <p>Some of the key features of the software are:</p> <ul> <li> <p>Arbitrary FE models built for linear aeroelastic analysis are enhanced with geometric nonlinear effects, flight dynamics and linearized state-space solutions about nonlinear equilibrium.</p> </li> <li> <p>Leveraging on the numerical library JAX and optimised algorithms, a high performance is achieved that leads to simulation times comparable to the linear counterparts on conventional platforms.</p> </li> <li> <p>The software runs on modern hardware architectures such as GPUs in a addition to standard CPUs.</p> </li> <li> <p>Algorithm differentiation (AD) of the aeroelastic response is available via JAX primitives. </p> </li> <li> <p>Concurrent simulations for multiple load cases have been developed.</p> </li> </ul> <p>Warning</p> <p>The software is in beta, and while it has been thoroughly tested, new features keep being added and it is likely features for your analysis might be missing. Get in touch if you encounter problems.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>If you just want to start running the code, navigate to the Getting started</p>"},{"location":"#examples","title":"Examples","text":"<p>The most relevant examples in the code base are shown here, these and more can be found in the folder <code>/examples</code> They are also part of a large test suite that is integrated into the development using CI/CD.</p> <p>Tip</p> <p>Navigate to the code of the various examples, including the simulation input settings and postprocessing of the simulation --exactly as it was used for the articles backing the software. See examples</p>"},{"location":"#nonlinear-structural-static-results","title":"Nonlinear structural static results","text":"<p>Success</p> <ul> <li>Validated with MSC Nastran nonlinear solution (sol 400)</li> <li>AD differentiation of the response verified against finite-differences</li> </ul> <p>Notebook</p> <p></p> <p>Note</p> <p>Take a liner FE model of arbitrary complexity from your favourite FE solver, and turn it into a fully geometrically nonlinear model. You just need a condensation step into the main load paths and the resulting linear stiffness and mass matrices.  </p>"},{"location":"#wing-free-dynamics","title":"Wing free dynamics","text":"<p>Success</p> <ul> <li>Validated with MSC Nastran nonlinear solution (sol 400)</li> <li>Runs over x100 faster than Nastran </li> <li>AD differentiation of the response verified against finite-differences</li> </ul> <p>Notebook</p> <p></p>"},{"location":"#free-flying-structure","title":"Free flying structure","text":"<p>This example first appeared in the work of Juan Carlos Simo (see Bio) , a pioneer in the field of computational structural mechanics and the </p> <p>Notebook</p>"},{"location":"#2d-dynamics","title":"2D dynamics","text":""},{"location":"#3d-dynamics","title":"3D dynamics","text":""},{"location":"#concurrent-aeroelastic-simulations-on-ultra-high-aspect-ratio-aircraft","title":"Concurrent aeroelastic simulations on ultra-high aspect ratio aircraft","text":"<p>Success</p> <ul> <li>Nonlinear aeroelastic response in our solvers takes similar times or less to the linear Nastran solution!! </li> <li>Concurrent simulations for various loading settings achieve unparalleled computational times.</li> <li>CPU VS GPU benchmarks available.</li> </ul>"},{"location":"#wing-tip-static-loading","title":"Wing-tip static loading","text":"<ul> <li>Extremely large deformations</li> <li>Validation of concurrent solution</li> <li>300 modes in the solution, 8 different loading scenarios running in parallel each with 11 substeps, 24 seconds in total on A100 GPU</li> </ul>"},{"location":"#aeroelastic-equilibrium-for-varying-aoa","title":"Aeroelastic equilibrium for varying AoA","text":"<ul> <li>Nonlinear effects: follower aerodynamic forces, geometric stiffening, wing shortening.</li> <li>Steady manoeuvre varying flow conditions and AoA for a total 256 cases in 14 seconds.</li> </ul>"},{"location":"#dynamic-loads-at-large-scale-gust-envelopes","title":"Dynamic loads at large scale: gust envelopes","text":"<ul> <li>512 different gust cases run on A100 GPU NVIDIA in 38 seconds!</li> <li>Rigid body modes included, rigid/elastic nonlinear couplings accounted for.</li> <li>Load envelopes available from the simulation.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Please see the project license for further details.</p>"},{"location":"JAX/","title":"JAX","text":"<p>The Python library JAX has been used as the numerical engine for calculations and it also manages the parallelization. JAX is designed for high-performance numerical computing with focus on machine learning applications. It combines XLA (accelerated linear algebra) and Autograd, the former being a compiler that optimises models for different hardware platforms, the latter is an Automatic Differentiation (AD) tool in Python. See the documentation. The extensible system of composable function transformations provides a set of important features for Computational Science as illustrated in Figure above. For instance, the vmap function allows for complex vectorisation operations and the pmap function for Single-Program Multiple-Data (SPMD) parallelisation. Both forward and reverse mode automatic differentiation are supported. Finally the just-in-time compilation (jit) relies on the XLA engine to compile and execute functions on CPUs but also on accelerators such as GPUs and TPUs, offering a versatile solution for seamlessly connecting the software to various types of hardware.</p> <p>The XLA module is a domain-specific compiler for linear algebra that optimizes computations for both CPUs and GPUs. In fact, XLA is platform agnostic and achieves optimized performance on the target architecture orchestrating a complex process that encompassing a series of optimizations and transformations: the source code is first converted into HLO (High-Level Optimizer) code, an specialized language derived from a graph representation of the computations; XLA performs optimizations on the HLO code (geared towards high-level mathematical operations, particularly those in linear algebra and machine learning models), and are independent of the hardware architecture, such as operation fusion. It then carries optimizations for the particular architecture in use. From there, the Low Level Virtual Machine (LLVM) toolkit is utilized to produce an Intermediate Representation that the LLVM compiler can understand, which then performs further optimizations before outputting the machine code. When it comes to leveraging the computational power of GPUs, the link between XLA and CUDA kernels is critical. On the one hand, JAX utilizes CUDA libraries such as cuBLAS for dense linear algebra; on the other hand, it is capable of generating custom CUDA kernels for operations that are not efficiently covered by standard libraries.</p>"},{"location":"LICENSE/","title":"GNU General Public License","text":"<p>Version 3, 29 June 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p> <p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>"},{"location":"LICENSE/#preamble","title":"Preamble","text":"<p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p>"},{"location":"LICENSE/#terms-and-conditions","title":"TERMS AND CONDITIONS","text":""},{"location":"LICENSE/#0-definitions","title":"0. Definitions","text":"<p>\u201cThis License\u201d refers to version 3 of the GNU General Public License.</p> <p>\u201cCopyright\u201d also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\u201cThe Program\u201d refers to any copyrightable work licensed under this License. Each licensee is addressed as \u201cyou\u201d. \u201cLicensees\u201d and \u201crecipients\u201d may be individuals or organizations.</p> <p>To \u201cmodify\u201d a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \u201cmodified version\u201d of the earlier work or a work \u201cbased on\u201d the earlier work.</p> <p>A \u201ccovered work\u201d means either the unmodified Program or a work based on the Program.</p> <p>To \u201cpropagate\u201d a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \u201cconvey\u201d a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \u201cAppropriate Legal Notices\u201d to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>"},{"location":"LICENSE/#1-source-code","title":"1. Source Code","text":"<p>The \u201csource code\u201d for a work means the preferred form of the work for making modifications to it. \u201cObject code\u201d means any non-source form of a work.</p> <p>A \u201cStandard Interface\u201d means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \u201cSystem Libraries\u201d of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \u201cMajor Component\u201d, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \u201cCorresponding Source\u201d for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p>"},{"location":"LICENSE/#2-basic-permissions","title":"2. Basic Permissions","text":"<p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>"},{"location":"LICENSE/#3-protecting-users-legal-rights-from-anti-circumvention-law","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law","text":"<p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>"},{"location":"LICENSE/#4-conveying-verbatim-copies","title":"4. Conveying Verbatim Copies","text":"<p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>"},{"location":"LICENSE/#5-conveying-modified-source-versions","title":"5. Conveying Modified Source Versions","text":"<p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <ul> <li>a) The work must carry prominent notices stating that you modified it, and giving a relevant date.</li> <li>b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \u201ckeep intact all notices\u201d.</li> <li>c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.</li> <li>d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.</li> </ul> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \u201caggregate\u201d if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>"},{"location":"LICENSE/#6-conveying-non-source-forms","title":"6. Conveying Non-Source Forms","text":"<p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <ul> <li>a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.</li> <li>b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.</li> <li>c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.</li> <li>d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.</li> <li>e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.</li> </ul> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \u201cUser Product\u201d is either (1) a \u201cconsumer product\u201d, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \u201cnormally used\u201d refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\u201cInstallation Information\u201d for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>"},{"location":"LICENSE/#7-additional-terms","title":"7. Additional Terms","text":"<p>\u201cAdditional permissions\u201d are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <ul> <li>a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or</li> <li>b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or</li> <li>c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or</li> <li>d) Limiting the use for publicity purposes of names of licensors or authors of the material; or</li> <li>e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or</li> <li>f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.</li> </ul> <p>All other non-permissive additional terms are considered \u201cfurther restrictions\u201d within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>"},{"location":"LICENSE/#8-termination","title":"8. Termination","text":"<p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>"},{"location":"LICENSE/#9-acceptance-not-required-for-having-copies","title":"9. Acceptance Not Required for Having Copies","text":"<p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>"},{"location":"LICENSE/#10-automatic-licensing-of-downstream-recipients","title":"10. Automatic Licensing of Downstream Recipients","text":"<p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \u201centity transaction\u201d is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>"},{"location":"LICENSE/#11-patents","title":"11. Patents","text":"<p>A \u201ccontributor\u201d is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \u201ccontributor version\u201d.</p> <p>A contributor's \u201cessential patent claims\u201d are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \u201ccontrol\u201d includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \u201cpatent license\u201d is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \u201cgrant\u201d such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \u201cKnowingly relying\u201d means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \u201cdiscriminatory\u201d if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>"},{"location":"LICENSE/#12-no-surrender-of-others-freedom","title":"12. No Surrender of Others' Freedom","text":"<p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>"},{"location":"LICENSE/#13-use-with-the-gnu-affero-general-public-license","title":"13. Use with the GNU Affero General Public License","text":"<p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p>"},{"location":"LICENSE/#14-revised-versions-of-this-license","title":"14. Revised Versions of this License","text":"<p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>"},{"location":"LICENSE/#15-disclaimer-of-warranty","title":"15. Disclaimer of Warranty","text":"<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201cAS IS\u201d WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>"},{"location":"LICENSE/#16-limitation-of-liability","title":"16. Limitation of Liability","text":"<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"LICENSE/#17-interpretation-of-sections-15-and-16","title":"17. Interpretation of Sections 15 and 16","text":"<p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"UML/","title":"Object Oriented Architecture","text":"<p>Fig. [[components_architecture]] shows a high-level view of this first version of the software in terms of components. A Configuration component builds the necessary settings for the simulation, including geometric coordinates, load-paths information. The Configuration is injected into the Driver component that initialises the Simulation component, the Systems and the Solution component, after which it triggers the simulation. The Systems are run as managed by the Simulation component and encapsulate the various equations to be solved (time marching, nonlinear static equilibrium or stability for instance). The solution component acts as a memory-efficient container of the new data to be kept as the solution process advances, and it is responsible for loading (from a previous simulations) and writing solution data too. It is thus passed to every System. </p> <p>Fig. [[classes_architecture]] shows a lower view of the abstractions, interfaces between classes and how they interact via their public methods. The inputs to the program may be given via a .yaml file or a python dictionary in memory. The starting point in the main file is the initialisation of the driver corresponding to the mathematical description to be solved (so far only the intrinsic modal is available, Eqs. \\eqref{eq3:intrinsic_full_aeroelastic}). The intrinsic driver computes (or loads), as a pre-simulation step, the intrinsic modal shapes and nonlinear tensors from the linear stiffness and mass matrices and the nodal coordinates; then it runs the cases by triggering the simulation class. This class is responsible for managing how the systems are being run (in serial, in parallel, or even in a coupling process between systems). From the configuration settings, the intrinsic system loads the equations (dqs), the external loads in Eqs. \\eqref{eq2:sol_qs}, such as point-forces, gravity or modal aerodynamic GAFs. Various libraries can be chosen to either solve the static equations or march in time if the solution is dynamic; importantly, the JAX-based Diffrax library has been integrated and supports ordinary, stochastic and controlled equations, with many solvers and multiple adjoint methods which could be used in an optimization framework. This initial layout of the software is expected to evolve and to be consolidated as the software matures. </p>"},{"location":"UML/#abstract-classes","title":"Abstract classes","text":""},{"location":"UML/#inheritance-model","title":"Inheritance model","text":""},{"location":"algorithms/","title":"Intrinsic modal solution","text":""},{"location":"algorithms/#overall-solution-process","title":"Overall solution process","text":"<p>The tensor structure of the main components in the solution process is illustrated in the figure below in the sequential order they are computed, together with the asymptotic time and space complexities. The discretization of the problem comprises  number of condensed nodes,  modes used in the reduced order model and  time steps in the solution (if the problem is static,  represents a ramping load stepping scheme). The intrinsic modes,  are computed from the eigenvalue solution and the coordinates  of the active nodes.  The nonlinear couplings,  are calculated next, from which the is assembled and solved to yield the solution states  with  the number of states in the system that is proportional to the number of modes. Local velocities, internal forces and strain fields   are computed as a product of the corresponding intrinsic modes and states, and their integration leads to the position tensor,  with similar structure. In some cases, such as when gravity forces are included, the evolution of the rotational matrix, , needs to be solved for too.</p> <p></p> <p>For links to the codebase, see the following: </p> <ul> <li>Modes.</li> <li>Nonlinear couplings.</li> <li>Solution of equations:<ul> <li>Orchestrator to build the Systems</li> <li>Numerical solvers inside Sollibs: Using Diffrax or bespoke solvers in JAX.</li> <li>Right-hand-side (RHS) of the system of equations implemented in pure functions to comply with JAX functional programming approach.</li> </ul> </li> </ul>"},{"location":"algorithms/#system-of-equations","title":"System of equations","text":""},{"location":"algorithms/#recovery-of-deformations","title":"Recovery of deformations","text":"<p>Analytical solutions to the  are obtained when the strain is assumed constant between nodes, using a piecewise constant integration. If a component in the load-path is discretized in $n$+1 points, strain and curvatures are defined in the mid-points of the spatial discretization (n in total).  and  are constant within the segment , and the position and rotation matrix after integration are  with the operators  and  obtained from integration of the exponential function, as in \\cite{PALACIOS2010}. Note that when position and rotations are recovered from strain integration, there is still one point that is either clamped or needs to be tracked from integration of its local velocity.</p> <p></p>"},{"location":"developer/","title":"Tips","text":""},{"location":"developer/#tests","title":"Tests","text":"<ul> <li> <p>Testing framework using Pytest. Tests marked as slow, private or legacy won't run by default. See Configuration for details.</p> </li> <li> <p>CI/CD via Github actions, so every push to the master branch checks all tests are run.</p> </li> </ul>"},{"location":"developer/#pending-improvements","title":"Pending improvements","text":"<ul> <li> <p>Extend type-hinting to the entire codebase.</p> </li> <li> <p>Add entry point to run FENIAX from command line to .yml file. </p> </li> <li> <p>TODOs: Search for TODOs within the codebase. Either integrated in your IDE, or just run <code>grep -r --include \"*.py\" \"# TODO:\" .</code> from the terminal</p> </li> <li> <p>Setup a proper branching model (as more than one developer contributes to the code).</p> </li> </ul>"},{"location":"examples/","title":"Examples","text":"<ul> <li> <p>Find various notebooks here that have been written as part of the publications of this project.</p> </li> <li> <p>For a good range of examples, see the FENIAX example repo: FENIAXexamples</p> </li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the <code>Getting Started</code> guide for FENIAX.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<ul> <li>Currently the code has been tested and is developed in Linux and MacOS. Get the code from GitHub first, and move to the directory: <pre><code>git clone https://github.com/ACea15/FENIAX.git\ncd FENIAX\n</code></pre></li> <li>see pyproject.toml file for the options available. Python 3.10+ is required.</li> <li>A minimum installation into the current environment is possible by navigating to the main directory and <pre><code>pip install .\n</code></pre></li> </ul> <p>However developer mode is recommended and also installing the full set of packages which include testing and visualisation capabilities:</p> <p><pre><code>pip install -e .[all]\n</code></pre> or do the following if no visualisation is required or visualisation libraries give issues: <pre><code>pip install -e .[dev]\n</code></pre></p> <ul> <li>check everything is OK by running the tests: </li> </ul> <pre><code>pytest\n</code></pre> <ul> <li>To install with GPU support install jax first: <pre><code>pip install -U \"jax[cuda12]\"\npip install -e \".[all]\"\n</code></pre></li> </ul>"},{"location":"getting_started/#python-environment","title":"Python environment","text":"<p>Although it is not necessary, it is recommended that the software is installed in its own environment. Options that have been tested out follow.</p>"},{"location":"getting_started/#venv","title":"Venv","text":"<p>venv is the python native virtual environment. In the root of the project directory run  <pre><code>python -m venv name_env\nsource name_env/bin/activate\n</code></pre> Then install as above and all the required packages will be installed in the local bin folder. As always pytest to check everything runs fine.</p>"},{"location":"getting_started/#uv","title":"UV","text":"<p>UV is a new python package manager, very fast as it is written in Rust. Once installed, the workflow is similar to that of Venv.  Install the python version you want to use: <pre><code>uv python install 3.11\n</code></pre> Now similar to venv, create a folder in the project root, activate the environment, install the code (note uv comes first than pip and a python version is selected as many might be available), run tests: <pre><code>uv venv name_env --python 3.11\nsource name_env/bin/activate\nuv pip install -e .[all]\npytest\n</code></pre></p>"},{"location":"getting_started/#pyenv","title":"Pyenv","text":"<p>pyenv is a good way to maintain various python version in your system, lighter than conda and also provides a centralised solution for all your virtual environments. Navigate to the root directory and run the following: </p> <p><pre><code>  pyenv install 3.11.10\n  pyenv virtualenv 3.11.10 feniax\n  pyenv local feniax\n  pip install -e .[all]\n  pytest\n</code></pre> By setting pyenv local to feniax, every time one moves to feniax directory the environment is automatically activated</p>"},{"location":"getting_started/#conda","title":"Conda","text":"<p>If conda is being used as package manager, one can make a specific environment as,</p> <pre><code>conda create -n feniax python=3.11\nconda activate feniax\n</code></pre> <p>Thus a typical installation would comprise of these 4 steps: <pre><code>conda create -n feniax.python=3.11\nconda activate feniax\npip install -e .[all]\npytest\n</code></pre></p>"},{"location":"publications/","title":"Publications","text":"<p>Relevant publications:</p> <ul> <li>An Intrinsic Description of the Nonlinear Aeroelasticity of Very Flexible Wings</li> <li>Nonlinear Modal Condensation of Large Finite Element Models: Application of Hodges\u2019s Intrinsic Theory</li> <li>A non-intrusive geometrically nonlinear augmentation to generic linear aeroelastic models</li> <li>A Geometrically Nonlinear Approach For The Aeroelastic Analysis Of Commercial Transport Aircraft</li> <li>Geometrically Nonlinear Effects on the Aeroelastic Response of a Transport Aircraft Configuration</li> <li>JAX-based aeroelastic simulation engine for differentiable aircraft dynamics</li> </ul>"},{"location":"theory_intrinsic/","title":"Description","text":""},{"location":"theory_intrinsic/#high-level-physical-assumptions","title":"High level physical assumptions","text":""},{"location":"theory_intrinsic/#solution-process","title":"Solution process","text":""},{"location":"theory_intrinsic/#reduction-to-load-paths","title":"Reduction to Load paths","text":"<p>The full FE linear model is splitted into active (ASETs) nodes and ommited nodes such that,</p> <p> </p> <p>A linear dependency is assumed between the omitted and the active degrees of freedom,  </p> <p>with  the transformation matrix between both sets. In general, the condensation is dependent on the frequencies and forms a nonlinear eigenvalue problem where each LNM,  with natural frequency, , has one transformation matrix,  </p> <p>This is the so-called exact-condensation matrix, where Kidder's mode expansion is also introduced. The first-order approximation of this equation is attained by letting , thereby removing inertia effects. This results in a static condensation or Guyan reduction. Note that when the mass model consists only of lumped masses on the active degrees of freedom, , Guyan reduction is the exact condensation.</p> <p>After calculation of , the transformation from the active set and the full model is defined as , with  the identity matrix of dimension . The condensed mass and stiffness matrices are obtained by equating the kinetic energy,  and the potential energy,  in the linear reduced and complete systems; if external loads are applied to the omitted nodes, equating virtual work gives the equivalent loads in the condensed model:</p> <p> </p>"},{"location":"theory_intrinsic/#intrinsic-modes","title":"Intrinsic modes","text":"<p>Let  be the solution of the eigenvalue problem using the condensed matrices,  and .  includes the full set of modes in the condensed system written as displacement and linear rotations at the nodes along the load-paths. Those mode shapes also define velocity and strain distributions. Standard FE solvers yield results in the global reference frame while the intrinsic modes are defined in the initial local configuration (with the convention of the -direction running along the local beam). Therefore, a matrix  is introduced to rotate the 6-component vectors from the global to the local initial frame,  calculated from the structural nodes position.</p> <p>The discrete velocity mode is defined as  and a linear interpolation is sought for the continuous displacement, , and velocities modes, :</p> <p> </p> <p>The corresponding distribution of linear and rotational momenta at the master nodes can be  obtained using the condensed inertia matrix, , expressed in their components in the global frame of reference. The introduction of this momentum mode allows the use of arbitrary mass models. Because the mass matrix is already calculated as an integral along the 3D domain and then condensed to a set of master nodes, the continuous momentum mode shapes, , are considered lumped and defined using Dirac's delta function,  as,</p> <p> </p> <p>Each displacement mode also generates a corresponding internal stress state. This defines discrete force/moment modes, , which are obtained from the displacement modes and the condensed stiffness matrix using a summation-of-forces approach  where  is the position vector of the nodes summed by , and  the mid position between nodes  and . The first term is the sum of forces due to modal displacements and the second one the sum of moments due to modal rotations and the cross product of the  position vector and the previous calculated force. The strain modes  are obtained from spatial derivatives of the displacement modes along along the load paths, and interpolated as piece-wise constant too,</p> <p> </p>"},{"location":"theory_intrinsic/#nonlinear-couplings","title":"Nonlinear couplings","text":"<p>After a Galerkin projection of the equations, the following tensors need to be approximated: - Alphas must equal the identity matrix  </p> <ul> <li>Gammas give the nonlinear inertia and strain couplings</li> </ul> <p> </p>"},{"location":"theory_intrinsic/#aeroelastic-system","title":"Aeroelastic system","text":"<p>Systems of equations Different systems of equations are assembled depending on options: </p> <ul> <li>Structural dynamic:    </li> <li>(Clamped) Aeroelastic systems:    </li> </ul>"},{"location":"theory_intrinsic/#recovery-of-deformations","title":"Recovery of deformations","text":"<p>Calculation of the deformed geometry is obtained in a postprocessing step. Firstly, we define an Earth global reference system  used to determine the trajectory and instantaneous orientation of the aircraft, and then a local material frame  at each point along the load path. The relative orientation is defined by the coordinate transformation matrix, . Local rotations are needed, however, within the solution process when gravity, or other dead forces, are active. Recall that in an intrinsic formulation, forces are naturally given in the material frame of reference and so gravity forces need to be expressed in a local deformed frame. Quaternions  are used to parameterize the rotation, , such that given the angular velocity, , which is part of the velocity state, , it is  The quaternions, one per node, can be added to the main equations and march in time; the rotations can be extracted at every step as   where the first parenthesis in this equation is the symmetric part of the rotation and the last term the antisymmetric part. Alternatively, the rotation and position in the inertial reference system can be calculated by integration of strains along the domain, as in the Frenet-Serret formulas of differential geometry. Following definition of strains  and curvatures , which can be obtained from the strain modes defined above, we have   where .</p>"},{"location":"api/configuration/","title":"Configuration","text":""},{"location":"api/configuration/#preprocessor.configuration.Config","title":"<code>Config</code>","text":"Source code in <code>feniax/preprocessor/configuration.py</code> <pre><code>class Config:\n\n    def __init__(self, sett: dict):\n        self.__sett = copy.copy(sett)\n        self.__serial_data = None\n        self.__extract_attr()\n        self.__load_container()\n        self.__defaults()\n        self.__set_defaults()        \n        self.__build()\n\n    def __extract_attr(self):\n        \"\"\"Extracts attributes that do not belong to a container.\n        This attributes are located at the first level of the input settings.\"\"\"\n        if \"ex\" in self.__sett.keys():\n            self.__set_experimental(self.__sett.pop(\"ex\"))\n        if \"engine\" in self.__sett.keys():\n            self.__set_attr(engine=self.__sett.pop(\"engine\"))\n\n    def __load_container(self):\n        \"\"\"Load the container with the configuration dataclasses\"\"\"\n\n        # TODO: Extend to functionality for various containers\n        self.__container = importlib.import_module(\n            f\"feniax.preprocessor.containers.{self.engine}\"\n        )\n        self.__container = importlib.reload(self.__container)  # remove after testing\n\n    def __defaults(self):\n        self.__MOD_DEFAULT = dict(optionsjax=[\"jax_np\", \"jax_scipy\"])\n        self.__CONTAINER_DEFAULT = dict(intrinsicmodal=[\"const\", \"log\"])\n\n    def __set_defaults(self):\n        # default modules\n        for k, v in self.__MOD_DEFAULT.items():\n            _container = importlib.import_module(f\"feniax.preprocessor.containers.{k}\")\n            for i in v:\n                container_k = getattr(_container, \"\".join([\"D\", i]))                \n                if i in self.__sett.keys():\n                    setattr(self, i, container_k(**self.__sett[i]))\n                    del self.__sett[i]\n                else:\n                    setattr(self, i, container_k())\n        # default containers within self.engine module\n        for k, vlist in self.__CONTAINER_DEFAULT.items():\n            if self.engine == k:\n                for v in vlist:\n                    container_v = getattr(self.__container, \"\".join([\"D\", v]))\n                    if v in self.__sett.keys():\n                        setattr(self, v, container_v(**self.__sett[v]))\n                        del self.__sett[v]\n                    else:\n                        setattr(self, v, container_v())\n\n    def __build(self):\n        if self.engine == \"intrinsicmodal\":  # needs some specialisation here\n            k = \"fem\"  # initialised fem first as it will be pass to system\n            v = self.__sett[k]\n            container_k = getattr(self.__container, \"\".join([\"D\", k]))\n            container_k_initialised = container_k(**v)\n            setattr(self, k, container_k_initialised)\n            for k, v in self.__sett.items():\n                if k != \"fem\" and v is not None: # avoid empty containers\n                    container_k = getattr(self.__container, \"\".join([\"D\", k]))\n                    if k == \"systems\" or k == \"system\":  # pass Dfem\n                        container_k_initialised = container_k(\n                            **(v | dict(_fem=self.fem))\n                        )\n                    else:\n                        container_k_initialised = container_k(**v)\n                    setattr(self, k, container_k_initialised)\n        else:  # not currently in used\n            for k, v in self.__sett.items():\n                container_k = getattr(self.__container, \"\".join([\"D\", k]))\n                setattr(self, k, container_k(**v))\n\n    def __set_experimental(self, experimental: dict):\n        ex_object = inputs.dict2object(experimental)\n        setattr(self, \"ex\", ex_object)\n\n    def __set_attr(self, **kwargs):\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    @classmethod\n    def from_file(cls, file_dir: str | pathlib.Path, **kwargs):\n        yaml = YAML()\n        yaml_dict = yaml.load(pathlib.Path(file_dir))\n        return cls(yaml_dict)\n\n    def clone(self, add_attr:dict=None, del_attr:str|list=None):\n        self_dict = serialize_nocomments(self)\n        if add_attr is not None:\n            self_dict = feniax.utils.dict_merge(self_dict, add_attr)\n        if del_attr is not None:\n            if isinstance(del_attr, str):\n                feniax.utils.dict_deletebypath(self_dict, del_attr)\n            elif isinstance(del_attr, list):\n                for li in del_attr:\n                    feniax.utils.dict_deletebypath(self_dict, li)\n        return Config(self_dict)\n</code></pre>"},{"location":"api/configuration/#preprocessor.configuration.Config.__extract_attr","title":"<code>__extract_attr()</code>","text":"<p>Extracts attributes that do not belong to a container. This attributes are located at the first level of the input settings.</p> Source code in <code>feniax/preprocessor/configuration.py</code> <pre><code>def __extract_attr(self):\n    \"\"\"Extracts attributes that do not belong to a container.\n    This attributes are located at the first level of the input settings.\"\"\"\n    if \"ex\" in self.__sett.keys():\n        self.__set_experimental(self.__sett.pop(\"ex\"))\n    if \"engine\" in self.__sett.keys():\n        self.__set_attr(engine=self.__sett.pop(\"engine\"))\n</code></pre>"},{"location":"api/configuration/#preprocessor.configuration.Config.__load_container","title":"<code>__load_container()</code>","text":"<p>Load the container with the configuration dataclasses</p> Source code in <code>feniax/preprocessor/configuration.py</code> <pre><code>def __load_container(self):\n    \"\"\"Load the container with the configuration dataclasses\"\"\"\n\n    # TODO: Extend to functionality for various containers\n    self.__container = importlib.import_module(\n        f\"feniax.preprocessor.containers.{self.engine}\"\n    )\n    self.__container = importlib.reload(self.__container)  # remove after testing\n</code></pre>"},{"location":"api/couplings/","title":"Nonlinear couplings","text":""},{"location":"api/couplings/#intrinsic.couplings.f_alpha1","title":"<code>f_alpha1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>alpha1 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        alpha1 tensor (NmxNm)\n\n    \"\"\"\n\n    alpha1 = jnp.einsum(\"isn,jsn-&gt;ij\", phi1, psi1)\n    return alpha1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_alpha2","title":"<code>f_alpha2(phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Alpha2 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha2(phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Alpha2 tensor (NmxNm)\n\n    \"\"\"\n\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    alpha2 = jnp.einsum(\"isn,jsn,n-&gt;ij\", phi2i, psi2i, delta_si)\n    return alpha2\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma1","title":"<code>f_gamma1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma1 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        Gamma1 tensor (NmxNmxNm)\n\n    \"\"\"\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L1(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L1 = f2(phi1, psi1)  # Nmx6xNmxNm\n    gamma1 = jnp.einsum(\"isn,jskn-&gt;ijk\", phi1, L1)\n    return gamma1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma2","title":"<code>f_gamma2(phi1m, phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>psi1m</code> <code>array</code> <p>Velocity modal shapes at mid-points (Nmx6xNn)</p> required <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma2 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma2(\n    phi1m: jnp.array, phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array\n) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    psi1m : jnp.array\n        Velocity modal shapes at mid-points (Nmx6xNn)    \n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Gamma2 tensor (NmxNmxNm)\n\n    \"\"\"\n\n    phi1mi = phi1m[:, :, 1:]\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L2(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L2 = f2(phi2i, psi2i)  # Nmx6xNmxNm\n    gamma2 = jnp.einsum(\"isn,jskn,n-&gt;ijk\", phi1mi, L2, delta_si)\n    # L2 = f2(phi2, psi2) # Nmx6xNmxNm\n    # gamma2 = jnp.einsum('isn,jskn,n-&gt;ijk', phi1m, L2, delta_s)\n    return gamma2\n</code></pre>"},{"location":"api/deformations/","title":"Deformations","text":""},{"location":"api/deformations/#intrinsic.postprocess.compute_internalforces","title":"<code>compute_internalforces(phi2l, q2)</code>","text":"<p>Recovery velocities in material frame.</p> <p>Parameters:</p> Name Type Description Default <code>phi2l</code> <code>ndarray</code> <p>Intrinsic force modes in local frame</p> required <code>q2</code> <code>ndarray</code> <p>Force modal coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Internal force field</p> Source code in <code>feniax/intrinsic/postprocess.py</code> <pre><code>def compute_internalforces(phi2l: jnp.ndarray, q2: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Recovery velocities in material frame.\n\n    Parameters\n    ----------\n    phi2l : jnp.ndarray\n        Intrinsic force modes in local frame\n    q2 : jnp.ndarray\n        Force modal coordinate\n\n    Returns\n    -------\n    jnp.ndarray\n        Internal force field\n\n    \"\"\"\n\n    X2 = jnp.tensordot(phi2l, q2, axes=(0, 1))  # 6xNnxNt\n    return X2.transpose((2, 0, 1))\n</code></pre>"},{"location":"api/deformations/#intrinsic.postprocess.compute_strains","title":"<code>compute_strains(cphi2l, q2)</code>","text":"<p>Recovery strains in material frame.</p> <p>Parameters:</p> Name Type Description Default <code>cphi2l</code> <code>ndarray</code> <p>Intrinsic  strain modes in local frame</p> required <code>q2</code> <code>ndarray</code> <p>Force modal coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Strain field</p> Source code in <code>feniax/intrinsic/postprocess.py</code> <pre><code>def compute_strains(cphi2l: jnp.ndarray, q2: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Recovery strains in material frame.\n\n    Parameters\n    ----------\n    cphi2l : jnp.ndarray\n        Intrinsic  strain modes in local frame\n    q2 : jnp.ndarray\n        Force modal coordinate\n\n    Returns\n    -------\n    jnp.ndarray\n        Strain field\n\n    \"\"\"\n\n    X3 = jnp.tensordot(cphi2l, q2, axes=(0, 1))  # 6xNnxNt\n    return X3.transpose((2, 0, 1))\n</code></pre>"},{"location":"api/deformations/#intrinsic.postprocess.compute_velocities","title":"<code>compute_velocities(phi1l, q1)</code>","text":"<p>Recovery velocities in material frame.</p> <p>Parameters:</p> Name Type Description Default <code>phi1l</code> <code>ndarray</code> <p>Intrinsic velocity modes in local frame</p> required <code>q1</code> <code>ndarray</code> <p>Velocity modal coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Velocity field</p> Source code in <code>feniax/intrinsic/postprocess.py</code> <pre><code>def compute_velocities(phi1l: jnp.ndarray, q1: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Recovery velocities in material frame.\n\n    Parameters\n    ----------\n    phi1l : jnp.ndarray\n        Intrinsic velocity modes in local frame\n    q1 : jnp.ndarray\n        Velocity modal coordinate\n\n    Returns\n    -------\n    jnp.ndarray\n        Velocity field\n\n    \"\"\"\n\n    X1 = jnp.tensordot(phi1l, q1, axes=(0, 1))  # 6xNnxNt\n    return X1.transpose((2, 0, 1)) # Ntx6xNn\n</code></pre>"},{"location":"api/deformations/#intrinsic.postprocess.integrate_strains","title":"<code>integrate_strains(ra_0n, Cab_0n, X3t, sol, fem)</code>","text":"<p>Function to integrate position from strains at a given time step</p> Source code in <code>feniax/intrinsic/postprocess.py</code> <pre><code>def integrate_strains(ra_0n, Cab_0n, X3t, sol, fem):\n    \"\"\"\n    Function to integrate position from strains at a given time step\n    \"\"\"\n\n    ds = sol.data.modes.X_xdelta\n    C0ab = sol.data.modes.C0ab  # 3x3xNn\n    # TODO: make as fori loop\n    Cab = jnp.zeros((3, 3, fem.num_nodes))\n    ra = jnp.zeros((3, fem.num_nodes))\n\n    comp_nodes = jnp.array(fem.component_nodes[fem.component_names[0]])[1:]\n    numcomp_nodes = len(comp_nodes)\n    Cab0_init = C0ab[:, :, 0]\n    init = jnp.hstack([Cab_0n, Cab0_init, ra_0n.reshape((3, 1))])\n    ds_i = ds[comp_nodes]\n    ds_i = jnp.broadcast_to(ds_i, (3, ds_i.shape[0])).T.reshape((numcomp_nodes, 3, 1))\n    strains_i = X3t[:3, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n    kappas_i = X3t[3:, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n    # import pdb; pdb.set_trace()\n    C0ab_i = C0ab[:, :, comp_nodes].transpose((2, 0, 1))\n    xs = jnp.concatenate([C0ab_i, strains_i, kappas_i, ds_i], axis=2)\n    last_carry, Cra = jax.lax.scan(integrate_X3, init, xs)\n    ra = ra.at[:, 0].set(ra_0n)\n    Cab = Cab.at[:, :, 0].set(Cab_0n)\n    ra = ra.at[:, comp_nodes].set(Cra[:, :, 3].T)\n    Cab = Cab.at[:, :, comp_nodes].set(Cra[:, :, :3].transpose((1, 2, 0)))\n\n    for ci in fem.component_names[1:]:\n        comp_father = fem.component_father[ci]\n        comp_nodes = jnp.array(fem.component_nodes[ci])\n        numcomp_nodes = len(comp_nodes)\n        if comp_father is None:\n            node_father = 0\n        else:\n            node_father = fem.component_nodes[comp_father][-1]\n        Cab_init = Cab[:, :, node_father]\n        Cab0_init = C0ab[:, :, node_father]\n        ra_init = ra[:, node_father]\n        init = jnp.hstack([Cab_init, Cab0_init, ra_init.reshape((3, 1))])\n        ds_i = ds[comp_nodes]\n        ds_i = jnp.broadcast_to(ds_i, (3, ds_i.shape[0])).T.reshape(\n            (numcomp_nodes, 3, 1)\n        )\n        strains_i = X3t[:3, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n        kappas_i = X3t[3:, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n        C0ab_i = C0ab[:, :, comp_nodes].transpose((2, 0, 1))\n        xs = jnp.concatenate([C0ab_i, strains_i, kappas_i, ds_i], axis=2)\n        last_carry, Cra = jax.lax.scan(integrate_X3, init, xs)\n        ra = ra.at[:, comp_nodes].set(Cra[:, :, 3].T)\n        Cab = Cab.at[:, :, comp_nodes].set(Cra[:, :, :3].transpose((1, 2, 0)))\n\n    return Cab, ra\n</code></pre>"},{"location":"api/deformations/#intrinsic.postprocess.integrate_strainsl","title":"<code>integrate_strainsl(ra_0n, Cab_0n, X3t, sol, fem)</code>","text":"<p>Function to integrate position from strains at a given time step</p> Source code in <code>feniax/intrinsic/postprocess.py</code> <pre><code>def integrate_strainsl(ra_0n, Cab_0n, X3t, sol, fem):\n    \"\"\"\n    Function to integrate position from strains at a given time step\n    \"\"\"\n\n    ds = sol.data.modes.X_xdelta\n    C0ab = sol.data.modes.C0ab  # 3x3xNn\n    # TODO: make as fori loop\n    Cab = jnp.zeros((3, 3, fem.num_nodes))\n    ra = jnp.zeros((3, fem.num_nodes))\n\n    comp_nodes = jnp.array(fem.component_nodes[fem.component_names[0]])[1:]\n    numcomp_nodes = len(comp_nodes)\n    Cab0_init = C0ab[:, :, 0]\n    init = jnp.hstack([Cab_0n, Cab0_init, ra_0n.reshape((3, 1))])\n    ds_i = ds[comp_nodes]\n    ds_i = jnp.broadcast_to(ds_i, (3, ds_i.shape[0])).T.reshape((numcomp_nodes, 3, 1))\n    strains_i = X3t[:3, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n    kappas_i = X3t[3:, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n    # import pdb; pdb.set_trace()\n    C0ab_i = C0ab[:, :, comp_nodes].transpose((2, 0, 1))\n    xs = jnp.concatenate([C0ab_i, strains_i, kappas_i, ds_i], axis=2)\n    last_carry, Cra = jax.lax.scan(integrate_X3l, init, xs)\n    ra = ra.at[:, 0].set(ra_0n)\n    Cab = Cab.at[:, :, 0].set(Cab_0n)\n    ra = ra.at[:, comp_nodes].set(Cra[:, :, 3].T)\n    Cab = Cab.at[:, :, comp_nodes].set(Cra[:, :, :3].transpose((1, 2, 0)))\n\n    for ci in fem.component_names[1:]:\n        comp_father = fem.component_father[ci]\n        comp_nodes = jnp.array(fem.component_nodes[ci])\n        numcomp_nodes = len(comp_nodes)\n        if comp_father is None:\n            node_father = 0\n        else:\n            node_father = fem.component_nodes[comp_father][-1]\n        Cab_init = Cab[:, :, node_father]\n        Cab0_init = C0ab[:, :, node_father]\n        ra_init = ra[:, node_father]\n        init = jnp.hstack([Cab_init, Cab0_init, ra_init.reshape((3, 1))])\n        ds_i = ds[comp_nodes]\n        ds_i = jnp.broadcast_to(ds_i, (3, ds_i.shape[0])).T.reshape(\n            (numcomp_nodes, 3, 1)\n        )\n        strains_i = X3t[:3, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n        kappas_i = X3t[3:, comp_nodes].T.reshape((numcomp_nodes, 3, 1))\n        C0ab_i = C0ab[:, :, comp_nodes].transpose((2, 0, 1))\n        xs = jnp.concatenate([C0ab_i, strains_i, kappas_i, ds_i], axis=2)\n        last_carry, Cra = jax.lax.scan(integrate_X3l, init, xs)\n        ra = ra.at[:, comp_nodes].set(Cra[:, :, 3].T)\n        Cab = Cab.at[:, :, comp_nodes].set(Cra[:, :, :3].transpose((1, 2, 0)))\n\n    return Cab, ra\n</code></pre>"},{"location":"api/diffrax/","title":"Diffrax","text":""},{"location":"api/diffrax/#systems.sollibs.diffrax.ode","title":"<code>ode(F, args, sett, q0, t0, t1, tn, dt, **kwargs)</code>","text":"<p>Diffrax ODE solover</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def ode(\n    F: callable,\n    args,\n    sett,\n    # solver_name: str,\n    q0,\n    t0,\n    t1,\n    tn,\n    dt,\n    # save_at=None,\n    **kwargs,\n) -&gt; diffrax.Solution:\n    \"\"\"\n    Diffrax ODE solover\n    \"\"\"\n\n    # TODO: Logic should be extended and improved\n\n    solver_sett = dict()\n    diffeqsolve_sett = dict()\n    term = diffrax.ODETerm(F)\n    if sett.save_at is None:\n        saveat = diffrax.SaveAt(\n            ts=jnp.linspace(t0, t1, tn)\n        )  # diffrax.SaveAt(steps=True) #\n    else:\n        saveat = sett.save_at\n    _solver = getattr(diffrax, sett.solver_name)\n    if (root := sett.root_finder) is not None:\n        _root_finder = getattr(optx, list(root.keys())[0])\n        root_finder = _root_finder(**list(root.values())[0])\n        solver_sett[\"root_finder\"] = root_finder\n    solver = _solver(**solver_sett)\n\n    if (stepsize := sett.stepsize_controller) is not None:\n        _stepsize_controller = getattr(optx, list(stepsize.keys())[0])\n        stepsize_controller = _stepsize_controller(**list(stepsize.values())[0])\n        diffeqsolve_sett[\"stepsize_controller\"] = stepsize_controller\n\n    sol = diffrax.diffeqsolve(\n        term,\n        solver,\n        t0=t0,\n        t1=t1,\n        dt0=dt,\n        y0=q0,\n        args=args,\n        # throw=False,\n        max_steps=sett.max_steps,\n        saveat=saveat,\n        **diffeqsolve_sett,\n    )\n    return sol\n</code></pre>"},{"location":"api/diffrax/#systems.sollibs.diffrax.pull_newton","title":"<code>pull_newton(sol)</code>","text":"<p>Extract states from diffrax Newton solution object</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def pull_newton(sol):\n    \"\"\"Extract states from diffrax Newton solution object\n    \"\"\"\n\n    qs = jnp.array(sol.value)\n    return qs\n</code></pre>"},{"location":"api/diffrax/#systems.sollibs.diffrax.pull_ode","title":"<code>pull_ode(sol)</code>","text":"<p>Extract states from diffrax ODE solution object</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def pull_ode(sol):\n    \"\"\"Extract states from diffrax ODE solution object\n    \"\"\"\n\n    qs = jnp.array(sol.ys)\n    return qs\n</code></pre>"},{"location":"api/drivers/","title":"Drivers","text":""},{"location":"api/drivers/#drivers.driver.Driver","title":"<code>Driver</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Initialises the main objects of the program and triggers the simulation</p> Source code in <code>feniax/drivers/driver.py</code> <pre><code>class Driver(ABC):\n    \"\"\" Initialises the main objects of the program and triggers the simulation\n\n    \"\"\"\n    @abstractmethod\n    def _set_simulation(self):\n        \"\"\"Initialise the simulation object\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _set_systems(self):\n        \"\"\"Initialise the system of equations objects\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def pre_simulation(self):\n        \"\"\"Run any computation pre-simulation\n\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def run_cases(self):\n        \"\"\"Trigger the simulations\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def post_simulation(self):\n        \"\"\"Run any computation post-simulation\n\n        For instance the forager pattern that launches other programs\n\n        \"\"\"\n\n        pass\n\n    def __init_subclass__(cls, **kwargs):\n        assert \"cls_name\" in kwargs\n        super().__init_subclass__()\n        if kwargs[\"cls_name\"] in __DRIVER_DICT__:\n            raise ValueError(\"Name %s already registered!\" % kwargs[\"cls_name\"])\n        __DRIVER_DICT__[kwargs[\"cls_name\"]] = cls\n</code></pre>"},{"location":"api/drivers/#drivers.driver.Driver.post_simulation","title":"<code>post_simulation()</code>  <code>abstractmethod</code>","text":"<p>Run any computation post-simulation</p> <p>For instance the forager pattern that launches other programs</p> Source code in <code>feniax/drivers/driver.py</code> <pre><code>@abstractmethod\ndef post_simulation(self):\n    \"\"\"Run any computation post-simulation\n\n    For instance the forager pattern that launches other programs\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/drivers/#drivers.driver.Driver.pre_simulation","title":"<code>pre_simulation()</code>  <code>abstractmethod</code>","text":"<p>Run any computation pre-simulation</p> Source code in <code>feniax/drivers/driver.py</code> <pre><code>@abstractmethod\ndef pre_simulation(self):\n    \"\"\"Run any computation pre-simulation\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/drivers/#drivers.driver.Driver.run_cases","title":"<code>run_cases()</code>  <code>abstractmethod</code>","text":"<p>Trigger the simulations</p> Source code in <code>feniax/drivers/driver.py</code> <pre><code>@abstractmethod\ndef run_cases(self):\n    \"\"\"Trigger the simulations\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/equations/","title":"Equations","text":""},{"location":"api/equations/#static-problems","title":"Static problems","text":""},{"location":"api/equations/#intrinsic.dq_static.dq_10G1","title":"<code>dq_10G1(q, *args)</code>","text":"<p>Structural static under gravity.</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_10G1(q, *args):\n    \"\"\"Structural static under gravity.\"\"\"\n\n    (\n        eta_0,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        x,\n        force_gravity,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n    X3t = postprocess.compute_strains_t(psi2l, q)\n    Rab = postprocess.integrate_strainsCab(\n        jnp.eye(3),\n        X3t,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n    F = omega * q - common.contraction_gamma2(gamma2, q)\n    F += xloads.eta_pointdead(t, phi1l, x, force_gravity, Rab)\n    F += eta_0\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_10G121","title":"<code>dq_10G121(q, *args)</code>","text":"<p>Structural static with dead point forces and gravity.</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_10G121(q, *args):\n    \"\"\"Structural static with dead point forces and gravity.\"\"\"\n\n    (\n        eta_0,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        x,\n        force_dead,\n        force_gravity,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n\n    # @jax.jit\n    def _dq_10g121(q2):\n        X3t = postprocess.compute_strains_t(psi2l, q2)\n        Rab = postprocess.integrate_strainsCab(\n            jnp.eye(3),\n            X3t,\n            X_xdelta,\n            C0ab,\n            component_names,\n            num_nodes,\n            component_nodes,\n            component_father,\n        )\n        F = omega * q2 - common.contraction_gamma2(gamma2, q2)\n        F += xloads.eta_pointdead(t, phi1l, x, force_dead + force_gravity, Rab)\n        F += eta_0\n        return F\n\n    F = _dq_10g121(q)\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_10g11","title":"<code>dq_10g11(q, *args)</code>","text":"<p>Structural static with follower point forces.</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_10g11(q, *args):\n    \"\"\"Structural static with follower point forces.\"\"\"\n\n    (eta_0, gamma2, omega, phi1, x, force_follower, t) = args[0]\n\n    # @jax.jit\n    def _dq_10g11(q):\n        F = omega * q - common.contraction_gamma2(gamma2, q)\n        F += xloads.eta_pointfollower(t, phi1, x, force_follower)\n        F += eta_0\n        return F\n\n    F = _dq_10g11(q)\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_10g121","title":"<code>dq_10g121(q, *args)</code>","text":"<p>Structural static with dead point forces.</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_10g121(q, *args):\n    \"\"\"Structural static with dead point forces.\"\"\"\n\n    (\n        eta_0,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        x,\n        force_dead,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n\n    # @jax.jit\n    def _dq_10g121(q2):\n        X3t = postprocess.compute_strains_t(psi2l, q2)\n        Rab = postprocess.integrate_strainsCab(\n            jnp.eye(3),\n            X3t,\n            X_xdelta,\n            C0ab,\n            component_names,\n            num_nodes,\n            component_nodes,\n            component_father,\n        )\n        F = omega * q2 - common.contraction_gamma2(gamma2, q2)\n        F += xloads.eta_pointdead(t, phi1l, x, force_dead, Rab)\n        F += eta_0\n        return F\n\n    F = _dq_10g121(q)\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_10g15","title":"<code>dq_10g15(q, *args)</code>","text":"<p>Manoeuvre under qalpha.</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_10g15(q, *args):\n    \"\"\"Manoeuvre under qalpha.\"\"\"\n\n    (eta_0, gamma2, omega, x, qalpha, A0hat, C0hat, t) = args[0]\n    q0 = -q / omega\n    F = omega * q - common.contraction_gamma2(gamma2, q)\n    F += xloads.eta_steadyaero(q0, A0hat)\n    F += xloads.eta_manoeuvre(t, x, qalpha, C0hat)\n    F += eta_0\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_11G6","title":"<code>dq_11G6(q, *args)</code>","text":"<p>Static trim1</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_11G6(q, *args):\n    \"\"\"Static trim1\"\"\"\n\n    (\n        eta_0,\n        gamma2,\n        omega,\n        phi1,\n        phi1l,\n        psi2l,\n        x,\n        force_gravity,\n        states,\n        A0hat,\n        B0hat,\n        elevator_index,\n        elevator_link,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n\n    # qe = q[states['qe']]\n    q2 = q[states[\"q2\"]]\n    q0i = -q2[2:] / omega[2:]\n    q0 = jnp.hstack([q2[:2], q0i])\n    qx = q[states[\"qx\"]]\n    X3t = postprocess.compute_strains_t(psi2l, q2)\n    Rab = postprocess.integrate_strainsCab(\n        jnp.eye(3),\n        X3t,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n\n    eta_gravity = xloads.eta_pointdead(t, phi1l, x, force_gravity, Rab)\n    eta_aero = xloads.eta_steadyaero(q0, A0hat)\n    eta_elevator = xloads.eta_controls(qx, B0hat, elevator_index, elevator_link)\n    F1 = omega * q2 - common.contraction_gamma2(gamma2, q2)\n    F1 += eta_gravity + eta_aero + eta_elevator\n    F1 += eta_0\n    Fh = phi1[:, 2, 0].dot(q0)  # added eq: 0 vertical position of first node\n    # import jax.debug; jax.debug.breakpoint()\n    F = jnp.hstack([F1, Fh])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_11G6l","title":"<code>dq_11G6l(q, *args)</code>","text":"<p>Static trim1 linear</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_11G6l(q, *args):\n    \"\"\"Static trim1 linear\"\"\"\n\n    (\n        eta_0,\n        omega,\n        phi1,\n        phi1l,\n        psi2l,\n        x,\n        force_gravity,\n        states,\n        A0hat,\n        B0hat,\n        elevator_index,\n        elevator_link,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n\n    # qe = q[states['qe']]\n    q2 = q[states[\"q2\"]]\n    q0i = -q2[2:] / omega[2:]\n    q0 = jnp.hstack([q2[:2], q0i])\n    qx = q[states[\"qx\"]]\n    X3t = postprocess.compute_strains_t(psi2l, q2)\n    # Rab = postprocess.integrate_strainsCab(\n    #     jnp.eye(3), X3t,\n    #     X_xdelta, C0ab,\n    #     component_names,\n    #     num_nodes,\n    #     component_nodes,\n    #     component_father)\n\n    eta_gravity = xloads.eta_pointdead(t, phi1l, x, force_gravity, C0ab)\n    eta_aero = xloads.eta_steadyaero(q0, A0hat)\n    eta_elevator = xloads.eta_controls(qx, B0hat, elevator_index, elevator_link)\n    F1 = omega * q2  # - common.contraction_gamma2(gamma2, q2)\n    F1 += eta_gravity + eta_aero + eta_elevator\n    F1 += eta_0\n    Fh = phi1[:, 2, 0].dot(q0)  # added eq: 0 vertical position of first node\n    # import jax.debug; jax.debug.breakpoint()\n    F = jnp.hstack([F1, Fh])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_static.dq_12G2","title":"<code>dq_12G2(q, *args)</code>","text":"<p>Static trim2</p> <p>TODO: FINALISE!</p> Source code in <code>feniax/intrinsic/dq_static.py</code> <pre><code>def dq_12G2(q, *args):\n    \"\"\"Static trim2\n\n    TODO: FINALISE!\n    \"\"\"\n\n    (\n        eta_0,\n        gamma2,\n        omega,\n        phi1l,\n        x,\n        force_gravity,\n        states,\n        A0hat,\n        B0hat,\n        C0hat,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n        t,\n    ) = args[0]\n\n    # qalpha = q[states['qalpha']]\n    # qe = q[states['qe']]\n    q2i = q[states[\"q2\"]]\n    q0i = -q2i / omega[2:]\n    qalpha = q[states[\"qalpha\"]]\n    qx = q[states[\"qx\"]]\n    q2 = jnp.hstack([0.0, 0.0, q[states[\"q2\"]]])\n    q0 = jnp.hstack([0.0, 0.0, q0i])\n    jnp.hstack([0.0, 0.0, qalpha])\n    qm = jnp.hstack([0.0, 0.0, qalpha])\n    eta_gravity = xloads.eta_pointdead(t, phi1l, x, force_gravity, C0ab)\n    eta_aero = xloads.eta_steadyaero(q0, A0hat)\n    eta_aoa = xloads.eta_manoeuvre(qm, C0hat)\n    eta_elevator = xloads.eta_control(qx, B0hat)\n    F = omega * q2 - common.contraction_gamma2(gamma2, q2)\n    F += eta_gravity + eta_aero + eta_elevator\n    F += eta_0\n    return F\n</code></pre>"},{"location":"api/equations/#dynamic-problems","title":"Dynamic problems","text":""},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20G2","title":"<code>dq_20G2(t, q, *args)</code>","text":"<p>Free Structural dynamic gravity forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20G2(t, q, *args):\n    \"\"\"Free Structural dynamic gravity forces.\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        force_gravity,\n        states,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    qr = q[states[\"qr\"]]\n\n    Rab = common.computeRab_node0(\n        psi2l,\n        q2,\n        qr,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n\n    # no interpolation of gravity in dynamic case\n    eta = xloads.eta_pointdead_const(phi1l, force_gravity[-1], Rab)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta\n    F1 += eta_0\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F = jnp.hstack([F1, F2, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20G546","title":"<code>dq_20G546(t, q, *args)</code>","text":"<p>Free flight with gravity forces and rigid body DoF, and gust</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20G546(t, q, *args):\n    \"\"\"Free flight with gravity forces and rigid body DoF, and gust\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        xgust,\n        F1gust,\n        Flgust,\n        force_gravity,\n        states,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    qr = q[states[\"qr\"]]\n\n    Rab = common.computeRab_node0(\n        psi2l,\n        q2,\n        qr,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n\n    # no interpolation of gravity in dynamic case\n    eta_gravity = xloads.eta_pointdead_const(phi1l, force_gravity[-1], Rab)\n    eta_aero = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_aero + eta_gravity + eta_gust\n    F1 += eta_0\n    # jax.debug.print(\"time: {t}\", t=t)\n    # jax.debug.print(\"eta_aero: {eta_aero}\", eta_aero=(eta_gust))\n    # jax.debug.breakpoint()\n    F1 = A2hatinv @ F1  # Nm\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    Fl += Flgust\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F0 = q1\n    F = jnp.hstack([F1, F2, Fl, F0, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20G546l","title":"<code>dq_20G546l(t, q, *args)</code>","text":"<p>Free flight with gravity forces and rigid body DoF, and gust (LINEAR)</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20G546l(t, q, *args):\n    \"\"\"Free flight with gravity forces and rigid body DoF, and gust\n    (LINEAR)\"\"\"\n\n    (\n        eta_0,\n        omega,\n        phi1l,\n        psi2l,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        xgust,\n        F1gust,\n        Flgust,\n        force_gravity,\n        states,\n        C0ab,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    qr = q[states[\"qr\"]]\n\n    # Rab = common.computeRab_node0(psi2l, q2, qr, X_xdelta, C0ab,\n    #                               component_names,\n    #                                num_nodes,\n    #                                component_nodes,\n    #                                component_father)\n\n    # no interpolation of gravity in dynamic case\n    eta_gravity = xloads.eta_pointdead_const(phi1l, force_gravity[-1], C0ab)\n    eta_aero = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    F1, F2 = common.f_12l(omega, q1, q2)\n    F1 += eta_aero + eta_gravity + eta_gust\n    F1 += eta_0\n    # jax.debug.print(\"time: {t}\", t=t)\n    # jax.debug.print(\"eta_aero: {eta_aero}\", eta_aero=(eta_gust))\n    # jax.debug.breakpoint()\n    F1 = A2hatinv @ F1  # Nm\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    Fl += Flgust\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F0 = q1\n    F = jnp.hstack([F1, F2, Fl, F0, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20G78","title":"<code>dq_20G78(t, q, *args)</code>","text":"<p>Free flight with gravity forces and rigid body DoF</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20G78(t, q, *args):\n    \"\"\"Free flight with gravity forces and rigid body DoF\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        force_gravity,\n        states,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    qr = q[states[\"qr\"]]\n\n    Rab = common.computeRab_node0(\n        psi2l,\n        q2,\n        qr,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n\n    # no interpolation of gravity in dynamic case\n    eta_gravity = xloads.eta_pointdead_const(phi1l, force_gravity[-1], Rab)\n    eta_aero = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_aero + eta_gravity\n    F1 += eta_0\n    # jax.debug.print(\"time: {t}\", t=t)\n    # jax.debug.print(\"eta_aero: {eta_aero}\", eta_aero=(eta_gust))\n    # jax.debug.breakpoint()\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F0 = q1\n    F = jnp.hstack([F1, F2, Fl, F0, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20G78l","title":"<code>dq_20G78l(t, q, *args)</code>","text":"<p>Free flight with gravity forces and rigid body DoF (LINEAR)</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20G78l(t, q, *args):\n    \"\"\"Free flight with gravity forces and rigid body DoF (LINEAR)\"\"\"\n\n    (\n        eta_0,\n        omega,\n        phi1l,\n        psi2l,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        force_gravity,\n        states,\n        C0ab,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    qr = q[states[\"qr\"]]\n\n    # Rab = common.computeRab_node0(psi2l, q2, qr, X_xdelta, C0ab,\n    #                               component_names,\n    #                                num_nodes,\n    #                                component_nodes,\n    #                                component_father)\n\n    # no interpolation of gravity in dynamic case\n    eta_gravity = xloads.eta_pointdead_const(phi1l, force_gravity[-1], C0ab)\n    eta_aero = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    F1, F2 = common.f_12l(omega, q1, q2)\n    F1 += eta_aero + eta_gravity\n    F1 += eta_0\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F0 = q1\n    F = jnp.hstack([F1, F2, Fl, F0, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g1","title":"<code>dq_20g1(t, q, *args)</code>","text":"<p>Clamped Structural dynamics, free vibrations.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g1(t, q, *args):\n    \"\"\"Clamped Structural dynamics, free vibrations.\"\"\"\n\n    eta_0, gamma1, gamma2, omega, states = args[0]\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_0\n    F = jnp.hstack([F1, F2])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g11","title":"<code>dq_20g11(t, q, *args)</code>","text":"<p>Clamped structural dynamic follower point forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g11(t, q, *args):\n    \"\"\"Clamped structural dynamic follower point forces.\"\"\"\n\n    (eta_0, gamma1, gamma2, omega, phi1, x, force_follower, states) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    eta = xloads.eta_pointfollower(t, phi1, x, force_follower)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta\n    F1 += eta_0\n    F = jnp.hstack([F1, F2])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g121","title":"<code>dq_20g121(t, q, *args)</code>","text":"<p>Clamped structural dynamic dead point forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g121(t, q, *args):\n    \"\"\"Clamped structural dynamic dead point forces.\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        x,\n        force_dead,\n        states,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    ) = args[0]\n\n    q1i = q[states[\"q1\"]]\n    q2i = q[states[\"q2\"]]\n\n    # @jax.jit\n    def _dq_20g121(t, q1, q2):\n        X3t = postprocess.compute_strains_t(psi2l, q2)\n        Rab = postprocess.integrate_strainsCab(\n            jnp.eye(3),\n            X3t,\n            X_xdelta,\n            C0ab,\n            component_names,\n            num_nodes,\n            component_nodes,\n            component_father,\n        )\n        eta = xloads.eta_pointdead(t, phi1l, x, force_dead, Rab)\n        F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n        F1 += eta\n        F1 += eta_0\n        F = jnp.hstack([F1, F2])\n        return F\n\n    F = _dq_20g121(t, q1i, q2i)\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g2","title":"<code>dq_20g2(t, q, *args)</code>","text":"<p>Free structural dynamic no external forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g2(t, q, *args):\n    \"\"\"Free structural dynamic no external forces.\"\"\"\n\n    (eta_0, gamma1, gamma2, omega, phi1l, states) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    qr = q[states[\"qr\"]]    \n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_0\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F = jnp.hstack([F1, F2, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g21","title":"<code>dq_20g21(t, q, *args)</code>","text":"<p>Gust response, clamped model</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g21(t, q, *args):\n    \"\"\"Gust response, clamped model\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        states,\n        poles,        \n        num_modes,\n        num_poles,\n        xgust,\n        c_ref,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        F1gust,\n        Flgust,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    q0 = -q2 / omega\n    ql = q[states[\"ql\"]]\n    # jax.debug.breakpoint()\n    # ql_tensor = ql.reshape((num_modes, num_poles))\n    eta_s = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    # jax.debug.breakpoint()\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_s + eta_gust\n    F1 += eta_0\n    # jax.debug.print(\"time: {t}\", t=t)\n    # jax.debug.print(\"eta_aero: {eta_aero}\", eta_aero=(eta_gust))\n    # jax.debug.breakpoint()\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    # Fl1 = xloads.lags_rogerstructure1(A3hat, q1, ql, u_inf,\n    #                                 c_ref, poles,\n    #                                 num_modes, num_poles)  # NlxNm\n    # Fl2 = xloads.lags_rogerstructure2(A3hat, q1, ql, u_inf,\n    #                                 c_ref, poles,\n    #                                 num_modes, num_poles)  # NlxNm\n    # Fl = Fl1 + Fl2\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)  # NlxNm\n    # jax.debug.breakpoint()\n    Fl += Flgust\n    # jax.debug.print(\"eta_gust {eta_gust}\", eta_gust=xgust)\n    # Fl = Fl_tensor.reshape(num_modes * num_poles\n    return jnp.hstack([F1, F2, Fl])\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g21l","title":"<code>dq_20g21l(t, q, *args)</code>","text":"<p>Gust response.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g21l(t, q, *args):\n    \"\"\"Gust response.\"\"\"\n\n    (\n        eta_0,\n        omega,\n        states,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        xgust,\n        F1gust,\n        Flgust,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    q0 = -q2 / omega\n    ql = q[states[\"ql\"]]\n    # jax.debug.breakpoint()\n    # ql_tensor = ql.reshape((num_modes, num_poles))\n    eta_s = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    # jax.debug.breakpoint()\n    F1, F2 = common.f_12l(omega, q1, q2)\n    F1 += eta_s + eta_gust\n    F1 += eta_0\n    # jax.debug.print(\"time: {t}\", t=t)\n    # jax.debug.print(\"eta_aero: {eta_aero}\", eta_aero=(eta_gust))\n    # jax.debug.breakpoint()\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    # Fl1 = xloads.lags_rogerstructure1(A3hat, q1, ql, u_inf,\n    #                                 c_ref, poles,\n    #                                 num_modes, num_poles)  # NlxNm\n    # Fl2 = xloads.lags_rogerstructure2(A3hat, q1, ql, u_inf,\n    #                                 c_ref, poles,\n    #                                 num_modes, num_poles)  # NlxNm\n    # Fl = Fl1 + Fl2\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)  # NlxNm\n    # jax.debug.breakpoint()\n    Fl += Flgust\n    # Fl = Fl_tensor.reshape(num_modes * num_poles\n    return jnp.hstack([F1, F2, Fl])\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g22","title":"<code>dq_20g22(t, q, *args)</code>","text":"<p>Free structural dynamic follower point forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g22(t, q, *args):\n    \"\"\"Free structural dynamic follower point forces.\"\"\"\n\n    (eta_0, gamma1, gamma2, omega, phi1, x, force_follower, states) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    eta = xloads.eta_pointfollower(t, phi1, x, force_follower)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta\n    F1 += eta_0\n    F = jnp.hstack([F1, F2])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g242","title":"<code>dq_20g242(t, q, *args)</code>","text":"<p>Free Structural dynamic dead point forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g242(t, q, *args):\n    \"\"\"Free Structural dynamic dead point forces.\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,\n        psi2l,\n        x,\n        force_dead,\n        states,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    qr = q[states[\"qr\"]]\n\n    Rab = common.computeRab_node0(\n        psi2l,\n        q2,\n        qr,\n        X_xdelta,\n        C0ab,\n        component_names,\n        num_nodes,\n        component_nodes,\n        component_father,\n    )\n    eta = xloads.eta_pointdead(t, phi1l, x, force_dead, Rab)\n    # import jax.debug; jax.debug.breakpoint()\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta\n    F1 += eta_0\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F = jnp.hstack([F1, F2, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g273","title":"<code>dq_20g273(t, q, *args)</code>","text":"<p>Gust response, q0 obtained via integrator q1.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g273(t, q, *args):\n    \"\"\"Gust response, q0 obtained via integrator q1.\"\"\"\n\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        states,\n        num_modes,\n        num_poles,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        c_ref,\n        poles,\n        xgust,\n        F1gust,\n        Flgust,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    # ql_tensor = ql.reshape((num_modes, num_poles))\n    eta_s = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_s + eta_gust\n    F1 += eta_0\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)  # NlxNm\n    Fl += Flgust\n    F0 = q1\n    # Fl = Fl_tensor.reshape(num_modes * num_poles\n    return jnp.hstack([F1, F2, Fl, F0])\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g2gamma1","title":"<code>dq_20g2gamma1(t, q, *args)</code>","text":"<p>Free structural dynamic no external forces.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g2gamma1(t, q, *args):\n    \"\"\"Free structural dynamic no external forces.\"\"\"\n\n    (eta_0, gamma1, omega, phi1l, states) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    qr = q[states[\"qr\"]]\n    F1, F2 = common.f_12gamma1(omega, gamma1, q1, q2)\n    F1 += eta_0\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F = jnp.hstack([F1, F2, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g2l","title":"<code>dq_20g2l(t, q, *args)</code>","text":"<p>Free structural dynamic no external forces. Linear</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g2l(t, q, *args):\n    \"\"\"Free structural dynamic no external forces. Linear\"\"\"\n\n    (eta_0, omega, phi1l, states) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    qr = q[states[\"qr\"]]    \n    F1, F2 = common.f_12l(omega, q1, q2)\n    F1 += eta_0\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F = jnp.hstack([F1, F2, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#intrinsic.dq_dynamic.dq_20g546","title":"<code>dq_20g546(t, q, *args)</code>","text":"<p>Gust response free flight, q0 obtained via integrator q1.</p> Source code in <code>feniax/intrinsic/dq_dynamic.py</code> <pre><code>def dq_20g546(t, q, *args):\n    \"\"\"Gust response free flight, q0 obtained via integrator q1.\"\"\"\n\n    # (\n    #     eta_0,\n    #     gamma1,\n    #     gamma2,\n    #     omega,\n    #     phi1l,\n    #     states,\n    #     num_modes,\n    #     num_poles,\n    #     A0hat,\n    #     A1hat,\n    #     A2hatinv,\n    #     A3hat,\n    #     u_inf,\n    #     c_ref,\n    #     poles,\n    #     xgust,\n    #     F1gust,\n    #     Flgust,\n    # ) = args[0]\n    (\n        eta_0,\n        gamma1,\n        gamma2,\n        omega,\n        phi1l,        \n        states,\n        poles,        \n        num_modes,\n        num_poles,\n        xgust,\n        c_ref,\n        A0hat,\n        A1hat,\n        A2hatinv,\n        A3hat,\n        u_inf,\n        F1gust,\n        Flgust,\n    ) = args[0]\n\n    q1 = q[states[\"q1\"]]\n    q2 = q[states[\"q2\"]]\n    ql = q[states[\"ql\"]]\n    q0 = q[states[\"q0\"]]\n    qr = q[states[\"qr\"]]\n\n    # ql_tensor = ql.reshape((num_modes, num_poles))\n    eta_s = xloads.eta_rogerstruct(q0, q1, ql, A0hat, A1hat, num_modes, num_poles)\n    eta_gust = xloads.eta_rogergust(t, xgust, F1gust)\n    F1, F2 = common.f_12(omega, gamma1, gamma2, q1, q2)\n    F1 += eta_s + eta_gust\n    F1 += eta_0\n    F1 = A2hatinv @ F1  # Nm\n    Fl = xloads.lags_rogerstructure(\n        A3hat, q1, ql, u_inf, c_ref, poles, num_modes, num_poles\n    )  # NlxNm\n    Flgust = xloads.lags_rogergust(t, xgust, Flgust)  # NlxNm\n    Fl += Flgust\n    Fr = common.f_quaternion(phi1l, q1, qr)\n    F0 = q1\n    F = jnp.hstack([F1, F2, Fl, F0, Fr])\n    return F\n</code></pre>"},{"location":"api/equations/#helper-functions","title":"Helper functions","text":""},{"location":"api/equations/#intrinsic.dq_common.contraction_gamma1","title":"<code>contraction_gamma1(gamma1, q1)</code>","text":"<p>Contraction of Gamma1 with velocity modal coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>gamma1</code> <code>ndarray</code> <p>3rd order tensor (NmxNmxNm) with velocity modal couplings</p> required <code>q1</code> <code>ndarray</code> <p>velocity modal coordinate</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Gamma1xq1xq1 (Nmx1)</p> Source code in <code>feniax/intrinsic/dq_common.py</code> <pre><code>@jax.jit\ndef contraction_gamma1(gamma1: jnp.ndarray, q1: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Contraction of Gamma1 with velocity modal coordinate.\n\n    Parameters\n    ----------\n    gamma1 : jnp.ndarray\n        3rd order tensor (NmxNmxNm) with velocity modal couplings\n    q1 : jnp.ndarray\n        velocity modal coordinate\n\n    Returns\n    -------\n    jnp.ndarray\n        Gamma1xq1xq1 (Nmx1)\n    \"\"\"\n    res = jnp.einsum(\"ijk,jk-&gt;i\", gamma1, jnp.tensordot(q1, q1, axes=0))\n    return res\n</code></pre>"},{"location":"api/inputs/","title":"Input containers","text":""},{"location":"api/inputs/#intrinsic-modal-solution","title":"Intrinsic modal solution","text":"<p>Containers for the intrinsic modal solution settings</p>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DGustMc","title":"<code>DGustMc</code>","text":"<p>               Bases: <code>DGust</code></p> <p>1-cos gust settings (specialisation from DGust)</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <p>Flow velocity</p> required <code>simulation_time</code> <code>Array</code> <p>Time array for the simulation</p> required <code>intensity</code> <code>float</code> <p>Gust intensity</p> required <code>step</code> <code>float</code> <p>Gust discretisation in x-direction --gust dx</p> required <code>time_epsilon</code> <p>Epsilon time between the gust first hitting the AC and the next interpolation point</p> required <code>length</code> <code>float</code> <p>Gust length</p> required <code>shift</code> <code>float</code> <p>Shift gust position</p> required <code>panels_dihedral</code> <code>str | Array</code> <p>Proportional array with cosines for dihedral</p> required <code>collocation_points</code> <code>str | Array</code> <p>Collocation points coordinates</p> required <code>shape</code> <code>str</code> <p>Span-wise shape</p> required <p>Attributes:</p> Name Type Description <code>totaltime</code> <code>float</code> <p>gust_length / u_inf</p> <code>x</code> <code>Array</code> <p>Discretisation in flow direction</p> <code>time</code> <code>Array</code> <p>Times at which gust quantities are interpolated (driven by step and u_inf) </p> <code>ntime</code> <code>int</code> <p>len(time)</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DGustMc(DGust):\n    \"\"\"1-cos gust settings (specialisation from DGust)\n\n    Parameters\n    ----------\n    u_inf : float\n         Flow velocity     \n    simulation_time : Array\n         Time array for the simulation\n    intensity : float\n         Gust intensity\n    step : float\n         Gust discretisation in x-direction --gust dx\n    time_epsilon: float\n         Epsilon time between the gust first hitting the AC and the next interpolation point\n    length : float\n         Gust length\n    shift : float\n         Shift gust position\n    panels_dihedral : str | jax.Array\n         Proportional array with cosines for dihedral \n    collocation_points : str | jax.Array\n         Collocation points coordinates\n    shape : str\n         Span-wise shape\n\n    Attributes\n    ----------\n    totaltime : float\n        gust_length / u_inf\n    x : Array\n        Discretisation in flow direction\n    time : Array\n        Times at which gust quantities are interpolated (driven by step and u_inf) \n    ntime : int\n        len(time)\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    simulation_time: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    intensity: float = dfield(\"\", default=None)\n    step: float = dfield(\"\", default=None)\n    time_epsilon: float = dfield(\"\", default=1e-6)\n    length: float = dfield(\"\", default=None)\n    shift: float = dfield(\"\", default=0.0)\n    panels_dihedral: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    collocation_points: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    collocation_points_path: str = dfield(\"\", default=None)\n    shape: str = dfield(\"\",\n                        default=\"const\")\n    fixed_discretisation: dict[str: float] = dfield(\"\",\n                                                    default=None)\n    totaltime: float = dfield(\"\", init=False)\n    x: jnp.ndarray = dfield(\"\", init=False)\n    time: jnp.ndarray = dfield(\"\", init=False)\n    ntime: int = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        if isinstance(self.panels_dihedral, (str, pathlib.Path)):\n            object.__setattr__(self, \"panels_dihedral\", jnp.load(self.panels_dihedral))\n        if isinstance(self.collocation_points, (str, pathlib.Path)):\n            object.__setattr__(self,\n                               \"collocation_points_path\",\n                               os.path.abspath(self.collocation_points)\n                               )            \n            object.__setattr__(self, \"collocation_points\", jnp.load(self.collocation_points))\n\n        elif self.collocation_points_path is not None:\n            object.__setattr__(self, \"collocation_points\", jnp.load(self.collocation_points_path))\n            object.__setattr__(self,\n                               \"collocation_points_path\",\n                               os.path.abspath(self.collocation_points_path)\n                               )\n        object.__setattr__(self, \"panels_dihedral\", jnp.array(self.panels_dihedral))\n        object.__setattr__(self, \"collocation_points\", jnp.array(self.collocation_points))    \n        # self.panels_dihedral = jnp.array(self.panels_dihedral)\n        # self.collocation_points = jnp.array(self.collocation_points)\n\n        # gust_totaltime, xgust, time, ntime = self._set_gustDiscretization(\n        #     self.intensity,\n        #     self.panels_dihedral,\n        #     self.shift,\n        #     self.step,\n        #     self.simulation_time,\n        #     self.length,\n        #     self.u_inf,\n        #     jnp.min(self.collocation_points[:, 0]),\n        #     jnp.max(self.collocation_points[:, 0]),\n        # )\n        if self.fixed_discretisation is None:\n            gust_totaltime, xgust, time, ntime = gust_discretisation(\n                self.shift,\n                self.step,\n                self.simulation_time,\n                self.length,\n                self.u_inf,\n                float(jnp.min(self.collocation_points[:, 0])),\n                float(jnp.max(self.collocation_points[:, 0])),\n            )\n        else:\n            gust_totaltime, xgust, time, ntime = gust_discretisation(\n                self.shift,\n                self.step,\n                self.simulation_time,\n                self.fixed_discretisation[0],\n                self.fixed_discretisation[1],                \n                float(jnp.min(self.collocation_points[:, 0])),\n                float(jnp.max(self.collocation_points[:, 0])),\n            )\n\n        object.__setattr__(self, \"totaltime\", gust_totaltime)\n        object.__setattr__(self, \"x\", xgust)\n        object.__setattr__(self, \"time\", time)\n        object.__setattr__(self, \"ntime\", ntime)\n        # del self.simulation_time\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DShard","title":"<code>DShard</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>settings</p> <p>Parameters:</p> Name Type Description Default <code>input_type</code> <code>str</code> required <code>label</code> <code>str</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DShard(DataContainer):\n    \"\"\" settings\n\n    Parameters\n    ----------\n    input_type : str\n    label : str\n\n    \"\"\"\n\n    inputs: dict = dfield(\"\", default=None, yaml_save=False)\n    input_type: str = dfield(\"\", default=None, options=ShardinputType._member_names_)\n    label: str = dfield(\"\", default=None, init=False)\n\n    def __post_init__(self):\n        label = ShardinputType[self.input_type.upper()].value\n        object.__setattr__(self, \"label\", label)\n        input_class = globals()[f\"DShard_{self.input_type.lower()}\"]\n        object.__setattr__(\n            self,\n            \"inputs\",\n            initialise_Dclass(\n                self.inputs,\n                input_class\n            ),\n        )\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DShard_gust1","title":"<code>DShard_gust1</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Point forces</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DShard_gust1(DataContainer):\n    \"\"\"Point forces\n\n    Parameters\n    ----------\n\n    \"\"\"\n    rho_inf: jnp.ndarray = dfield(\"\", default=None)\n    u_inf: jnp.ndarray = dfield(\"\", default=None)\n    length: jnp.ndarray = dfield(\"\", default=None)\n    intensity: jnp.ndarray = dfield(\"\", default=None)\n    def __post_init__(self):\n\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DShard_pointforces","title":"<code>DShard_pointforces</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Point forces</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DShard_pointforces(DataContainer):\n    \"\"\"Point forces\n\n    Parameters\n    ----------\n\n    \"\"\"\n\n    follower_points: jnp.ndarray = dfield(\"\", default=None)\n    follower_interpolation: jnp.ndarray = dfield(\"\", default=None)\n    dead_points: jnp.ndarray = dfield(\"\", default=None)\n    dead_interpolation: jnp.ndarray = dfield(\"\", default=None)\n    gravity: jnp.ndarray = dfield(\"\", default=None)\n    gravity_vect: jnp.ndarray = dfield(\"\", default=None)\n\n    def __post_init__(self):\n        if self.follower_points is not None:\n            object.__setattr__(self, \"follower_points\", jnp.array(self.follower_points))\n        if self.follower_interpolation is not None:\n            object.__setattr__(self, \"follower_interpolation\", jnp.array(self.follower_interpolation))\n        if self.dead_points is not None:\n            object.__setattr__(self, \"dead_points\", jnp.array(self.dead_points))\n        if self.dead_interpolation is not None:                 \n            object.__setattr__(self, \"dead_interpolation\", jnp.array(self.dead_interpolation))\n        if self.gravity is not None:\n            object.__setattr__(self, \"gravity\", jnp.array(self.gravity))\n        if self.gravity_vect is not None:            \n            object.__setattr__(self, \"gravity_vect\", jnp.array(self.gravity_vect))        \n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DShard_steadyalpha","title":"<code>DShard_steadyalpha</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Point forces</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DShard_steadyalpha(DataContainer):\n    \"\"\"Point forces\n\n    Parameters\n    ----------\n\n    \"\"\"\n\n    rho_inf: jnp.ndarray = dfield(\"\", default=None)\n    u_inf: jnp.ndarray = dfield(\"\", default=None)\n    aeromatrix: list[int] = dfield(\"\", default=None)\n    def __post_init__(self):\n\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Daero","title":"<code>Daero</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Modal aerodynamic settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <p>Flow velocity</p> required <code>rho_inf</code> <code>float</code> <p>Flow density</p> required <code>q_inf</code> <code>float</code> <p>Flow dynamic pressure</p> required <code>c_ref</code> <code>float</code> <p>Reference chord</p> required <code>time</code> <code>Array</code> <p>Simulation time array</p> required <code>qalpha</code> <code>Array</code> required <code>qx</code> <code>Array</code> required <code>elevator_index</code> <code>Array</code> required <code>elevator_link</code> <code>Array</code> required <code>approx</code> <code>str</code> <p>Aero approximation Options = Roger</p> required <code>Qk_struct</code> <code>list</code> <p>Sample frequencies and corresponding AICs for the structure</p> required <code>Qk_gust</code> <code>list</code> required <code>Qk_controls</code> <code>list</code> required <code>Q0_rigid</code> <code>Array</code> required <code>A</code> <code>str | Array</code> required <code>B</code> <code>str | Array</code> required <code>C</code> <code>str | Array</code> required <code>D</code> <code>str | Array</code> required <code>_controls</code> <code>list</code> required <code>poles</code> <code>str | Array</code> <p>Poles array</p> required <code>num_poles</code> <code>int</code> <p>Number of poles</p> required <code>gust_profile</code> <code>str</code> <p>Gust name options=[\"mc\"]</p> required <code>gust</code> <code>dict | DGust</code> <p>Gust settings</p> required <code>controller_name</code> <code>dict</code> required <code>controller_settings</code> <code>dict</code> required <code>controller</code> <code>DController</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Daero(DataContainer):\n    \"\"\"Modal aerodynamic settings for each system\n\n    Parameters\n    ----------\n    u_inf : float\n        Flow velocity\n    rho_inf : float\n        Flow density\n    q_inf : float\n        Flow dynamic pressure\n    c_ref : float\n        Reference chord\n    time : Array\n        Simulation time array\n    qalpha : Array\n    qx : Array\n    elevator_index : Array\n    elevator_link : Array\n    approx : str\n        Aero approximation Options = Roger\n    Qk_struct : list\n        Sample frequencies and corresponding AICs for the structure\n    Qk_gust : list\n    Qk_controls : list\n    Q0_rigid : Array\n    A : str | jax.Array\n    B : str | jax.Array\n    C : str | jax.Array\n    D : str | jax.Array\n    _controls : list\n    poles : str | jax.Array\n         Poles array\n    num_poles : int\n         Number of poles\n    gust_profile : str\n        Gust name options=[\"mc\"]\n    gust : dict | __main__.DGust\n        Gust settings \n    controller_name : dict\n    controller_settings : dict\n    controller : DController\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    rho_inf: float = dfield(\"\", default=None)\n    q_inf: float = dfield(\"\", init=False)\n    c_ref: float = dfield(\"\", default=None)\n    time: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    qalpha: jnp.ndarray = dfield(\"\", default=None)\n    qx: jnp.ndarray = dfield(\"\", default=None)\n    elevator_index: jnp.ndarray = dfield(\"\", default=None)\n    elevator_link: jnp.ndarray = dfield(\"\", default=None)\n    #\n    approx: str = dfield(\"\", default=\"Roger\")\n    Qk_struct: list[jnp.ndarray, jnp.ndarray] = dfield(\n        \"\",\n        default=None,\n        yaml_save=False,\n    )\n    Qk_gust: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None, yaml_save=False)\n    Qk_controls: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None, yaml_save=False)\n    Q0_rigid: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    A: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    B: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    C: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    D: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    _controls: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None)\n    poles: str | jnp.ndarray = dfield(\"\", default=None)\n    num_poles: int = dfield(\"\", default=None)\n    gust_profile: str = dfield(\"\", default=\"mc\", options=[\"mc\"])\n    # gust_settings: dict = dfield(\"\", default=None, yaml_save=False)\n    gust: dict | DGust = dfield(\"Gust settings\", default=None)\n    controller_name: dict = dfield(\"\", default=None)\n    controller_settings: dict = dfield(\"\", default=None)\n    controller: DController = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"approx\", self.approx.capitalize())\n        if self.gust is not None:\n            gust_class = globals()[f\"DGust{self.gust_profile.capitalize()}\"]\n            object.__setattr__(\n                self,\n                \"gust\",\n                # initialise_Dclass(self.gust, gust_class))\n                initialise_Dclass(\n                    self.gust, gust_class, u_inf=self.u_inf, simulation_time=self.time\n                ),\n            )\n\n        if self.controller_name is not None:\n            controller_class = globals()[f\"DController{self.controller_name.upper()}\"]\n            controller_obj = initialise_Dclass(self.controller_settings, controller_class)\n            object.__setattr__(self, \"controller\", controller_obj)\n        else:\n            object.__setattr__(self, \"controller\", None)\n        if isinstance(self.poles, (str, pathlib.Path)):\n            object.__setattr__(self, \"poles\", jnp.load(self.poles))\n        if self.elevator_link is not None:\n            object.__setattr__(self, \"elevator_link\", jnp.array(self.elevator_link))\n        if self.elevator_index is not None:\n            object.__setattr__(self, \"elevator_index\", jnp.array(self.elevator_index))\n        if self.poles is not None:\n            object.__setattr__(self, \"num_poles\", len(self.poles))\n        if self.u_inf is not None and self.rho_inf is not None:\n            q_inf = 0.5 * self.rho_inf * self.u_inf**2\n            object.__setattr__(self, \"q_inf\", q_inf)\n        if isinstance(self.Q0_rigid, (str, pathlib.Path)):\n            object.__setattr__(self, \"Q0_rigid\", jnp.load(self.Q0_rigid))            \n        if isinstance(self.A, (str, pathlib.Path)):\n            object.__setattr__(self, \"A\", jnp.load(self.A))\n        if isinstance(self.B, (str, pathlib.Path)):\n            object.__setattr__(self, \"B\", jnp.load(self.B))\n        if isinstance(self.C, (str, pathlib.Path)):\n            object.__setattr__(self, \"C\", jnp.load(self.C))\n        if isinstance(self.D, (str, pathlib.Path)):\n            object.__setattr__(self, \"D\", jnp.load(self.D))\n        if self.qalpha is not None and not isinstance(self.qalpha, jnp.ndarray):\n            object.__setattr__(self, \"qalpha\", jnp.array(self.qalpha))\n\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dconst","title":"<code>Dconst</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Constants in the configuration</p> <p>Parameters:</p> Name Type Description Default <code>I3</code> <code>Array</code> <p>3x3 Identity matrix</p> required <code>e1</code> <code>Array</code> <p>3-component vector with beam direction in local frame</p> required <code>EMAT</code> <code>Array</code> <p>3x3 Identity matrix</p> required <p>Attributes:</p> Name Type Description <code>EMATT</code> <code>Array</code> <p>Transpose EMAT</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@filter_kwargs\n@Ddataclass\nclass Dconst(DataContainer):\n    \"\"\"Constants in the configuration\n\n    Parameters\n    ----------\n    I3 : Array\n       3x3 Identity matrix\n    e1 : Array\n       3-component vector with beam direction in local frame\n    EMAT : Array\n       3x3 Identity matrix\n\n    Attributes\n    ----------\n    EMATT : Array\n       Transpose EMAT\n\n    \"\"\"\n\n    I3: jnp.ndarray = dfield(\"\", default=jnp.eye(3))\n    e1: jnp.ndarray = dfield(\n        \"3-component vector with beam direction in local frame\",\n        default=jnp.array([1.0, 0.0, 0.0]),\n    )\n    EMAT: jnp.ndarray = dfield(\n        \"3x3 Identity matrix\",\n        default=jnp.array(\n            [\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, -1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n            ]\n        ),\n    )\n    EMATT: jnp.ndarray = dfield(\"3x3 Identity matrix\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"EMAT\", jnp.array(self.EMAT))\n        object.__setattr__(self, \"EMATT\", self.EMAT.T)\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxNewton","title":"<code>DdiffraxNewton</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax Newton solver</p> <p>Parameters:</p> Name Type Description Default <code>rtol</code> <code>float</code> required <code>atol</code> <code>float</code> required <code>max_steps</code> <code>int</code> required <code>norm</code> <code>str</code> required <code>kappa</code> <code>float</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DdiffraxNewton(Dlibrary):\n    \"\"\"Settings for Diffrax Newton solver\n\n    Parameters\n    ----------\n    rtol : float\n    atol : float\n    max_steps : int\n    norm : str\n    kappa : float\n\n    \"\"\"\n\n    rtol: float = dfield(\"\", default=1e-7)\n    atol: float = dfield(\"\", default=1e-7)\n    max_steps: int = dfield(\"\", default=100)\n    norm: str = dfield(\"\", default=\"linalg_norm\")\n    kappa: float = dfield(\"\", default=0.01)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"newton\")\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxOde","title":"<code>DdiffraxOde</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax ODE solvers</p> <p>Parameters:</p> Name Type Description Default <code>root_finder</code> <code>dict</code> required <code>stepsize_controller</code> <code>dict</code> required <code>solver_name</code> <code>str</code> required <code>save_at</code> <code>Array | list</code> required <code>max_steps</code> <code>int</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@filter_kwargs\n@Ddataclass\nclass DdiffraxOde(Dlibrary):\n    \"\"\"Settings for Diffrax ODE solvers\n\n    Parameters\n    ----------\n    root_finder : dict\n    stepsize_controller : dict\n    solver_name : str\n    save_at : jax.Array | list\n    max_steps : int\n\n    \"\"\"\n\n    root_finder: dict = dfield(\"\", default=None)\n    stepsize_controller: dict = dfield(\"\", default=None)\n    solver_name: str = dfield(\"\", default=\"Dopri5\")\n    save_at: jnp.ndarray | list[float] = dfield(\"\", default=None)\n    max_steps: int = dfield(\"\", default=20000)\n\n    def __post_init__(self, **kwargs):\n        object.__setattr__(self, \"function\", \"ode\")\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Ddriver","title":"<code>Ddriver</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Program initialisation settings and trigger of simulations.</p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <p>Driver to manage the simulation options=[\"intrinsic\"]</p> required <code>sol_path</code> <code>str | Path</code> <p>Folder path to save results</p> required <code>compute_fem</code> <code>bool</code> <p>Compute or load presimulation data</p> required <code>save_fem</code> <code>bool</code> <p>Save presimulation data</p> required <code>ad_on</code> <code>bool</code> <p>Algorithm differentiation ON</p> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Ddriver(DataContainer):\n    \"\"\"Program initialisation settings and trigger of simulations.\n\n    Parameters\n    ----------\n    typeof : str\n        Driver to manage the simulation options=[\"intrinsic\"]\n    sol_path : str | pathlib.Path\n        Folder path to save results   \n    compute_fem : bool\n        Compute or load presimulation data\n    save_fem : bool\n        Save presimulation data\n    ad_on : bool\n        Algorithm differentiation ON\n    \"\"\"\n\n    typeof: str = dfield(\"\", default=True, options=[\"intrinsic\", \"intrinsicmultibody\"])\n    sol_path: str | pathlib.Path = dfield(\"\", default=\"./\")\n    compute_fem: bool = dfield(\"\", default=True)\n    save_fem: bool = dfield(\"\", default=True)\n    ad_on: bool = dfield(\"\", default=False)\n    fast_on: bool = dfield(\"\", default=False)\n\n    def __post_init__(self):\n        if self.sol_path is not None:\n            object.__setattr__(self, \"sol_path\", pathlib.Path(self.sol_path))\n            self.sol_path.mkdir(parents=True, exist_ok=True)\n\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dfem","title":"<code>Dfem</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Finite Element and discretisation model settings.</p> <p>Parameters:</p> Name Type Description Default <code>connectivity</code> <code>dict | list</code> <p>Connectivities between components</p> required <code>folder</code> <code>str | Path</code> <p>Folder in which to find Ka, Ma, and grid data (with those names)</p> required <code>Ka_name</code> <code>str | Path</code> <p>Condensed stiffness matrix name</p> required <code>Ma_name</code> <code>str | Path</code> <p>Condensed mass matrix name</p> required <code>Ka</code> <code>Array</code> <p>Condensed stiffness matrix</p> required <code>Ma</code> <code>Array</code> <p>Condensed mass matrix</p> required <code>Ka0s</code> <code>Array</code> <p>Condensed stiffness matrix augmented with 0s</p> required <code>Ma0s</code> <code>Array</code> <p>Condensed mass matrix augmented with 0s</p> required <code>num_modes</code> <code>int</code> <p>Number of modes in the solution</p> required <code>eig_type</code> <code>str</code> <p>Calculation of eigenvalues/vectors options=[\"scipy\", \"jax_custom\", \"inputs, input_memory\"]</p> required <code>eigenvals</code> <code>Array</code> <p>EigenValues</p> required <code>eigenvecs</code> <code>Array</code> <p>EigenVectors</p> required <code>eig_cutoff</code> <code>float</code> <p>Cut-off frequency such that eigenvalues smaller than this are set to 0</p> required <code>eig_names</code> <code>list</code> <p>name to load eigenvalues/vectors in <code>folder</code></p> required <code>grid</code> <code>str | Path | Array | DataFrame</code> <p>Grid file or array with Nodes Coordinates, node ID in the FEM, and associated component</p> required <code>Cab_xtol</code> <code>float</code> <p>Tolerance for building the local frame</p> required <p>Attributes:</p> Name Type Description <code>df_grid</code> <code>DataFrame</code> <p>Data Frame associated to Grid file</p> <code>X</code> <code>Array</code> <p>Grid coordinates    </p> <code>Xm</code> <code>Array</code> <p>Grid coordinates mid-points</p> <code>fe_order</code> <code>list[int] | Array</code> <p>node ID in the FEM</p> <code>fe_order_start</code> <code>int</code> <p>fe_order starting with this index</p> <code>component_vect</code> <code>list</code> <p>Array with component associated to each node</p> <code>dof_vect</code> <code>list</code> <p>Array with DoF associated to each node (for constrained systems)</p> <code>num_nodes</code> <code>int</code> <p>Number of nodes </p> <code>component_names</code> <code>list</code> <p>Name of components defining the structure</p> <code>component_father</code> <code>dict</code> <p>Map between each component and its father</p> <code>component_nodes</code> <code>dict</code> <p>Node indexes of the component</p> <code>component_names_int</code> <code>tuple</code> <p>Name of components defining the structure as integers</p> <code>component_father_int</code> <code>tuple</code> <p>Map between each component and its father with integers</p> <code>component_nodes_int</code> <code>tuple</code> <p>Node indexes of the component</p> <code>component_chain</code> <code>dict</code> <p>Dictionary mapping each component to all the components in the load path equilibrium </p> <code>clamped_nodes</code> <code>list</code> <p>List of clamped or multibody nodes</p> <code>freeDoF</code> <code>dict</code> <code>clampedDoF</code> <code>dict</code> <code>total_clampedDoF</code> <code>int</code> <code>constrainedDoF</code> <code>int</code> <code>prevnodes</code> <code>list</code> <p>Immediate previous node following </p> <code>Mavg</code> <code>Array</code> <p>Matrix for tensor average between adjent nodes</p> <code>Mdiff</code> <code>Array</code> <p>Matrix for tensor difference between nodes</p> <code>Mfe_order</code> <code>Array</code> <p>Matrix with 1s and 0s that reorders quantities such as eigenvectors in the FE model; nodes in horizontal arrangement.    </p> <code>Mfe_order0s</code> <code>Array</code> <code>Mload_paths</code> <code>Array</code> <p>Matrix with with 1s and 0s for the load paths that each node, in vertical arrangement, need to transverse to sum up to a free-end.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dfem(DataContainer):\n    \"\"\"Finite Element and discretisation model settings.\n\n    Parameters\n    ----------\n    connectivity : dict | list\n        Connectivities between components\n    folder : str | pathlib.Path\n        Folder in which to find Ka, Ma, and grid data (with those names)\n    Ka_name : str | pathlib.Path\n        Condensed stiffness matrix name\n    Ma_name : str | pathlib.Path\n        Condensed mass matrix name\n    Ka : Array\n        Condensed stiffness matrix\n    Ma : Array\n        Condensed mass matrix \n    Ka0s : Array\n        Condensed stiffness matrix augmented with 0s\n    Ma0s : Array\n        Condensed mass matrix augmented with 0s\n    num_modes : int\n        Number of modes in the solution\n    eig_type : str\n        Calculation of eigenvalues/vectors options=[\"scipy\", \"jax_custom\", \"inputs, input_memory\"]\n    eigenvals : Array\n        EigenValues\n    eigenvecs : Array\n        EigenVectors\n    eig_cutoff : float\n        Cut-off frequency such that eigenvalues smaller than this are set to 0\n    eig_names : list\n        name to load eigenvalues/vectors in `folder`\n    grid : str | pathlib.Path | jax.Array | pandas.core.frame.DataFrame\n        Grid file or array with Nodes Coordinates, node ID in the FEM, and associated component\n    Cab_xtol : float\n        Tolerance for building the local frame\n\n    Attributes\n    ----------\n    df_grid : DataFrame\n        Data Frame associated to Grid file\n    X : Array\n        Grid coordinates    \n    Xm : Array\n        Grid coordinates mid-points\n    fe_order : list[int] | jax.Array\n        node ID in the FEM\n    fe_order_start : int\n        fe_order starting with this index\n    component_vect : list\n        Array with component associated to each node\n    dof_vect : list\n        Array with DoF associated to each node (for constrained systems)\n    num_nodes : int\n        Number of nodes \n    component_names : list\n        Name of components defining the structure\n    component_father : dict\n        Map between each component and its father\n    component_nodes : dict\n        Node indexes of the component\n    component_names_int : tuple\n        Name of components defining the structure as integers\n    component_father_int : tuple\n        Map between each component and its father with integers\n    component_nodes_int : tuple\n        Node indexes of the component\n    component_chain : dict\n        Dictionary mapping each component to all the components in the load path equilibrium \n    clamped_nodes : list\n        List of clamped or multibody nodes\n    freeDoF : dict\n    clampedDoF : dict\n    total_clampedDoF : int\n    constrainedDoF : int\n    prevnodes : list\n        Immediate previous node following \n    Mavg : Array\n        Matrix for tensor average between adjent nodes\n    Mdiff : Array\n        Matrix for tensor difference between nodes\n    Mfe_order : Array\n        Matrix with 1s and 0s that reorders quantities such as eigenvectors in the FE model; nodes in horizontal arrangement.    \n    Mfe_order0s : Array\n    Mload_paths : Array\n        Matrix with with 1s and 0s for the load paths that each node, in vertical arrangement, need to transverse to sum up to a free-end.\n\n    \"\"\"\n\n    connectivity: dict | list = dfield(\"\")\n    folder: str | pathlib.Path = dfield(\n        \"\",\n        default=None,\n    )  # yaml_save=False)\n    Ka_name: str | pathlib.Path = dfield(\"\", default=\"Ka.npy\")\n    Ma_name: str | pathlib.Path = dfield(\"\", default=\"Ma.npy\")\n    Ka: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    Ma: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    Ka0s: jnp.ndarray = dfield(\n        \"\", default=None, yaml_save=False\n    )\n    Ma0s: jnp.ndarray = dfield(\n        \"\", default=None, yaml_save=False\n    )\n    num_modes: int = dfield(\"\", default=None)\n    eig_type: str = dfield(\n        \"\",\n        default=\"scipy\",\n        options=[\"scipy\", \"jax_custom\", \"inputs, input_memory\"],\n    )\n    eigenvals: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    eigenvecs: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)  # [6Nn x Nm]\n    eig_cutoff: float = dfield(\n        \"\",\n        default=1e-2,\n    )  # -jnp.inf?\n    eig_names: list[str | pathlib.Path] = dfield(\n        \"\",\n        default=[\"eigenvals.npy\", \"eigenvecs.npy\"],\n    )\n    grid: str | pathlib.Path | jnp.ndarray | pd.DataFrame = dfield(\n        \"\",\n        default=\"structuralGrid\",\n    )\n    Cab_xtol: float = dfield(\"\", default=1e-4)\n    df_grid: pd.DataFrame = dfield(\"\", init=False)\n    X: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    Xm: jnp.ndarray = dfield(\"\", default=None, init=False)\n    fe_order: list[int] | jnp.ndarray = dfield(\"\", default=None)\n    fe_order_start: int = dfield(\"\", default=0, yaml_save=False)\n    component_vect: list[str] = dfield(\"\", default=None, yaml_save=False)\n    dof_vect: list[str] = dfield(\n        \"\", default=None, yaml_save=False\n    )\n    num_nodes: int = dfield(\"\", init=False)\n    component_names: list = dfield(\"\", init=False)\n    component_father: dict[str:str] = dfield(\n        \"\", init=False\n    )\n    component_nodes: dict[str : list[int]] = dfield(\"\", init=False)\n    component_names_int: tuple[int] = dfield(\n        \"\", init=False\n    )\n    component_father_int: tuple[int] = dfield(\n        \"\", init=False\n    )\n    component_nodes_int: tuple[list[int]] = dfield(\"\", init=False)\n\n    component_chain: dict[str : list[str]] = dfield(\"\", init=False)\n    clamped_nodes: list[int] = dfield(\"\", init=False)\n    freeDoF: dict[str:list] = dfield(\"\", init=False)\n    clampedDoF: dict[str:list] = dfield(\"\", init=False)\n    total_clampedDoF: int = dfield(\"\", init=False)\n    constrainedDoF: int = dfield(\n        \"\", init=False\n    )\n    #\n    prevnodes: list[int] = dfield(\"\", init=False)\n    Mavg: jnp.ndarray = dfield(\"\", init=False)\n    Mdiff: jnp.ndarray = dfield(\"\", init=False)\n    Mfe_order: jnp.ndarray = dfield(\n        \"\",\n        init=False,\n    )\n    Mfe_order0s: jnp.ndarray = dfield(\n        \"\",\n        init=False,\n    )\n    Mload_paths: jnp.ndarray = dfield(\n        \"\",\n        init=False,\n    )\n\n    def __post_init__(self):\n        # set attributes in frozen instance\n        setobj = lambda k, v: object.__setattr__(self, k, v)\n        connectivity = geometry.list2dict(self.connectivity)\n        setobj(\"connectivity\", connectivity)\n        Ka_name, Ma_name, grid = geometry.find_fem(\n            self.folder, self.Ka_name, self.Ma_name, self.grid\n        )\n\n        if self.folder is not None:\n            setobj(\"folder\", pathlib.Path(self.folder).absolute())\n        if self.Ka is None:\n            if self.folder is None:\n                setobj(\"Ka_name\", os.path.abspath(Ka_name))\n\n            else:\n                setobj(\"Ka_name\", self.folder / Ka_name)\n\n        if self.Ma is None:\n            if self.folder is None:\n                setobj(\"Ma_name\", os.path.abspath(Ma_name))\n            else:\n                setobj(\"Ma_name\", self.folder / Ma_name)\n\n        if self.Ka_name is not None and self.Ka is None:\n            setobj(\"Ka\", load_jnp(self.Ka_name))\n        if self.Ma_name is not None and self.Ma is None:            \n            setobj(\"Ma\", load_jnp(self.Ma_name))\n        if self.eig_names is not None and self.eigenvals is None:\n            eigenvals, eigenvecs = iutils.compute_eigs_load(self.num_modes,\n                                                           self.folder,\n                                                           self.eig_names)\n\n            setobj(\"eigenvals\", eigenvals)\n            setobj(\"eigenvecs\", eigenvecs)\n            if self.folder is None:\n                setobj(\"eig_names\", [os.path.abspath(self.eig_names[0]),\n                                     os.path.abspath(self.eig_names[1])])\n            else:\n                setobj(\"eig_names\", [os.path.abspath(self.folder / self.eig_names[0]),\n                                     os.path.abspath(self.folder / self.eig_names[1])])\n\n        if self.folder is None:\n            setobj(\"grid\", os.path.abspath(grid))\n\n        else:\n            setobj(\"grid\", self.folder / grid)\n\n        if self.num_modes is None:\n            # full set of modes in the solution\n            setobj(\"num_modes\", len(self.Ka))\n        # if self.folder is None:\n        #     df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n        #         self.grid,\n        #         self.X,\n        #         self.fe_order,\n        #         self.fe_order_start,\n        #         self.component_vect,\n        #         self.dof_vect,\n        #     )\n        # else:\n        df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n            self.grid,\n            self.X,\n            self.fe_order,\n            self.fe_order_start,\n            self.component_vect,\n            self.dof_vect,\n        )\n        setobj(\"df_grid\", df_grid)\n        setobj(\"X\", X)\n        setobj(\"fe_order\", fe_order)\n        setobj(\"component_vect\", component_vect)\n        setobj(\"dof_vect\", dof_vect)\n        num_nodes = len(self.X)\n        setobj(\"num_nodes\", num_nodes)\n        component_names, component_father = geometry.compute_component_father(self.connectivity)\n        setobj(\"component_names\", component_names)\n        setobj(\"component_father\", component_father)\n        setobj(\"component_nodes\", geometry.compute_component_nodes(self.component_vect))\n        setobj(\n            \"component_chain\",\n            geometry.compute_component_chain(self.component_names, self.connectivity),\n        )\n        clamped_nodes, freeDoF, clampedDoF, total_clampedDoF, constrainedDoF = (\n            geometry.compute_clamped(self.fe_order.tolist(), self.dof_vect)\n        )\n        setobj(\"clamped_nodes\", clamped_nodes)\n        setobj(\"freeDoF\", freeDoF)\n        setobj(\"clampedDoF\", clampedDoF)\n        setobj(\"total_clampedDoF\", total_clampedDoF)\n        setobj(\"constrainedDoF\", constrainedDoF)\n        if constrainedDoF:\n            Ka0s, Ma0s = geometry.compute_Mconstrained(\n                self.Ka, self.Ma, self.fe_order, clamped_nodes, clampedDoF\n            )\n            setobj(\"Ka0s\", Ka0s)\n            setobj(\"Ma0s\", Ma0s)\n        setobj(\n            \"prevnodes\",\n            geometry.compute_prevnode(\n                self.component_vect, self.component_nodes, self.component_father\n            ),\n        )\n        setobj(\"Mavg\", geometry.compute_Maverage(self.prevnodes, self.num_nodes))\n        setobj(\"Xm\", jnp.matmul(self.X.T, self.Mavg))\n        setobj(\"Mdiff\", geometry.compute_Mdiff(self.prevnodes, self.num_nodes))\n        Mfe_order, Mfe_order0s = geometry.compute_Mfe_order(\n            self.fe_order,\n            self.clamped_nodes,\n            self.freeDoF,\n            self.total_clampedDoF,\n            self.component_nodes,\n            self.component_chain,\n            self.num_nodes,\n        )\n        setobj(\"Mfe_order\", Mfe_order)\n        setobj(\"Mfe_order0s\", Mfe_order0s)\n        setobj(\n            \"Mload_paths\",\n            geometry.compute_Mloadpaths(\n                self.component_vect,\n                self.component_nodes,\n                self.component_chain,\n                self.num_nodes,\n            ),\n        )\n        (component_names_int, component_nodes_int, component_father_int) = (\n            geometry.convert_components(\n                self.component_names, self.component_nodes, self.component_father\n            )\n        )\n        setobj(\"component_names_int\", component_names_int)\n        setobj(\"component_nodes_int\", component_nodes_int)\n        setobj(\"component_father_int\", component_father_int)\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dlibrary","title":"<code>Dlibrary</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Solution library</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dlibrary(DataContainer):\n    \"\"\"Solution library\"\"\"\n\n    function: str = dfield(\"Function wrapper calling the library\", default=None)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dlog","title":"<code>Dlog</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Simulation settings for the management the way each system is run.</p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <p>Type of simulation [\"single\", \"serial\", \"parallel\"]</p> required <code>workflow</code> <code>dict</code> <p>Dictionary that defines which system is run after which. The default None implies systems are run in order of the input</p> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dlog(DataContainer):\n    \"\"\"Simulation settings for the management the way each system is run.\n\n    Parameters\n    ----------\n    typeof : str\n        Type of simulation [\"single\", \"serial\", \"parallel\"]\n    workflow : dict\n        Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\n    \"\"\"\n\n    to_console: bool = dfield(\n        \"Output to console\", default=True\n    )\n    to_file: bool = dfield(\n        \"Output to file\", default=True\n    )    \n    level: str = dfield(\n        \"Logging level\", default=\"info\", options=[\"notset\", \"debug\", \"info\", \"warning\", \"error\", \"critical\"]\n    )\n    file_name: str = dfield(\"Name of log file\",\n        default=\"feniax\",\n    )\n    file_mode: str = dfield(\n        \"Mode for writing log file\", default=\"w\", options=[\"w\", \"a\"]\n    )\n\n    path: str = dfield(\"Path to log file\",\n        default=None,\n    ) \n    def __post_init__(self):\n        if self.path is not None:\n            object.__setattr__(self, \"path\", pathlib.Path(self.path))\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DobjectiveArgs","title":"<code>DobjectiveArgs</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Settings for the objective function in the AD</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> required <code>nodes</code> <code>tuple</code> required <code>t</code> <code>tuple</code> required <code>components</code> <code>tuple</code> required <code>axis</code> <code>int</code> required <code>_numtime</code> <code>int</code> required <code>_numnodes</code> <code>int</code> required <code>_numcomponents</code> <code>int</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DobjectiveArgs(DataContainer):\n    \"\"\"Settings for the objective function in the AD\n\n    Parameters\n    ----------\n    function : str\n    nodes : tuple\n    t : tuple\n    components : tuple\n    axis : int\n    _numtime : int\n    _numnodes : int\n    _numcomponents : int\n\n    \"\"\"\n\n    nodes: tuple = dfield(\"\", default=None)\n    t: tuple = dfield(\"\", default=None)\n    components: tuple = dfield(\"\", default=None)\n    axis: int = dfield(\"\", default=None)\n    _numtime: int = dfield(\"\", default=None)\n    _numnodes: int = dfield(\"\", default=None)\n    _numcomponents: int = dfield(\"\", default=6)\n\n    def __post_init__(self):\n        if self.nodes is None:\n            object.__setattr__(self, \"nodes\", tuple(range(self._numnodes)))\n        if self.t is None:\n            object.__setattr__(self, \"t\", tuple(range(self._numtime)))\n        if self.components is None:\n            object.__setattr__(self, \"components\", tuple(range(self._numcomponents)))\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Drunge_kuttaOde","title":"<code>Drunge_kuttaOde</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Solution settings for Runge-Kutta in-house solvers</p> <p>Parameters:</p> Name Type Description Default <code>solver_name</code> <code>str</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Drunge_kuttaOde(Dlibrary):\n    \"\"\"Solution settings for Runge-Kutta in-house solvers\n\n    Parameters\n    ----------\n    solver_name : str\n    \"\"\"\n\n    solver_name: str = dfield(\"\", default=\"rk4\")\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"ode\")\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsimulation","title":"<code>Dsimulation</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Simulation settings for the management the way each system is run.</p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <p>Type of simulation [\"single\", \"serial\", \"parallel\"]</p> required <code>workflow</code> <code>dict</code> <p>Dictionary that defines which system is run after which. The default None implies systems are run in order of the input</p> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dsimulation(DataContainer):\n    \"\"\"Simulation settings for the management the way each system is run.\n\n    Parameters\n    ----------\n    typeof : str\n        Type of simulation [\"single\", \"serial\", \"parallel\"]\n    workflow : dict\n        Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\n    \"\"\"\n\n    typeof: str = dfield(\n        \"\", default=\"single\", options=[\"single\", \"serial\", \"parallel\"]\n    )\n    workflow: dict = dfield(\"\",\n        default=None,\n    )\n\n    def __post_init__(self):\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystem","title":"<code>Dsystem</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>System settings for the corresponding equations to be solved</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>_fem</code> <code>Dfem</code> required <code>solution</code> <code>str</code> required <code>target</code> <code>str</code> required <code>bc1</code> <code>str</code> required <code>save</code> <code>bool</code> required <code>xloads</code> <code>dict | Dxloads</code> required <code>aero</code> <code>dict | Daero</code> required <code>t0</code> <code>float</code> required <code>t1</code> <code>float</code> required <code>tn</code> <code>int</code> required <code>dt</code> <code>float</code> required <code>t</code> <code>Array</code> required <code>solver_library</code> <code>str</code> required <code>solver_function</code> <code>str</code> required <code>solver_settings</code> <code>str</code> required <code>q0treatment</code> <code>int</code> required <code>rb_treatment</code> <code>int</code> required <code>nonlinear</code> <code>bool</code> required <code>residualise</code> <code>bool</code> required <code>residual_modes</code> <code>int</code> required <code>label</code> <code>str</code> required <code>label_map</code> <code>dict</code> required <code>states</code> <code>dict</code> required <code>num_states</code> <code>int</code> required <code>init_states</code> <code>dict</code> required <code>init_mapper</code> <code>dict</code> required <code>ad</code> <code>DtoAD</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dsystem(DataContainer):\n    \"\"\"System settings for the corresponding equations to be solved\n\n    Parameters\n    ----------\n    name : str\n    _fem : Dfem\n    solution : str\n    target : str\n    bc1 : str\n    save : bool\n    xloads : dict | __main__.Dxloads\n    aero : dict | __main__.Daero\n    t0 : float\n    t1 : float\n    tn : int\n    dt : float\n    t : Array\n    solver_library : str\n    solver_function : str\n    solver_settings : str\n    q0treatment : int\n    rb_treatment : int\n    nonlinear : bool\n    residualise : bool\n    residual_modes : int\n    label : str\n    label_map : dict\n    states : dict\n    num_states : int\n    init_states : dict\n    init_mapper : dict\n    ad : DtoAD\n\n    \"\"\"\n\n    name: str = dfield(\"System name\", default=\"sys1\")\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n    solution: str = dfield(\n        \"Type of solution to be solved\",\n        options=[\"static\", \"dynamic\", \"multibody\", \"stability\"],\n    )\n    target: str = dfield(\n        \"The simulation goal of this system\",\n        default=\"Level\",\n        options=SimulationTarget._member_names_,\n    )\n    bc1: str = dfield(\n        \"Boundary condition first node\",\n        default=\"clamped\",\n        options=BoundaryCond._member_names_,\n    )\n    operationalmode: str = dfield(\n        \"\",\n        options=[\"(empty string/default)\", \"Fast\", \"AD\", \"Shard\", \"ShardMap\", \"ShardAD\"],\n        default=\"\"\n    )\n\n    save: bool = dfield(\"Save results of the run system\", default=True)\n    xloads: dict | Dxloads = dfield(\"External loads dataclass\", default=None)\n    aero: dict | Daero = dfield(\"Aerodynamic dataclass\", default=None)\n    t0: float = dfield(\"Initial time\", default=0.0)\n    t1: float = dfield(\"Final time\", default=1.0)\n    tn: int = dfield(\"Number of time steps\", default=None)\n    dt: float = dfield(\"Delta time\", default=None)\n    t: jnp.ndarray = dfield(\"Time vector\", default=None, yaml_save=False)\n    solver_library: str = dfield(\"Library solving our system of equations\", default=None)\n    solver_function: str = dfield(\n        \"Name for the solver of the previously defined library\", default=None\n    )\n    solver_settings: str = dfield(\"Settings for the solver\", default=None)\n    q0treatment: int = dfield(\n        \"\"\"Modal velocities, q1, and modal forces, q2, are the main variables\n        in the intrinsic structural description,\n        but the steady aerodynamics part needs a displacement component, q0;\n        proportional gain to q2 or  integration of velocities q1\n        can be used to obtain this.\"\"\",\n        default=2,\n        options=[2, 1],\n    )\n    rb_treatment: int = dfield(\n        \"\"\"Rigid-body treatment: 1 to use the first node quaternion to track the body\n        dynamics (integration of strains thereafter; 2 to use quaternions at every node.)\"\"\",\n        default=1,\n        options=[1, 2],\n    )\n    nonlinear: int = dfield(\n        \"\"\"whether to include the nonlinear terms in the eqs. (Gammas)\n        and in the integration\"\"\",\n        default=1,\n        options=[2, 1, 0, -1, -2],\n    )\n    residualise: bool = dfield(\n        \"average the higher frequency eqs and make them algebraic\", default=False\n    )\n    residual_modes: int = dfield(\"number of modes to residualise\", default=0)\n    label: str = dfield(\"\"\"System label that maps to the solution functional\"\"\", default=None)\n    label_map: dict = dfield(\"\"\"label dictionary assigning \"\"\", default=None)\n\n    states: dict = dfield(\"\"\"Dictionary with the state variables.\"\"\", default=None)\n    num_states: int = dfield(\"\"\"Total number of states\"\"\", default=None)\n    init_states: dict[str:list] = dfield(\n        \"\"\"Dictionary with initial conditions for each state\"\"\", default=None\n    )\n    init_mapper: dict[str:str] = dfield(\n        \"\"\"Dictionary mapping states types to functions in initcond\"\"\",\n        default=dict(q1=\"velocity\", q2=\"force\"),\n    )\n    ad: dict | DtoAD = dfield(\"\"\"Dictionary for AD\"\"\", default=None)\n    shard: dict | DShard = dfield(\"\"\"Dictionary for parallelisation\"\"\", default=None)\n\n    def __post_init__(self):\n        if self.t is not None:\n            object.__setattr__(self, \"t\", jnp.array(self.t))\n            object.__setattr__(self, \"t1\", float(self.t[-1]))\n            object.__setattr__(self, \"t0\", float(self.t[0]))\n\n            if (len_t := len(self.t)) &lt; 2:\n                object.__setattr__(self, \"dt\", 0.0)\n            else:\n                object.__setattr__(self, \"dt\", float(self.t[1]) - self.t0)\n            object.__setattr__(self, \"tn\", len_t)\n        else:\n            if self.dt is not None and self.tn is not None:\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            elif self.tn is not None and self.t1 is not None:\n                object.__setattr__(self, \"dt\", (self.t1 - self.t0) / (self.tn - 1))\n            elif self.t1 is not None and self.dt is not None:\n                object.__setattr__(self, \"tn\", math.ceil((self.t1 - self.t0) / self.dt + 1))\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            object.__setattr__(self, \"t\", jnp.linspace(self.t0, self.t1, self.tn))\n\n        object.__setattr__(self, \"xloads\", initialise_Dclass(self.xloads, Dxloads))\n        if self.aero is not None:\n            object.__setattr__(self, \"aero\", initialise_Dclass(self.aero, Daero, time=self.t))\n        # self.xloads = initialise_Dclass(self.xloads, Dxloads)\n        if self.solver_settings is None:\n            object.__setattr__(self, \"solver_settings\", dict())\n\n        libsettings_class = globals()[f\"D{self.solver_library}{self.solver_function.capitalize()}\"]\n        object.__setattr__(\n            self,\n            \"solver_settings\",\n            initialise_Dclass(self.solver_settings, libsettings_class),\n        )\n        if self.ad is not None:\n\n            if isinstance(self.ad, dict):\n                libsettings_class = globals()[\"DtoAD\"]\n                object.__setattr__(\n                    self,\n                    \"ad\",\n                    initialise_Dclass(\n                        self.ad,\n                        libsettings_class,\n                        _numtime=len(self.t),\n                        _numnodes=self._fem.num_nodes,\n                    ),\n                )\n            if self.shard is not None:\n                object.__setattr__(self, \"operationalmode\", \"ADShard\")\n                if isinstance(self.shard, dict):\n                    libsettings_class = globals()[\"DShard\"]\n                    object.__setattr__(\n                        self,\n                        \"shard\",\n                        initialise_Dclass(\n                            self.shard,\n                            libsettings_class,\n                            #_fem=self._fem,\n                            #_aero=self._aero,\n                        ),\n                    )\n\n            else:\n                object.__setattr__(self, \"operationalmode\", \"AD\")\n\n        elif self.shard is not None:\n            if self.operationalmode == \"\":\n                object.__setattr__(self, \"operationalmode\", \"Shard\")\n            else:\n                object.__setattr__(self, \"operationalmode\", self.operationalmode.capitalize())\n            if isinstance(self.shard, dict):\n                libsettings_class = globals()[\"DShard\"]\n                object.__setattr__(\n                    self,\n                    \"shard\",\n                    initialise_Dclass(\n                        self.shard,\n                        libsettings_class,\n                        #_fem=self._fem,\n                        #_aero=self._aero,\n                    ),\n                )\n        elif self.operationalmode == \"fast\":\n            object.__setattr__(self, \"operationalmode\", \"Fast\")\n        if self.label is None:\n            self.build_label()\n        self._initialize_attributes()\n\n    def build_states(self, num_modes: int, num_nodes: int):\n\n        num_poles = 0\n        if self.label_map[\"aero_sol\"] and self.aero.approx.lower() == \"roger\":\n            num_poles = self.aero.num_poles\n        tracker = iutils.build_systemstates(self.solution, self.target, self.bc1, self.rb_treatment, self.q0treatment, num_poles, num_modes, num_nodes)\n\n        # if self.solution == \"static\":\n        #     state_dict.update(m, kwargs)\n        object.__setattr__(self, \"states\", tracker.states)\n        object.__setattr__(self, \"num_states\", tracker.num_states)\n\n    def build_label(self):\n        # WARNING: order dependent for the label\n        # nonlinear and residualise should always come last as they are represented\n        # with letters\n        lmap = dict()\n        lmap[\"soltype\"] = SystemSolution[self.solution.upper()].value\n        lmap[\"target\"] = SimulationTarget[self.target.upper()].value - 1\n        if self.xloads.gravity_forces:\n            lmap[\"gravity\"] = \"G\"\n        else:\n            lmap[\"gravity\"] = \"g\"\n        lmap[\"bc1\"] = BoundaryCond[self.bc1.upper()].value - 1\n        lmap[\"aero_sol\"] = int(self.xloads.modalaero_forces)\n        if lmap[\"aero_sol\"] &gt; 0:\n            if self.aero.approx.lower() == \"roger\":\n                lmap[\"aero_sol\"] = 1\n            elif self.aero.approx.lower() == \"loewner\":\n                lmap[\"aero_sol\"] = 2\n            if self.aero.qalpha is None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 0\n            elif self.aero.qalpha is not None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 1\n            elif self.aero.qalpha is None and self.aero.qx is not None:\n                lmap[\"aero_steady\"] = 2\n            else:\n                lmap[\"aero_steady\"] = 3\n            #\n            if self.aero.gust is None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 0\n            elif self.aero.gust is not None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 1\n            elif self.aero.gust is None and self.aero.controller is not None:\n                lmap[\"aero_unsteady\"] = 2\n            else:\n                lmap[\"aero_unsteady\"] = 3\n        else:\n            lmap[\"aero_steady\"] = 0\n            lmap[\"aero_unsteady\"] = 0\n        if self.xloads.follower_forces and self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 3\n        elif self.xloads.follower_forces:\n            lmap[\"point_loads\"] = 1\n        elif self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 2\n        else:\n            lmap[\"point_loads\"] = 0\n        if self.q0treatment == 2:\n            lmap[\"q0treatment\"] = 0\n        elif self.q0treatment == 1:\n            lmap[\"q0treatment\"] = 1\n        if self.nonlinear == 1:\n            lmap[\"nonlinear\"] = \"\"\n        elif self.nonlinear == -1:\n            lmap[\"nonlinear\"] = \"l\"\n        elif self.nonlinear == -2:\n            lmap[\"nonlinear\"] = \"L\"\n        elif self.nonlinear == 2:\n            lmap[\"nonlinear\"] = \"gamma1\"            \n        if self.residualise:\n            lmap[\"residualise\"] = \"r\"\n        else:\n            lmap[\"residualise\"] = \"\"\n        labelx = list(lmap.values())\n        label = label_generator(labelx)\n\n        # TODO: label dependent\n        object.__setattr__(self, \"label_map\", lmap)\n        object.__setattr__(self, \"label\", label)  # f\"dq_{label}\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystems","title":"<code>Dsystems</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Input setting for the range of systems in the simulation</p> <p>Parameters:</p> Name Type Description Default <code>sett</code> <code>dict</code> required <code>mapper</code> <code>dict</code> required <code>borrow</code> <code>dict</code> required <code>_fem</code> <code>Dfem</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dsystems(DataContainer):\n    \"\"\"Input setting for the range of systems in the simulation\n\n    Parameters\n    ----------\n    sett : dict\n    mapper : dict\n    borrow : dict\n    _fem : Dfem\n\n    Attributes\n    ----------\n\n\n    \"\"\"\n\n    sett: dict[str:dict] = dfield(\"Settings \", yaml_save=True)\n    mapper: dict[str:Dsystem] = dfield(\"Dictionary with systems in the simulation\", init=False)\n    borrow: dict[str:str] = dfield(\n        \"\"\"Borrow settings from another system:\n    if there is only one system, then inactive; otherwise default to take settings from\n    the first system unless specified.\n    \"\"\",\n        default=None,\n    )\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n\n    def __post_init__(self):\n        mapper = dict()\n        counter = 0\n        for k, v in self.sett.items():\n            if self.borrow is None:\n                # pass self._fem to the system here, the others should already have\n                # a reference\n                mapper[k] = initialise_Dclass(v, Dsystem, name=k, _fem=self._fem)\n            elif isinstance(self.borrow, str):\n                assert self.borrow in self.sett.keys(), \"borrow not in system names\"\n                if k == self.borrow:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n                else:\n                    v0 = self.sett[self.borrow]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n            else:\n                if k in self.borrow.keys():\n                    v0 = self.sett[self.borrow[k]]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n                else:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n\n            counter += 1\n        object.__setattr__(self, \"mapper\", mapper)\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DtoAD","title":"<code>DtoAD</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Algorithm differentiation settings</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> required <code>inputs</code> <code>dict</code> required <code>input_type</code> <code>str</code> required <code>grad_type</code> <code>str</code> required <code>objective_fun</code> <code>str</code> required <code>objective_var</code> <code>str</code> required <code>objective_args</code> <code>dict</code> required <code>_numnodes</code> <code>int</code> required <code>_numtime</code> <code>int</code> required <code>_numcomponents</code> <code>int</code> required <code>label</code> <code>str</code> required Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass DtoAD(DataContainer):\n    \"\"\"Algorithm differentiation settings\n\n    Parameters\n    ----------\n    function : str\n    inputs : dict\n    input_type : str\n    grad_type : str\n    objective_fun : str\n    objective_var : str\n    objective_args : dict\n    _numnodes : int\n    _numtime : int\n    _numcomponents : int\n    label : str\n\n    \"\"\"\n\n    inputs: dict = dfield(\"\", default=None, yaml_save=False)\n    input_type: str = dfield(\"\", default=None, options=ADinputType._member_names_)\n    grad_type: str = dfield(\n        \"\",\n        default=None,\n        options=[  # \"grad\", \"value_grad\",\n            \"jacrev\",\n            \"jacfwd\",\n            \"value\",\n        ],\n    )\n    objective_fun: str = dfield(\"\", default=None)\n    objective_var: str = dfield(\"\", default=None)\n    objective_args: dict | DobjectiveArgs = dfield(\"\", default=None, yaml_save=False)\n    _numnodes: int = dfield(\"\", default=None, yaml_save=False)\n    _numtime: int = dfield(\"\", default=None, yaml_save=False)\n    _numcomponents: int = dfield(\"\", default=6, yaml_save=False)\n    label: str = dfield(\"\", default=None, init=False)\n\n    def __post_init__(self):\n        label = ADinputType[self.input_type.upper()].value\n        object.__setattr__(self, \"label\", label)\n\n        object.__setattr__(\n            self,\n            \"objective_args\",\n            initialise_Dclass(\n                self.objective_args,\n                DobjectiveArgs,\n                _numtime=self._numtime,\n                _numnodes=self._numnodes,\n                _numcomponents=self._numcomponents,\n            ),\n        )\n        for k, v in self.inputs.items():\n            if isinstance(v, str):\n                self.inputs[k] = jnp.load(v)\n        self._initialize_attributes()\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dxloads","title":"<code>Dxloads</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>External loads settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>follower_forces</code> <code>bool</code> <p>Include point follower forces</p> required <code>dead_forces</code> <code>bool</code> required <code>gravity_forces</code> <code>bool</code> required <code>modalaero_forces</code> <code>bool</code> required <code>x</code> <code>Array</code> required <code>force_follower</code> <code>Array</code> required <code>force_dead</code> <code>Array</code> required <code>follower_points</code> <code>list</code> required <code>dead_points</code> <code>list</code> required <code>follower_interpolation</code> <code>list</code> required <code>dead_interpolation</code> <code>list</code> required <code>gravity</code> <code>float</code> required <code>gravity_vect</code> <code>Array</code> required <p>Attributes:</p> Name Type Description <code>Methods</code> <code>-------</code> <code>build_point_follower</code> <code>build_point_dead</code> <code>build_gravity</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@Ddataclass\nclass Dxloads(DataContainer):\n    \"\"\"External loads settings for each system\n\n    Parameters\n    ----------\n    follower_forces : bool\n        Include point follower forces\n    dead_forces : bool\n    gravity_forces : bool\n    modalaero_forces : bool\n    x : Array\n    force_follower : Array\n    force_dead : Array\n    follower_points : list\n    dead_points : list\n    follower_interpolation : list\n    dead_interpolation : list\n    gravity : float\n    gravity_vect : Array\n\n    Attributes\n    ----------\n\n    Methods\n    -------\n    build_point_follower\n    build_point_dead\n    build_gravity\n\n    \"\"\"\n\n    follower_forces: bool = dfield(\"\", default=False)\n    dead_forces: bool = dfield(\"\", default=False)\n    gravity_forces: bool = dfield(\"Include gravity in the analysis\", default=False)\n    modalaero_forces: bool = dfield(\"Include aerodynamic forces\", default=False)\n    x: jnp.ndarray = dfield(\"x-axis vector for interpolation\", default=None)\n    force_follower: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    force_dead: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    follower_points: list[list[int, int]] = dfield(\n        \"Follower force points [Node, coordinate]\",\n        default=None,\n    )\n    dead_points: list[list[int, int]] = dfield(\n        \"Dead force points [Node, coordinate]\",\n        default=None,\n    )\n\n    follower_interpolation: list[list[float]] = dfield(\n        \"(Linear) interpolation of the follower forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n    dead_interpolation: list[list[int]] = dfield(\n        \"(Linear) interpolation of the dead forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n\n    gravity: float = dfield(\"gravity force [m/s]\", default=9.807)\n    gravity_vect: jnp.ndarray = dfield(\"gravity vector\", default=jnp.array([0, 0, -1]))\n\n    # gravity_steps: int = dfield(\"steps in which gravity is applied in trim simulation\",\n    #                                    default=1) manage by t\n    # label: str = dfield(\"\"\"Description of the loading type:\n    # '1001' = follower point forces, no dead forces, no gravity, aerodynamic forces\"\"\",\n    #                     init=False)\n    def __post_init__(self):\n        if self.x is not None:\n            object.__setattr__(self, \"x\", jnp.array(self.x))\n        else:\n            object.__setattr__(self, \"x\", jnp.linspace(0, 1, 2))\n        # self.label = f\"{int(self.follower_forces)}\\\n        # {int(self.dead_forces)}{self.gravity_forces}{self.aero_forces}\"\n        self._initialize_attributes()\n\n    def build_point_follower(self, num_nodes, C06ab):\n        num_interpol_points = len(self.x)\n        forces = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.follower_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.follower_points[fi][0]\n                dim = self.follower_points[fi][1]\n                forces = forces.at[li, dim, fnode].set(\n                    self.follower_interpolation[fi][li]\n                )  # Nx_6_Nn\n        force_follower = coordinate_transform(forces, C06ab, jax.lax.Precision.HIGHEST)\n        object.__setattr__(self, \"force_follower\", force_follower)\n        # return self.force_follower\n\n    def build_point_dead(self, num_nodes):\n        # TODO: add gravity force, also in modes as M@g\n        num_interpol_points = len(self.x)\n        force_dead = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.dead_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.dead_points[fi][0]\n                dim = self.dead_points[fi][1]\n                force_dead = force_dead.at[li, dim, fnode].set(self.dead_interpolation[fi][li])\n        object.__setattr__(self, \"force_dead\", force_dead)\n        # return self.force_dead\n\n    def build_gravity(self, Ma, Mfe_order):\n        num_nodes = Mfe_order.shape[1] // 6\n        num_nodes_out = Mfe_order.shape[0] // 6\n        if self.x is not None and len(self.x) &gt; 1:\n            len_x = len(self.x)\n        else:\n            len_x = 2\n        # force_gravity = jnp.zeros((2, 6, num_nodes))\n        gravity = self.gravity * self.gravity_vect\n        gravity_field = jnp.hstack([jnp.hstack([gravity, 0.0, 0.0, 0.0])] * num_nodes)\n        _force_gravity = jnp.matmul(Mfe_order, Ma @ gravity_field)\n        gravity_interpol = jnp.vstack([xi * _force_gravity for xi in jnp.linspace(0, 1, len_x)]).T\n        force_gravity = reshape_field(\n            gravity_interpol, len_x, num_nodes_out\n        )  # Becomes  (len_x, 6, Nn)\n        # num_forces = len(self.dead_interpolation)\n        # for li in range(num_interpol_points):\n        #     for fi in range(num_forces):\n        #         fnode = self.dead_points[fi][0]\n        #         dim = self.dead_points[fi][1]\n        #         force_dead = force_dead.at[li, dim, fnode].set(\n        #             self.dead_interpolation[fi][li])\n        object.__setattr__(self, \"force_gravity\", force_gravity)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.generate_docstring","title":"<code>generate_docstring(cls)</code>","text":"<p>Generate a docstring for a data class based on its fields.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def generate_docstring(cls: Any) -&gt; Any:\n    \"\"\"\n    Generate a docstring for a data class based on its fields.\n    \"\"\"\n    if not is_dataclass(cls):\n        return cls\n\n    lines = [f\"{cls.__name__}:\\n\"]\n    for field in fields(cls):\n        field_type = field.type.__name__ if hasattr(field.type,\n                                                    \"__name__\") else str(field.type)\n        lines.append(f\"{field.name} : {field_type}\")\n        # Here you could add more detailed documentation for each field if needed\n    cls.__doc__ = \"\\n\".join(lines)\n    return cls\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.update_docstrings","title":"<code>update_docstrings(module)</code>","text":"<p>Update docstrings for all data classes in the given module.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def update_docstrings(module: Any) -&gt; None:\n    \"\"\"Update docstrings for all data classes in the given module.\"\"\"\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj) and is_dataclass(obj):\n            obj = generate_docstring(obj)\n            print(obj.__doc__)\n</code></pre>"},{"location":"api/modes/","title":"Modes","text":""},{"location":"api/modes/#intrinsic.modes.axis_tilde","title":"<code>axis_tilde(tensor)</code>","text":"<p>Apply tilde0010 to a tensor</p> <p>The input tesor is iterated through axis 2 first, and axis 1 subsequently; tilde0010 is applied to axis 0.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>ndarray</code> <p>3xN1xN2 tensor</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6xN1xN2 tensor</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef axis_tilde(tensor: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Apply tilde0010 to a tensor\n\n    The input tesor is iterated through axis 2 first, and axis 1\n    subsequently; tilde0010 is applied to axis 0.\n\n    Parameters\n    ----------\n    tensor : jnp.ndarray\n        3xN1xN2 tensor\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6xN1xN2 tensor\n\n    \"\"\"\n\n    f1 = jax.vmap(tilde0010, in_axes=1, out_axes=2)\n    f2 = jax.vmap(f1, in_axes=2, out_axes=3)\n    f = f2(tensor)\n\n    return f\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.contraction","title":"<code>contraction(moments, loadpaths, precision)</code>","text":"<p>Sums the moments from the nodal forces along the corresponding load path</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) x num_nodes(moment at the previous index due to forces at this node)</p> required <code>loadpaths</code> <code>ndarray</code> <p>num_node x num_node such that [ni, nj] is 1 or 0 depending on whether ni is a node in the loadpath of nj respectively</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) as the sum of moments due to forces at each node</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef contraction(moments: jnp.ndarray, loadpaths: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Sums the moments from the nodal forces along the corresponding load path\n\n    Parameters\n    ----------\n    moments : jnp.ndarray\n        num_modes x 6 x num_nodes(index) x num_nodes(moment at the\n        previous index due to forces at this node)\n    loadpaths : jnp.ndarray\n        num_node x num_node such that [ni, nj] is 1 or 0 depending on\n        whether ni is a node in the loadpath of nj respectively\n\n    Returns\n    -------\n    jnp.ndarray\n        num_modes x 6 x num_nodes(index) as the sum of moments\n        due to forces at each node\n\n    \"\"\"\n\n    f = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(2, 0), precision=precision),\n        in_axes=(2, 1),\n        out_axes=2,\n    )\n    fuv = f(moments, loadpaths)\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.coordinates_difftensor","title":"<code>coordinates_difftensor(X, Xm, precision)</code>","text":"<p>Computes coordinates</p> <p>The tensor represents the following: Coordinates, middle point of each element, minus the position of each node in the structure</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Grid coordinates</p> required <code>Mavg</code> <code>ndarray</code> <p>Matrix to calculate the averege point between nodes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required <p>Returns:</p> Name Type Description <code>X3</code> <code>jnp.ndarray: (3xNnxNn)</code> <p>Tensor, Xm1 -(X1)' : [Coordinates, Middle point of segment, Node]</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef coordinates_difftensor(X: jnp.ndarray, Xm: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Computes coordinates\n\n    The tensor represents the following: Coordinates, middle point of each element,\n    minus the position of each node in the structure\n\n    Parameters\n    ----------\n    X : jnp.ndarray\n        Grid coordinates\n    Mavg : jnp.ndarray\n        Matrix to calculate the averege point between nodes\n    num_nodes : int\n        Number of nodes\n\n    Returns\n    -------\n    X3 : jnp.ndarray: (3xNnxNn)\n        Tensor, Xm*1 -(X*1)' : [Coordinates, Middle point of segment, Node]\n\n\n    \"\"\"\n\n    # Xm = jnp.matmul(X, Mavg, precision=precision)\n    num_nodes = X.shape[1]\n    ones = jnp.ones(num_nodes)\n    Xm3 = jnp.tensordot(\n        Xm, ones, axes=0, precision=precision\n    )  # copy Xm along a 3rd dimension\n    Xn3 = jnp.transpose(\n        jnp.tensordot(X, ones, axes=0, precision=precision), axes=[0, 2, 1]\n    )  # copy X along the 2nd dimension\n    X3 = Xm3 - Xn3\n    return X3\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh","title":"<code>eigh(a, b)</code>","text":"<p>Compute the solution to the symmetrized generalized eigenvalue problem.</p> <p>a_s @ w = b_s @ w @ np.diag(v)</p> <p>where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the inputs and H is the Hermitian (conjugate transpose) operator.</p> <p>For self-adjoint inputs the solution should be consistent with <code>scipy.linalg.eigh</code> i.e.</p> <p>v, w = eigh(a, b) v_sp, w_sp = scipy.linalg.eigh(a, b) np.testing.assert_allclose(v, v_sp) np.testing.assert_allclose(w, standardize_angle(w_sp))</p> <p>Note this currently uses <code>jax.linalg.eig(jax.linalg.solve(b, a))</code>, which will be slow because there is no GPU implementation of <code>eig</code> and it's just a generally inefficient way of doing it. Future implementations should wrap cuda primitives. This implementation is provided primarily as a means to test <code>eigh_jvp_rule</code>.</p> <p>Args:     a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)     b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)</p> <p>Returns:     v: eigenvalues of the generalized problem in ascending order.     w: eigenvectors of the generalized problem, normalized such that         w.H @ b @ w = I.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jax.custom_jvp  # jax.scipy.linalg.eigh doesn't support general problem i.e. b not None\ndef eigh(a, b):\n    \"\"\"\n    Compute the solution to the symmetrized generalized eigenvalue problem.\n\n    a_s @ w = b_s @ w @ np.diag(v)\n\n    where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the\n    inputs and H is the Hermitian (conjugate transpose) operator.\n\n    For self-adjoint inputs the solution should be consistent with `scipy.linalg.eigh`\n    i.e.\n\n    v, w = eigh(a, b)\n    v_sp, w_sp = scipy.linalg.eigh(a, b)\n    np.testing.assert_allclose(v, v_sp)\n    np.testing.assert_allclose(w, standardize_angle(w_sp))\n\n    Note this currently uses `jax.linalg.eig(jax.linalg.solve(b, a))`, which will be\n    slow because there is no GPU implementation of `eig` and it's just a generally\n    inefficient way of doing it. Future implementations should wrap cuda primitives.\n    This implementation is provided primarily as a means to test `eigh_jvp_rule`.\n\n    Args:\n        a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)\n        b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)\n\n    Returns:\n        v: eigenvalues of the generalized problem in ascending order.\n        w: eigenvectors of the generalized problem, normalized such that\n            w.H @ b @ w = I.\n    \"\"\"\n    a = symmetrize(a)\n    b = symmetrize(b)\n    b_inv_a = jax.scipy.linalg.cho_solve(jax.scipy.linalg.cho_factor(b), a)\n    v, w = jax.jit(jax.numpy.linalg.eig, backend=\"cpu\")(b_inv_a)\n    v = v.real\n    # with loops.Scope() as s:\n    #     for _ in s.cond_range(jnp.isrealobj)\n    if jnp.isrealobj(a) and jnp.isrealobj(b):\n        w = w.real\n    # reorder as ascending in w\n    order = jnp.argsort(v)\n    v = v.take(order, axis=0)\n    w = w.take(order, axis=1)\n    # renormalize so v.H @ b @ H == 1\n    norm2 = jax.vmap(lambda wi: (wi.conj() @ b @ wi).real, in_axes=1)(w)\n    norm = jnp.sqrt(norm2)\n    w = w / norm\n    w = standardize_angle(w, b)\n    return v, w\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh_jvp_rule","title":"<code>eigh_jvp_rule(primals, tangents)</code>","text":"<p>Derivation based on Boedekker et al.</p> <p>https://arxiv.org/pdf/1701.00392.pdf</p> <p>Note diagonal entries of Winv dW/dt != 0 as they claim.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@eigh.defjvp\ndef eigh_jvp_rule(primals, tangents):\n    \"\"\"\n    Derivation based on Boedekker et al.\n\n    https://arxiv.org/pdf/1701.00392.pdf\n\n    Note diagonal entries of Winv dW/dt != 0 as they claim.\n    \"\"\"\n    a, b = primals\n    da, db = tangents\n    if not all(jnp.isrealobj(x) for x in (a, b, da, db)):\n        raise NotImplementedError(\"jvp only implemented for real inputs.\")\n    da = symmetrize(da)\n    db = symmetrize(db)\n\n    v, w = eigh(a, b)\n\n    # compute only the diagonal entries\n    dv = jax.vmap(\n        lambda vi, wi: -wi.conj() @ db @ wi * vi + wi.conj() @ da @ wi,\n        in_axes=(0, 1),\n    )(v, w)\n\n    dv = dv.real\n\n    E = v[jnp.newaxis, :] - v[:, jnp.newaxis]\n\n    # diagonal entries: compute as column then put into diagonals\n    diags = jnp.diag(-0.5 * jax.vmap(lambda wi: wi.conj() @ db @ wi, in_axes=1)(w))\n    # off-diagonals: there will be NANs on the diagonal, but these aren't used\n    off_diags = jnp.reciprocal(E) * (_H(w) @ (da @ w - db @ w * v[jnp.newaxis, :]))\n\n    dw = w @ jnp.where(jnp.eye(a.shape[0], dtype=np.bool), diags, off_diags)\n\n    return (v, w), (dv, dw)\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.make_C6","title":"<code>make_C6(v1)</code>","text":"<p>Given a 3x3xNn tensor, make the diagonal 6x6xNn</p> <p>It iterates over a third dimension in the input tensor</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>A tensor of the form (3x3xNn)</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef make_C6(v1) -&gt; jnp.ndarray:\n    \"\"\"Given a 3x3xNn tensor, make the diagonal 6x6xNn\n\n    It iterates over a third dimension in the input tensor\n\n    Parameters\n    ----------\n    v1 : jnp.ndarray\n        A tensor of the form (3x3xNn)\n\n    \"\"\"\n    f = jax.vmap(\n        lambda v: jnp.vstack(\n            [jnp.hstack([v, jnp.zeros((3, 3))]), jnp.hstack([jnp.zeros((3, 3)), v])]\n        ),\n        in_axes=2,\n        out_axes=2,\n    )\n    fv = f(v1)\n    return fv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.moment_force","title":"<code>moment_force(force, X3t, precision)</code>","text":"<p>Yields moments associated to each node due to the forces</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>ndarray</code> <p>Force tensor (Nmx6xNn) for which we want to obtain the resultant moments</p> required <code>X3t</code> <code>ndarray</code> <p>Tilde positions tensor (6x6xNnxNn)</p> required <p>Returns:</p> Type Description <code>jnp.ndarray: (Nmx6xNnxNn)</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef moment_force(force: jnp.ndarray, X3t: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Yields moments associated to each node due to the forces\n\n    Parameters\n    ----------\n    force : jnp.ndarray\n        Force tensor (Nmx6xNn) for which we want to obtain the\n        resultant moments\n    X3t : jnp.ndarray\n        Tilde positions tensor (6x6xNnxNn)\n\n    Returns\n    -------\n    jnp.ndarray: (Nmx6xNnxNn)\n\n    \"\"\"\n\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(1, 1), precision=precision),\n        in_axes=(None, 2),\n        out_axes=2,\n    )  # tensordot along coordinate axis (len=6)\n    f2 = jax.vmap(f1, in_axes=(2, 3), out_axes=3)\n    fuv = f2(force, X3t)\n\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.reshape_modes","title":"<code>reshape_modes(_phi, num_modes, num_nodes)</code>","text":"<p>Reshapes vectors in the input matrix to form a 3rd-order tensor</p> <p>Each vector is made into a 6xNn matrix</p> <p>Parameters:</p> Name Type Description Default <code>_phi</code> <code>ndarray</code> <p>Matrix as in the output of eigenvector analysis (6NnxNm)</p> required <code>num_modes</code> <code>int</code> <p>Number of modes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"num_modes\", \"num_nodes\"])\ndef reshape_modes(_phi: jnp.ndarray, num_modes: int, num_nodes: int):\n    \"\"\"Reshapes vectors in the input matrix to form a 3rd-order tensor\n\n    Each vector is made into a 6xNn matrix\n\n    Parameters\n    ----------\n    _phi : jnp.ndarray\n        Matrix as in the output of eigenvector analysis (6NnxNm)\n    num_modes : int\n        Number of modes\n    num_nodes : int\n        Number of nodes\n\n\n    \"\"\"\n\n    phi = jnp.reshape(_phi, (num_nodes, 6, num_modes), order=\"C\")\n    return phi.T\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.scale","title":"<code>scale(phi1, psi1, phi2, phi1l, phi1ml, psi1l, phi2l, psi2l, omega, X_xdelta, C0ab, C06ab, *args, **kwargs)</code>","text":"<p>Sacales the intrinsic modes</p> <p>The porpuse is that the integrals alpha1 and alpha2 are the identity</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>ndarray</code> required <code>psi1</code> <code>ndarray</code> required <code>phi2</code> <code>ndarray</code> required <code>phi1l</code> <code>ndarray</code> required <code>phi1ml</code> <code>ndarray</code> required <code>psi1l</code> <code>ndarray</code> required <code>phi2l</code> <code>ndarray</code> required <code>psi2l</code> <code>ndarray</code> required <code>omega</code> <code>ndarray</code> required <code>X_xdelta</code> <code>ndarray</code> required <code>C0ab</code> <code>ndarray</code> required <code>C06ab</code> <code>ndarray</code> required <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>def scale(\n    phi1: jnp.ndarray,\n    psi1: jnp.ndarray,\n    phi2: jnp.ndarray,\n    phi1l: jnp.ndarray,\n    phi1ml: jnp.ndarray,\n    psi1l: jnp.ndarray,\n    phi2l: jnp.ndarray,\n    psi2l: jnp.ndarray,\n    omega: jnp.ndarray,\n    X_xdelta: jnp.ndarray,\n    C0ab: jnp.ndarray,\n    C06ab: jnp.ndarray,\n    *args,\n    **kwargs,\n):\n    \"\"\"Sacales the intrinsic modes\n\n    The porpuse is that the integrals alpha1 and alpha2 are the\n    identity\n\n    Parameters\n    ----------\n    phi1 : jnp.ndarray\n    psi1 : jnp.ndarray\n    phi2 : jnp.ndarray\n    phi1l : jnp.ndarray\n    phi1ml : jnp.ndarray\n    psi1l : jnp.ndarray\n    phi2l : jnp.ndarray\n    psi2l : jnp.ndarray\n    omega : jnp.ndarray\n    X_xdelta : jnp.ndarray\n    C0ab : jnp.ndarray\n    C06ab : jnp.ndarray\n    *args :\n    **kwargs :\n\n\n    \"\"\"\n\n    alpha1 = couplings.f_alpha1(phi1, psi1)\n    alpha2 = couplings.f_alpha2(phi2l, psi2l, X_xdelta)\n    num_modes = len(alpha1)\n    # Broadcasting in division\n    alpha1_diagonal = alpha1.diagonal()\n    alpha2_diagonal = alpha2.diagonal()\n    # filter for rigid-body modes\n    alpha2d_filtered = jnp.where(alpha2_diagonal &gt; 1e-4, alpha2_diagonal, 1.0)\n    phi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1ml /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi2 /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    phi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    psi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n\n    return (\n        phi1,\n        psi1,\n        phi2,\n        phi1l,\n        phi1ml,\n        psi1l,\n        phi2l,\n        psi2l,\n        omega,\n        X_xdelta,\n        C0ab,\n        C06ab,\n    )\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.tilde0010","title":"<code>tilde0010(vector)</code>","text":"<p>Tilde matrix for cross product (moments due to forces)</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>A 3-element array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6 matrix with (3:6 x 0:3) tilde operator</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef tilde0010(vector: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Tilde matrix for cross product (moments due to forces)\n\n    Parameters\n    ----------\n    vector : jnp.ndarray\n        A 3-element array\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6 matrix with (3:6 x 0:3) tilde operator\n\n    \"\"\"\n\n    vector_tilde = jnp.vstack(\n        [jnp.zeros((3, 6)), jnp.hstack([tilde(vector), jnp.zeros((3, 3))])]\n    )\n    return vector_tilde\n</code></pre>"},{"location":"api/simulations/","title":"Simulations","text":""},{"location":"api/simulations/#simulations.simulation.Simulation","title":"<code>Simulation</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>feniax/simulations/simulation.py</code> <pre><code>class Simulation(ABC):\n\n    def __init__(self, systems: dict[system.System], sol: solution.Solution, settings):\n        \"\"\"Manages how the various systems are run\n\n        Parameters\n        ----------\n        systems : dict[system.System]\n            System objects\n        sol : solution.Solution\n            Solution object\n        settings : \n            Simulation settings\n\n        \"\"\"\n\n        self.systems = systems\n        self.sol = sol\n        self.settings = settings\n\n    @abstractmethod\n    def trigger(self):\n        \"\"\"Launch the simulations\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _run_systems(self):\n        \"\"\"Implements logic to run the systems: serial, parallel...\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _post_run(self):\n        \"\"\"Anything to run after the systems are solved\n\n        \"\"\"\n        pass\n\n    def __init_subclass__(cls, **kwargs):\n        assert \"cls_name\" in kwargs\n        super().__init_subclass__()\n        if kwargs[\"cls_name\"] in __SIMULATION_DICT__:\n            raise ValueError(\"Name %s already registered!\" % kwargs[\"cls_name\"])\n        __SIMULATION_DICT__[kwargs[\"cls_name\"]] = cls\n</code></pre>"},{"location":"api/simulations/#simulations.simulation.Simulation.__init__","title":"<code>__init__(systems, sol, settings)</code>","text":"<p>Manages how the various systems are run</p> <p>Parameters:</p> Name Type Description Default <code>systems</code> <code>dict[System]</code> <p>System objects</p> required <code>sol</code> <code>Solution</code> <p>Solution object</p> required <code>settings</code> <p>Simulation settings</p> required Source code in <code>feniax/simulations/simulation.py</code> <pre><code>def __init__(self, systems: dict[system.System], sol: solution.Solution, settings):\n    \"\"\"Manages how the various systems are run\n\n    Parameters\n    ----------\n    systems : dict[system.System]\n        System objects\n    sol : solution.Solution\n        Solution object\n    settings : \n        Simulation settings\n\n    \"\"\"\n\n    self.systems = systems\n    self.sol = sol\n    self.settings = settings\n</code></pre>"},{"location":"api/simulations/#simulations.simulation.Simulation.trigger","title":"<code>trigger()</code>  <code>abstractmethod</code>","text":"<p>Launch the simulations</p> Source code in <code>feniax/simulations/simulation.py</code> <pre><code>@abstractmethod\ndef trigger(self):\n    \"\"\"Launch the simulations\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sollibs/","title":"Solvers","text":"<p>Interface to nonlinear and ODE solvers</p>"},{"location":"api/sollibs/#systems.sollibs.factory","title":"<code>factory(module, name)</code>","text":"<p>Factory method for the solvers</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>Name of library providing solvers (diffrax, runge_kutta...)</p> required <code>name</code> <code>str</code> <p>Name of function to be used (ODE, newton...)</p> required <p>Returns:</p> Type Description <code>(Callable, Callable)</code> <p>Two functions, to build the solution object and to extract the states (qs) from this objects</p> Source code in <code>feniax/systems/sollibs/__init__.py</code> <pre><code>def factory(module: str, name: str) -&gt; (Callable, Callable):\n    \"\"\"Factory method for the solvers\n\n    Parameters\n    ----------\n    module : str\n        Name of library providing solvers (diffrax, runge_kutta...)\n    name : str\n        Name of function to be used (ODE, newton...)\n\n    Returns\n    -------\n    (Callable, Callable)\n        Two functions, to build the solution object and to extract the\n        states (qs) from this objects\n\n    \"\"\"\n\n    library = importlib.import_module(f\".{module}\", __name__)\n    function = getattr(library, name)\n    states_puller = getattr(library, \"pull_\" + name)\n    return states_puller, function\n</code></pre>"},{"location":"api/sollibs/#diffrax","title":"Diffrax","text":""},{"location":"api/sollibs/#systems.sollibs.diffrax.ode","title":"<code>ode(F, args, sett, q0, t0, t1, tn, dt, **kwargs)</code>","text":"<p>Diffrax ODE solover</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def ode(\n    F: callable,\n    args,\n    sett,\n    # solver_name: str,\n    q0,\n    t0,\n    t1,\n    tn,\n    dt,\n    # save_at=None,\n    **kwargs,\n) -&gt; diffrax.Solution:\n    \"\"\"\n    Diffrax ODE solover\n    \"\"\"\n\n    # TODO: Logic should be extended and improved\n\n    solver_sett = dict()\n    diffeqsolve_sett = dict()\n    term = diffrax.ODETerm(F)\n    if sett.save_at is None:\n        saveat = diffrax.SaveAt(\n            ts=jnp.linspace(t0, t1, tn)\n        )  # diffrax.SaveAt(steps=True) #\n    else:\n        saveat = sett.save_at\n    _solver = getattr(diffrax, sett.solver_name)\n    if (root := sett.root_finder) is not None:\n        _root_finder = getattr(optx, list(root.keys())[0])\n        root_finder = _root_finder(**list(root.values())[0])\n        solver_sett[\"root_finder\"] = root_finder\n    solver = _solver(**solver_sett)\n\n    if (stepsize := sett.stepsize_controller) is not None:\n        _stepsize_controller = getattr(optx, list(stepsize.keys())[0])\n        stepsize_controller = _stepsize_controller(**list(stepsize.values())[0])\n        diffeqsolve_sett[\"stepsize_controller\"] = stepsize_controller\n\n    sol = diffrax.diffeqsolve(\n        term,\n        solver,\n        t0=t0,\n        t1=t1,\n        dt0=dt,\n        y0=q0,\n        args=args,\n        # throw=False,\n        max_steps=sett.max_steps,\n        saveat=saveat,\n        **diffeqsolve_sett,\n    )\n    return sol\n</code></pre>"},{"location":"api/sollibs/#systems.sollibs.diffrax.pull_newton","title":"<code>pull_newton(sol)</code>","text":"<p>Extract states from diffrax Newton solution object</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def pull_newton(sol):\n    \"\"\"Extract states from diffrax Newton solution object\n    \"\"\"\n\n    qs = jnp.array(sol.value)\n    return qs\n</code></pre>"},{"location":"api/sollibs/#systems.sollibs.diffrax.pull_ode","title":"<code>pull_ode(sol)</code>","text":"<p>Extract states from diffrax ODE solution object</p> Source code in <code>feniax/systems/sollibs/diffrax.py</code> <pre><code>def pull_ode(sol):\n    \"\"\"Extract states from diffrax ODE solution object\n    \"\"\"\n\n    qs = jnp.array(sol.ys)\n    return qs\n</code></pre>"},{"location":"api/sollibs/#runge-kutta","title":"Runge-Kutta","text":""},{"location":"api/systems/","title":"Systems","text":""},{"location":"api/systems/#systems.system.System","title":"<code>System</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>feniax/systems/system.py</code> <pre><code>class System(ABC):\n\n    def __init__(self, name: str, settings: data_container.DataContainer):\n        \"\"\"Initialise object representing system of equations\n\n        Parameters\n        ----------\n        name : str\n            Name of the system\n        settings : data_container.DataContainer\n            system configuration settings\n\n        \"\"\"\n\n        self.name = name\n        self.settings = settings\n\n    @abstractmethod\n    def set_ic(self):\n        \"\"\"\n        Initial conditions for the system\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_system(self):\n        \"\"\"\n        Defines the actual system to be solved based on the inputs\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_solver(self):\n        \"\"\"\n        Picks the solver in ./sollibs to solve the system of equations\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def solve(self):\n        \"\"\"\n        Run the solver on the system of equations\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def build_solution(self):\n        \"\"\"\n        Based on the solution states, build any postprecessing fields\n        \"\"\"\n\n    def __init_subclass__(cls, **kwargs):\n        assert \"cls_name\" in kwargs\n        super().__init_subclass__()\n        if kwargs[\"cls_name\"] in __SYSTEM_DICT__:\n            raise ValueError(\"Name %s already registered!\" % kwargs[\"cls_name\"])\n        __SYSTEM_DICT__[kwargs[\"cls_name\"]] = cls\n</code></pre>"},{"location":"api/systems/#systems.system.System.__init__","title":"<code>__init__(name, settings)</code>","text":"<p>Initialise object representing system of equations</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the system</p> required <code>settings</code> <code>DataContainer</code> <p>system configuration settings</p> required Source code in <code>feniax/systems/system.py</code> <pre><code>def __init__(self, name: str, settings: data_container.DataContainer):\n    \"\"\"Initialise object representing system of equations\n\n    Parameters\n    ----------\n    name : str\n        Name of the system\n    settings : data_container.DataContainer\n        system configuration settings\n\n    \"\"\"\n\n    self.name = name\n    self.settings = settings\n</code></pre>"},{"location":"api/systems/#systems.system.System.build_solution","title":"<code>build_solution()</code>  <code>abstractmethod</code>","text":"<p>Based on the solution states, build any postprecessing fields</p> Source code in <code>feniax/systems/system.py</code> <pre><code>@abstractmethod\ndef build_solution(self):\n    \"\"\"\n    Based on the solution states, build any postprecessing fields\n    \"\"\"\n</code></pre>"},{"location":"api/systems/#systems.system.System.set_ic","title":"<code>set_ic()</code>  <code>abstractmethod</code>","text":"<p>Initial conditions for the system</p> Source code in <code>feniax/systems/system.py</code> <pre><code>@abstractmethod\ndef set_ic(self):\n    \"\"\"\n    Initial conditions for the system\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/systems/#systems.system.System.set_solver","title":"<code>set_solver()</code>  <code>abstractmethod</code>","text":"<p>Picks the solver in ./sollibs to solve the system of equations</p> Source code in <code>feniax/systems/system.py</code> <pre><code>@abstractmethod\ndef set_solver(self):\n    \"\"\"\n    Picks the solver in ./sollibs to solve the system of equations\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/systems/#systems.system.System.set_system","title":"<code>set_system()</code>  <code>abstractmethod</code>","text":"<p>Defines the actual system to be solved based on the inputs</p> Source code in <code>feniax/systems/system.py</code> <pre><code>@abstractmethod\ndef set_system(self):\n    \"\"\"\n    Defines the actual system to be solved based on the inputs\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/systems/#systems.system.System.solve","title":"<code>solve()</code>  <code>abstractmethod</code>","text":"<p>Run the solver on the system of equations</p> Source code in <code>feniax/systems/system.py</code> <pre><code>@abstractmethod\ndef solve(self):\n    \"\"\"\n    Run the solver on the system of equations\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"examples/cpc_examples/","title":"JAX-based Aeroelastic Simulation Engine for Differentiable Aircraft Dynamics","text":"<pre><code>#+setupfile: ./config.org\n</code></pre>"},{"location":"examples/cpc_examples/#house-keeping","title":"House keeping","text":""},{"location":"examples/cpc_examples/#load-modules","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = False\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/cpc_examples/#plotting","title":"Plotting","text":""},{"location":"examples/cpc_examples/#helper-functions","title":"Helper functions","text":"<pre><code>print(f\"Format for figures: {figfmt}\")\ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=6)\n            return fig, figname\n        return inner\n    return inner_decorator\n\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n\n@fig_background\ndef plot_ffb_times(modes, y1, y2, label1, label2):\n\n    fig = None\n    fig = uplotly.lines2d(modes, y1, fig,\n                              dict(name=label1,\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n\n    fig = uplotly.lines2d(modes, y2, fig,\n                          dict(name=label2,\n                               line=dict(color=\"red\")\n                               ),\n                          dict())          \n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=8)\n    fig.update_layout(legend=dict(x=0.7, y=0.95),\n                      height=650,\n                      xaxis_title='Num. modes',\n                      yaxis_title='Computational times [s]')\n    return fig\n\n@fig_background\ndef plot_ffb_error(modes, y1, label1):\n\n    fig = None\n    fig = uplotly.lines2d(modes, y1, fig,\n                              dict(name=label1,\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=8)\n    fig.update_layout(showlegend=False,\n                      #height=800,\n                      xaxis_title='Num. modes',\n                      yaxis_title='Cg error')\n    return fig\n\n@fig_background\ndef xrf1_wingtip2(sol1, sol2, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                  sol1.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                  sol2.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[:], (y1[:]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[0]}\",\n                               line=dict(color=\"orange\")\n                               ))\n    fig = uplotly.lines2d(x2[1:], (y2[:-1]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[1]}\",\n                               line=dict(color=\"steelblue\")\n                               ))\n\n    if nast_scale is not None:\n        offset = 0. #u111m[nast_load[0],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[0]], (u111m[nast_load[0],:,-1, dim] - offset)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[0]}\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\",\n                                             width=1.5)\n                                   ))\n        offset2 = 0. #u111m[nast_load[1],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[1]], (u111m[nast_load[1],:,-1, dim] - offset2)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[1]}\",\n                                   line=dict(color=\"red\",\n                                             dash=\"dot\",\n                                             width=1.5)\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n\ndef subplots_wtips(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        specs=[[{\"colspan\": 2}, None],\n                               [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=2, col=2\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\ndef subplots_wtips2(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig2.update_xaxes(title=None)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig1.layout.xaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig1.layout.yaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    fig.update_layout(legend=dict(x=0.81, y=1))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n\ndef subplots_xrf1wtips(sol1, sol2, labels=None, nast_scale=None, nast_load=None):\n\n    fig1 = xrf1_wingtip2(sol1, sol2, 0, labels,nast_scale, nast_load)\n    fig2 = xrf1_wingtip2(sol1, sol2, 1, labels,nast_scale, nast_load)\n    fig3 = xrf1_wingtip2(sol1, sol2, 2, labels,nast_scale, nast_load)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n\n    # fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.1, vertical_spacing=0.1,\n    #                    specs=[[{\"colspan\": 2}, None],\n    #                           [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n@fig_background\ndef xrf1_wingtip4(sol1, sol2, sol3, sol4, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                    sol1.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                    sol2.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x3, y3 = putils.pickIntrinsic2D(sol3.data.dynamicsystem_s1.t,\n                                    sol3.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x4, y4 = putils.pickIntrinsic2D(sol4.data.dynamicsystem_s1.t,\n                                    sol4.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[0]}\",\n                               line=dict(color=\"orange\",\n                                         dash=\"solid\")\n                               ))\n    fig = uplotly.lines2d(x2[:], (y2[:]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[1]}\",\n                               line=dict(color=\"blue\", dash=\"dot\")\n                               ))\n    fig = uplotly.lines2d(x3[:], (y3[:]-y3[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[2]}\",\n                               line=dict(color=\"red\")\n                               ))\n    fig = uplotly.lines2d(x4[:], (y4[:]-y4[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[3]}\",\n                               line=dict(color=\"grey\", dash=\"dash\")\n                               ))\n\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n\n@fig_background\ndef wsp_wingtip(sol_list, dim, labels=None, nast_load=None, axes=None,\n                modes = [5, 15, 30, 50, 100],scale = 1./28.8):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.ra,\n                                      fixaxis2=dict(node=23, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    if nast_load is not None:\n        fig = uplotly.lines2d(t_wsp[nast_load], u_wsp[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-NL\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\")\n                                   ))\n        fig = uplotly.lines2d(t_wspl[nast_load], u_wspl[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-Lin\",\n                                   line=dict(color=\"orange\",\n                                             #dash=\"dash\"\n                                             )\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    if axes is None:\n        fig.update_yaxes(title=r'$\\Large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=[0, 15], title='$\\large time \\; [s]$')\n    else:\n        fig.update_yaxes(range=axes[1], title=r'$\\large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=axes[0], title='$\\large time \\; [s]$')\n\n    return fig\n\n@fig_background\ndef wsp_rootload(sol_list, dim,\n                 labels = ['0.5', '1.', '1.5'], nodei=2, scale = 1e-3):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.X2,\n                                      fixaxis2=dict(node=nodei, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large f_%s \\; [MN/m]$'%(dim+1))\n    fig.update_xaxes(range=[0, 10], title='$\\large time \\; [s]$')\n\n    return fig\n\ndef subplots_wsp(sol_list, labels=None, nast_load=None, axes=None):\n\n    fig1 = wsp_wingtip(sol_list, 0, labels, nast_load, axes)\n    fig2 = wsp_wingtip(sol_list, 1, labels, nast_load, axes)\n    fig3 = wsp_wingtip(sol_list, 2, labels, nast_load, axes)\n    fig = make_subplots(rows=2, cols=2, horizontal_spacing=1, vertical_spacing=5,\n                        specs=[[{\"colspan\": 2}, None],\n                               [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=2, col=2\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\ndef fn_spErrorold(sol_list, config, print_info=True):\n\n  sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n  err = {f\"M{i}_L{j}\": 0. for i in range(1,6) for j in range(6)}\n  for li in range(6): # loads\n    for mi in range(1,6):  # modes\n      count = 0  \n      for index, row in config.fem.df_grid.iterrows():\n        r_spn = u_sp[li, row.fe_order,:3] + config.fem.X[index]\n        r_sp = sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index]\n        err[f\"M{mi}_L{li}\"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)\n        # print(f\"nas = {r_spn}  ,  {r_sp}\")\n        count += 1\n      err[f\"M{mi}_L{li}\"] /= count\n      if print_info:\n          print(f\"**** LOAD: {li}, NumModes: {mi} ****\")\n          print(err[f\"M{mi}_L{li}\"])\n  return err\n\ndef fn_spError(sol_list, config, print_info=True):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    err = {f\"M{i}_L{j}\": 0. for i in range(1,6) for j in range(6)}\n    for li in range(6): # loads\n      for mi in range(1,6):  # modes\n        count = 0\n        r_spn = []\n        r_sp = []\n        for index, row in config.fem.df_grid.iterrows():\n          r_spn.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n          r_sp.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n        r_spn = jnp.array(r_spn)\n        r_sp = jnp.array(r_sp)        \n        err[f\"M{mi}_L{li}\"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)\n        err[f\"M{mi}_L{li}\"] /= len(r_sp)\n        if print_info:\n            print(f\"**** LOAD: {li}, NumModes: {mi} ****\")\n            print(err[f\"M{mi}_L{li}\"])\n    return err\n\ndef fn_spWingsection(sol_list, config):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    r_spn = []\n    r_spnl = []\n    r_sp = []\n    for li in range(6): # loads\n      for mi in [4]:#range(1,6):  # modes\n        r_spni = []\n        r_spnli = []\n        r_spi = []\n        r_sp0 = []\n        for index, row in config.fem.df_grid.iterrows():\n          if row.fe_order in list(range(20)):\n            r_sp0.append(config.fem.X[index])  \n            r_spni.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n            r_spnli.append(u_spl[li, row.fe_order,:3] + config.fem.X[index])\n            r_spi.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n\n        r_spn.append(jnp.array(r_spni))\n        r_spnl.append(jnp.array(r_spnli))\n        r_sp.append(jnp.array(r_spi))\n    r_sp0 = jnp.array(r_sp0)\n    return r_sp0, r_sp, r_spn, r_spnl\n\n@fig_background\ndef plot_spWingsection(r0, r, rn, rnl):\n    fig = None\n    # colors=[\"darkgrey\", \"darkgreen\",\n    #         \"blue\", \"magenta\", \"orange\", \"black\"]\n    # dash = ['dash', 'dot', 'dashdot']\n    modes = [5, 15, 30, 50, 100]\n    for li in range(6):\n      if li == 0:   \n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"NMROM\",\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-NL\",\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-Lin\",\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())\n\n      else:\n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())            \n    fig.update_yaxes(title=r'$\\large u_z [m]$')\n    fig.update_xaxes(title=r'$\\large S [m]$', range=[6.81,36])\n    fig.update_layout(legend=dict(x=0.6, y=0.95),\n                      font=dict(size=20))\n    # fig = uplotly.lines2d((rnl[:,0]**2 + rnl[:,1]**2)**0.5, rnl[:,2], fig,\n    #                       dict(name=f\"NASTRAN-101\",\n    #                            line=dict(color=\"grey\",\n    #                                      dash=\"solid\")\n    #                                  ),\n    #                             dict())\n    return fig\n\n@fig_background\ndef fn_spPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    e250 = jnp.array([error[f'M{i}_L1'] for i in range(1,6)])\n    e400 = jnp.array([error[f'M{i}_L3'] for i in range(1,6)])\n    e530 = jnp.array([error[f'M{i}_L5'] for i in range(1,6)])\n    fig = None\n    fig = uplotly.lines2d(num_modes, e250 , fig,\n                              dict(name=\"F = 250 KN\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e400, fig,\n                              dict(name=\"F = 400 KN\",\n                                   line=dict(color=\"green\", dash=\"dash\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e530, fig,\n                              dict(name=\"F = 530 KN\",\n                                   line=dict(color=\"black\", dash=\"dot\")\n                                   ),\n                              dict())\n    fig.update_xaxes(title= {'font': {'size': 20}, 'text': 'Number of modes'})#title=\"Number of modes\",title_font=dict(size=20))\n    fig.update_yaxes(title=r\"$\\Large \\epsilon$\",type=\"log\", # tickformat= '.1r',\n                     tickfont = dict(size=12), exponentformat=\"power\",\n                     #dtick=0.2,\n                     #tickvals=[2e-2, 1e-2, 7e-3,5e-3,3e-3, 2e-3, 1e-3,7e-4, 5e-4,3e-4, 2e-4, 1e-4, 7e-5, 5e-5]\n                     )\n    #fig.update_layout(height=650)\n    fig.update_layout(legend=dict(x=0.7, y=0.95), font=dict(size=20))\n\n    return fig\n\n@fig_background\ndef fn_spPloterror3D(error, error3d):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    if error is not None:\n      fig = uplotly.lines2d(loads, error, fig,\n                                dict(name=\"Error ASET\",\n                                     line=dict(color=\"red\"),\n                                     marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n    fig = uplotly.lines2d(loads, error3d, fig,\n                              dict(name=\"Error full 3D\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      # showlegend=False,\n                      #legend=dict(x=0.7, y=0.95),\n                      xaxis_title='Loading [KN]',\n                      yaxis_title=r'$\\Large \\epsilon$')\n\n    return fig\n\n@fig_background\ndef plot_spAD(rn, r0):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    x = list(range(1,7))\n    y = [rn[i-1][-1, 2] - r0[-1,2] for i in x]\n    fig = uplotly.lines2d(x, y, fig,\n                                dict(#name=\"Error ASET\",\n                                     #line=dict(color=\"red\"),\n                                     #marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n\n    #fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      showlegend=False,\n                      xaxis_title=r'$\\Large{\\tau}$',\n                      yaxis_title='Uz [m]'\n    )\n\n    return fig\n\ndef fn_wspError(sol_list):\n    error_dict = dict()\n    for i, si in enumerate(sol_list):\n        for di in range(3):\n            x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                          si.data.dynamicsystem_s1.ra,\n                                          fixaxis2=dict(node=23, dim=di))\n            yinterp = jnp.interp(t_wsp, x, y)\n            ynastran = u_wsp[0,:,-4, di] + y[0]\n            n = 10000\n            error = jnp.linalg.norm((yinterp[1,:n] - ynastran[:n]) / ynastran[:n]) / len(ynastran[:n])\n            label = f\"M{i}x{di}\"\n            error_dict[label] = error\n\n    return error_dict\n\n@fig_background\ndef fn_wspPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    ex1 = [error[f'M{i}x0'] for i in range(5)]\n    ex2 = [error[f'M{i}x1'] for i in range(5)]\n    ex3 = [error[f'M{i}x2'] for i in range(5)]\n    fig = None\n    fig = uplotly.lines2d(num_modes, ex1, fig,\n                              dict(name=\"Error - x1\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex2, fig,\n                              dict(name=\"Error - x2\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex3, fig,\n                              dict(name=\"Error - x3\",\n                                   line=dict(color=\"black\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    return fig\n\n@fig_background\ndef fn_wspPloterror3D(time, error):\n\n    fig = None\n    fig = uplotly.lines2d(time, error, fig,\n                              dict(name=\"Error\",\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=7)\n    fig.update_layout(\n                      #height=700,\n                      xaxis_title=r'$\\Large time [s]$',\n                      yaxis_title=r'$\\Large \\epsilon$')\n    return fig\n</code></pre>"},{"location":"examples/cpc_examples/#nastran-data","title":"NASTRAN data","text":"<p>Read data from Nastran simulations</p> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n\n\nexamples_path = pathlib.Path(\"../../../../examples\")\n####### SailPlane ###########\nSP_folder = examples_path / \"SailPlane\"\n#nastran_path = wingSP_folder / \"NASTRAN/\"\n\nop2model = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run.op2\",\n                                   SP_folder / \"NASTRAN/static400/run.bdf\",\n                                 static=True)\n\nop2model.readModel()\nt_sp, u_sp = op2model.displacements()\n\nop2modell = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run_linear.op2\",\n                                   SP_folder / \"NASTRAN/static400/run_linear.bdf\",\n                                 static=True)\n\nop2modell.readModel()\nt_spl, u_spl = op2modell.displacements()\n\n####### wingSP ###########\nwingSP_folder = examples_path / \"wingSP\"\nnastran_path = wingSP_folder / \"NASTRAN/\"\nnas_wspl = op2reader.NastranReader(op2name=(nastran_path / \"wing_109d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wspl.readModel()\nt_wspl, u_wspl = nas_wspl.displacements()  \n# ###\nnas_wsp = op2reader.NastranReader(op2name=(nastran_path / \"wing400d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wsp.readModel()\nt_wsp, u_wsp = nas_wsp.displacements()\n####### XRF1 ###########\nnastran_path = examples_path / \"XRF1/NASTRAN/146-111/\"\nnas111 = op2reader.NastranReader(op2name=(nastran_path / \"XRF1-146run.op2\"))\nnas111.readModel()\nt111, u111 = nas111.displacements()\n\nnastran_pathm = examples_path / \"XRF1/NASTRAN/146-111_081\"\nnas111m = op2reader.NastranReader(op2name=(nastran_pathm / \"XRF1-146run.op2\"))\nnas111m.readModel()\nt111m, u111m = nas111m.displacements()\n\nsp_error3d = jnp.load(examples_path/ \"SailPlane/sp_err.npy\")\nwsp_error3d = jnp.load(examples_path/ \"wingSP/wsp_err.npy\")\n</code></pre>"},{"location":"examples/cpc_examples/#examples","title":"Examples","text":"<p>The cases presented are a demonstration of our solution approach to manage geometric nonlinearities, the accuracy of the solvers when compared to full FE simulations, and the computational gains that can be achieved. All computations are carried out on a single CPU with an i7-6700 processor of 3.4 GHz clock speed.</p>"},{"location":"examples/cpc_examples/#structural-verification-of-a-representative-configuration","title":"Structural verification of a representative configuration","text":"<p>A representative FE model of a full aircraft without engines is used to demonstrate a versatile solution that accounts for geometric nonlinearities in a very efficient manner and only needs modal shapes and linear FE matrices from a generic FE solver as inputs. Another of the goals set for this work was to achieve an equally flexible strategy in the automatic calculation of derivatives across the various solvers in the code. The structural static and dynamic responses and their sensitivities with respect to input parameters are verified against MSC Nastran and finite differences respectively.\\ The aircraft's main wing is composed of wing surfaces, rear and front spars, wing box and ribs with composite materials employed in the construction. Flexible tail and rear stabiliser are rigidly attached to the wing (28.8 m of span), as shown in Fig. 1. This aircraft was first used in cite:&amp;CEA2021a and is a good test case as it is not very complex yet representative of aircraft FE models and it is available open source.</p> <p></p> <p>A Guyan reduction is employed in the reduction process and Fig. 2 illustrates the accuracy of the condensed model by comparing the 3D modal shapes. No differences can be appreciated for the first few modes (the lowest frequency corresponding to a bending mode agrees in both models at $\\omega_1=4.995$ rads/s), so we show higher frequency modes: a high order bending mode ($\\omega_{10}=60.887/60.896$ rads/s in full versus reduced models) and a torsional mode ($\\omega_{20}=107.967/107.969$ rads/s). This very good preservation of the full model leads to an excellent accuracy in the static and dynamic results presented below. It is important to remark this aircraft model is typical of previous generations airliners and does not feature high-aspect ratio wings. Therefore while this modelling strategy would not be suitable for every engineering structure, as long as there is a dominant dimension and deformations in the other two remain small (as is the case in high level descriptions of aircraft, bridges or wind turbines) it has been found to produce very good approximations when compared with full dimensional solutions.</p> <p><pre><code>#+name: fig:modes2\n</code></pre> <pre><code>#+caption: Full VS reduced order models on the 10th modal shape $\\omega_{10}=60.887/60.896$ rads/s\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:figs_ext/SPM7af2.pdf</p> <p><pre><code>#+name: fig:modes\n</code></pre> <pre><code>#+caption: Full VS reduced order models on the 20th modal shape, $\\omega_{20}=107.97$ rads/s\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:figs_ext/SPM19af2.pdf</p>"},{"location":"examples/cpc_examples/#geometrically-nonlinear-static-response","title":"Geometrically nonlinear static response","text":"<p>The static equilibrium of the aircraft under prescribed loads is first studied with follower loads normal to the wing applied at the tip of each wing (nodes 25 and 48). The response for an increasing load stepping of 200, 300, 400, 480 and 530 KN is computed. The snippet of the inputs and simulation call are given in Listing <code>\\ref{code:static}</code>.</p> <p> </p> <p>Nonlinear static simulations on the original full model (before condensation) are also carried out in MSC Nastran and are included. The interpolation elements in the full FE solver are used to output the displacements at the condensation nodes for direct comparison with the NMROM results. Geometric nonlinearities are better illustrated by representing a sectional view of the wing as in Fig. 2, where deformations in the z-direction versus the metric $S = \\sqrt{x^2+y^2}$ are shown. MSC Nastran linear solutions (Solution 101) are also included to appreciate more clearly the shortening and follower force effects in the nonlinear computations.</p> <pre><code>import feniax.preprocessor.configuration as configuration\nconfig = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nr_sp0, r_sp, r_spn, r_spnl = fn_spWingsection(sol_sp, config)\nfig, figname = fig_out(name)(plot_spWingsection)(r_sp0, r_sp, r_spn, r_spnl)\nfigname\n</code></pre> <p></p> <p>The tolerance in the Newton solver was set to $10^{-6}$ in all cases. A convergence analysis with the number of modes in the solution is presented in Fig. 3. 5, 15, 30, 50, 100 modes are used to build the corresponding NMROMs. The error metric is defined as the $\\ell^2$ norm divided by the total number of nodes (only the condenses ones in this case): $\\epsilon = ||u_{NMROM} - u_{NASTRAN}||/N_{nodes}$. It can be seen the solution with 50 modes already achieves a very good solution even for the largest load which produces a 25.6$\\%$ tip deformation of the wing semi-span, $b = 28.8$ m. The displacement difference with the full FE solution at the tip in this case is less than 0.2$\\%$.</p> <pre><code>config = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nsp_error = fn_spError(sol_sp, config, print_info=True)\nfig, figname = fig_out(name)(fn_spPloterror)(sp_error)\nfigname\n</code></pre> <p></p> <p>The 3D structural response has been reconstructed using the approach in Fig. . The nodes connected by the interpolation elements (RBE3s) to the ASET solution are reconstructed first and subsequently a model with RBFs kernels is used to extrapolate to the rest of the nodes in the full FE. A very good agreement is found against the geometrically-nonlinear Nastran solution (SOL 400). Fig. 4 shows the overlap in the Nastran solution (in red) and the NMROM (in blue) for the 530 KN loading.</p> <p><pre><code>#+name: SPstatic_3D\n</code></pre> <pre><code>#+caption: Static 3D solution for a solution with 50 modes and 530 KN loading (Full NASTRAN solution in red versus the NMROM in blue).\n</code></pre> <pre><code>#+attr_latex: :width 0.7\\textwidth\n</code></pre>  The error metric of this 3D solution is also assessed in Fig. 4, for the solution with 50 modes. The discrepancy metric is of the same order than the previously shown at the reduction points. This conveys an important point, that there is no significant accuracy loss in the process of reconstructing the 3D solution.</p> <pre><code>sp_error1D = [sp_error[f'M4_L{i}'] for i in range(6)]\n# fig, figname = fig_out(name)(fn_spPloterror3D)(sp_error1D, sp_error3d)\nfig, figname = fig_out(name,update_layout=dict(showlegend=False))(fn_spPloterror3D)(None, sp_error3d)\nfigname\n</code></pre> <p></p> <p>Next we compare the computational times for the various solutions presented in this section in Table 1. Computations of the six load steps in Fig. 2 are included in the assessment. A near 50 times speed-up is achieved with our solvers compared to Nastran nonlinear solution, which is one of the main strengths of the proposed method. As expected, the linear static solution in Nastran is the fastest of the results, given it only entails solving a linear, very sparse system of equations.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'SP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [5*60 + 45]\nvalues += [1.02]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 101\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 101\n</code></pre> <p>Time    1.97, 2.05, 2.13, 2.17, 2.3         345           1.02</p> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 101\n</code></pre> Time    6.7, 6.63, 6.79, 7.06, 9.55         345           1.02 <p>Computational times static solution {#table:SP_times}</p>"},{"location":"examples/cpc_examples/#differentiation-of-static-response","title":"Differentiation of static response","text":"<p>The AD for the static solvers is first verified as follows: the load stepping shown above becomes a pseudo-time interpolation load such that a variable $\\tau$ controls the amount of loading and we look at the variation of the wing-tip displacement as a function of this $\\tau$. If $f(\\tau=[1, 2, 3, 4, 5, 6]) = [200, 250, 300, 400, 480, 530]$ KN, with a linear interpolation between points, the derivative of the z-component of the tip of the wing displacement is computed at $\\tau= 1.5, 3.5, 5.5 $, as show in Fig. 5 where the $y$-axis is the tip displacement, $\\tau$ is in the $x$-axis and the big red circles the points where the derivatives are computed (coincident to the graph slope at those points).</p> <pre><code>fig, figname = fig_out(name)(plot_spAD)(r_sp, r_sp0)\n#figname\n</code></pre> <p><pre><code>#+results: SP_AD\n</code></pre> file:</p> <p><pre><code>#+name: fig:sp_ad\n</code></pre> <pre><code>#+caption: Static tip displacement with pseudo-time stepping load\n</code></pre> <pre><code>#+attr_latex: :width 0.5\\textwidth\n</code></pre>  Table 2 shows a very good agreement against finite-differences (FD) with an epsilon of $10^{-3}$. Note how the derivative at each of the marked points corresponds approximately to the slope in the graph at those very points, which varies as the load steps are not of equal length. And the biggest slope occurs precisely in between $\\tau$ of 4 and 5 when the prescribed loading undergoes the biggest change from 300 to 400 KN. <p>$\\tau$   $f(\\tau)$    $f'(\\tau)$ (AD)   $f'(\\tau)$ (FD)</p> 1.5      2.81              0.700             0.700   3.5      4.527             1.344             1.344   5.5      6.538             0.623             0.623 <p>AD verification structural static problem {#table:SP_AD}</p>"},{"location":"examples/cpc_examples/#large-amplitude-nonlinear-dynamics","title":"Large-amplitude nonlinear dynamics","text":"<p>This test case demonstrates the accuracy of the NMROM approach for dynamic geometrically-nonlinear calculations. The right wing of Fig. 1 is considered and dynamic nonlinear simulations are carried out and compared to commercial solutions of the full FE model. A force is applied at the wing tip with a triangular loading profile, followed by a sudden release of the applied force to heavily excite the wing. The force profile is given in Fig. 5. The applied force is then $f_{tip} = \\alpha \\textup{\\pmb{f}}{max} f(0.05, 4)$ with $\\textup{\\pmb{f}} = [-2\\times 10^5, 0., 6\\times 10^5]$ where $\\alpha$ has been set to $1$.</p> <p><pre><code>#+name: fig:ramping_load\n</code></pre> <pre><code>#+caption: Ramping load profile for dynamic simulation of representative wing\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:./figs_ext/ramping_load.pdf The dynamic response is presented in Fig. 5, where results have been normalised with the wing semi-span ($l=28.8$ m). As expected, linear analysis over-predicts vertical displacements and does not capture displacements in the $x$ and $y$ directions. NMROMs were built with 5, 15, 30, 50 and 100 modes. A Runge-Kutta four is used to march the equation in time with time steps corresponding to the inverse of the largest eigenvalue in the NMROM, i.e. $\\Delta t = [27.34, 6.62, 2.49, 1.27, 0.575] \\times 10^{-3}$ s.</p> <pre><code>sol_wsp= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [1,2,4]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.9385,\n    font=dict(size= 10))))(subplots_wtips2)(wsp_wingtip, sol_wsp, labels=None, nast_load=0, modes=[5,15,50])\nfigname\n</code></pre> <p></p> <p>As in the previous example, the 3D shape of the model is retrieved and compared against the full nonlinear dynamic solution, as illustrated in Fig. 6 (Nastran solution in yellow and NMROM with 50 modes in blue). The times at positive and negative peaks are displayed. Even though a wing of such characteristics would never undergo in practice this level of deformations, these results further support the viability of the methodology to solve highly geometrically nonlinear dynamics, on complex models and with minimal computational effort.</p> <p></p> <p>Next we look at the differences of the dynamic simulations with the same metric employed above that now evolves in time. Integration errors accumulate and discrepancies grow with time but still remain small. In fact the differences between MSC Nastran and our dynamic solvers are comparable to the static example with the highest load (around the $5\\times 10^{-5}$ mark). Both cases displaying maximum deformations around 25\\% of the wing semi-span.</p> <pre><code>wsp_error = fn_wspError(sol_wsp)\nwsp_error_time = jnp.linspace(0,15,10001)\nfig, figname = fig_out(name, update_layout=dict(showlegend=False, margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=5,\n                              t=2,\n                              b=0)))(fn_wspPloterror3D)(wsp_error_time,wsp_error3d)\nfigname\n</code></pre> <p></p> <p>An impressive reduction of computational time is achieved by our solvers as highlighted in Table 3. The nonlinear response of the full model took 1 hour 22 minutes, which is over two orders of magnitude slower than the NMROM with 50 modes resolution, which proved very accurate. The significant increase in computational effort when moving from a solution with 50 modes to 100 modes is due to various factors: vectorised operations are limited and the quadratic nonlinearities ultimately lead to O($N_m^3$) algorithms; the time-step needs to be decreased for the Runge-Kutta integration to remain stable; the additional overheads that come with saving and moving larger tensors, from the modal shapes, the cubic modal couplings, to the system states (note times shown account for all the steps from start to end of the simulation, including saving all the data for postprocessing).</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'WSP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [1*60*60 + 22*60]\nvalues += [33.6]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 109\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <p><pre><code>#+results: WSP_times\n</code></pre>                NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 109</p> Time    2.79, 2.92, 4.85, 12.14, 155.3      4920          33.6 <p>Computational times representative wing dynamic solution</p>"},{"location":"examples/cpc_examples/#differentiation-of-dynamic-response","title":"Differentiation of dynamic response","text":"<p>We move now to a novel feature of this work, i.e. the ability to compute gradients via automatic differentiation in geometrically nonlinear dynamic problems. The maximum root loads occurring in a wing subjected to dynamic loads is a good test case as it can be a critical metric in sizing the aircraft wings, especially high-aspect ratio ones. Thus we look at the variation of the maximum z-component of the vertical internal forces as a function of $\\alpha$ in the loading profile of Fig. 5. Effectively, the slope of the loading increases with $\\alpha$. Table 4 shows the derivatives computed using FD with an epsilon of $10^{-4}$ and AD in reverse-mode on the example with 50 modes resolution. In this case the FD needed tweaking of epsilon while application of AD was straight forward with no need for checkpoints and took around three times the speed of a single calculation.</p> <p>$\\alpha$   $f(\\alpha)$    $f'(\\alpha)$ (AD)   $f'(\\alpha)$ (FD)</p> 0.5        1706.7                 3587.71             3587.77   1.0        3459.9                 3735.26             3735.11   1.5        5398.7                 3957.81             3958.31 <p>AD verification structural dynamic problem {#table:AD_WSP}</p> <p>It is worth noting the high frequency dynamics excited after the ramping load is suddenly released. In fact in the $z$-component of the wing-tip evolution in Fig. 8 we can see a maximum tip displacement of 4.36 m, 7.91 m and 10.83 m, for $\\alpha = 0.5, 1, 1.5$ i.e smaller than the proportional linear response. On the other hand, in Fig. 9 the evolution of the root loads show a response with much higher frequencies and the maximum occurs in the free dynamical response of the wing, which is higher as we increase $\\alpha$.</p> <pre><code>sol_wspz= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [\"4alpha05\",\n                                                          \"4\",\n                                                          \"4alpha15\"]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.3,\n    font=dict(size= 16))))(wsp_wingtip)(sol_wspz, dim=2, modes=[\"0.5\",\"1\",\"1.5\"], axes=[[0,10],None])\nfigname\n</code></pre> <p></p> <pre><code>fig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.941,\n    font=dict(size= 16))))(wsp_rootload)(sol_wspz, dim=2, scale=1e-6)\nfigname\n</code></pre> <p></p>"},{"location":"examples/cpc_examples/#aeroelastic-dynamic-loads-on-an-industrial-configuration","title":"Aeroelastic dynamic loads on an industrial configuration","text":"<p>The studies presented in this section are based on a reference configuration developed to industry standards known as XRF1, which is representative of a long-range wide-body transport airplane. The version with a wing-tip extension in [@CEA2023] is employed to verify a gust response against MSC Nastran linear solution of the full FE model. While the previous results where purely structural, now the dynamic response to an atmospheric disturbance or gust is computed. This aeroelastic analysis is a requirement for certification purposes and it is one of the main drivers in sizing the wings of high aspect ratio wings. Furthermore, the previous examples showed the advantage of our approach in terms of computational speed, but other than that results could be obtained with commercial software. The geometrically nonlinear aeroelastic response, however, it is not currently available in commercial solutions that are bounded to linear analysis in the frequency domain. Other research codes feature those additional physics, yet are limited to simple models. Thus the added value in the proposed approach comes at the intersection between the nonlinear physics arising from large integrated displacements, computational efficiency and the ability to enhance the models already built for industrial use.\\ Fig. 10 shows the reference FE model with three modal shapes. The FE model contains a total of around 177400 nodes, which are condensed into 176 active nodes along the reference load axes through interpolation elements. A Guyan or static condensation approach is used for the reduction and the error in the natural frequencies between full and reduced models is kept below 0.1% well beyond the 30th mode. The aerodynamic model contains $\\sim 1,500$ aerodynamic panels. The simulations are carried out with a modal resolution of 70 modes and a time step in the Runge-Kutta solver of 0.005.</p> <p><pre><code>#+name: fig:xrf1_modalshapes\n</code></pre> <pre><code>#+caption: Modified XRF1 reference configuration with characteristic modal shapes\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> file:figs_ext/xrf1_modalshapes3.pdf</p>"},{"location":"examples/cpc_examples/#linear-response-for-low-intensity-gust","title":"Linear response for low intensity gust","text":"<p>A verification exercise is introduced first by applying two 1-cos gust shapes at a very low intensity, thus producing small deformations and a linear response. The flow Mach number is 0.81. A first gust is applied that we name as G1 of length 67 m and peak velocity 0.141 m/s, and a second gust, G2, of 165 m and peak velocity of 0.164 m/s. A snippet of the inputs to the simulation is display in Listing <code>\\ref{code:dynamic}</code>.</p> <p> </p> <p>Fig. 10 shows the normalised wing-tip response with our NMROM that accurately reproduces the linear solution based on the full FE model.</p> <pre><code>sol1= solution.IntrinsicReader(\"./XRF1\")\nsol2= solution.IntrinsicReader(\"./XRF2\")\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip2,sol1, sol2, labels=[1,2], nast_scale=0.01, nast_load=[2,6])\nfigname\n</code></pre> <p></p>"},{"location":"examples/cpc_examples/#nonlinear-response-for-high-intensity-gust","title":"Nonlinear response for high intensity gust","text":"<p>The gust intensity in the previous section by a factor of 200 in order to show the effects of geometric nonlinearities that are only captured by the nonlinear solver. As seen in Fig. 11, there are major differences in the $x$ and $y$ components of the response due to follower and shortening effects, and a slight reduction in the $z$-component. These are well known geometrically nonlinear effects that are added to the analysis with no significant overhead.</p> <pre><code>sol1= solution.IntrinsicReader(\"./XRF3\")\nsol2= solution.IntrinsicReader(\"./XRF4\")\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip2, sol1, sol2, labels=[1,2], nast_scale=2., nast_load=[2,6])\nfigname\n</code></pre> <p></p> <p>Snapshots of the 3D response are reconstructed for the G1 gust using the method verified above at the time points where tip displacement are maximum and minimum, i.e. 0.54 and 0.84 seconds. The front and side views together with the aircraft reference configuration are shown in Fig. 12.</p> <p><pre><code>#+name: fig:xrf1gust3D\n</code></pre> <pre><code>#+caption: 3D XRF1 Nonlinear gust response\n</code></pre> <pre><code>#+attr_latex: :width 1\\textwidth\n</code></pre> file:figs_ext/xrf1gust3D2.pdf</p> <p>In previous examples the same Runge-Kutta 4 (RK4) time-marching scheme is used and now we explore the dynamic solution with other solvers to assess their accuracy and also their computational performance. Two explicit ODE solvers, RK4 and Dormand-Prince\\'s 5/4 method (labelled S1 and S2), and two implicit, Euler first order and Kvaerno\\'s 3/2 method ((labelled S3 and S4)), are compared in Fig. 12. In order to justify the use of implicit solvers we reduce the time step from 0.005 to 0.02 seconds, at which point both explicit solvers diverge. Kvaerno\\'s implicit solver remain stable and accurate despite the larger time step while the Euler implicit method is stable but do not yield accurate results.</p> <pre><code>sol3= solution.IntrinsicReader(\"./XRF3\")\nsol5= solution.IntrinsicReader(\"./XRF5\")\nsol7= solution.IntrinsicReader(\"./XRF7\")\nsol8= solution.IntrinsicReader(\"./XRF8\")\n\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip4, sol1=sol3, sol2=sol5, sol3=sol7, sol4=sol8,\n                                            labels=[\"S1\",\"S2\",\"S3\",\"S4\"])\nfigname\n</code></pre> <p><pre><code>#+name: fig:GustXRF3578\n</code></pre> <pre><code>#+caption: Wing-tip response to high intensity gust using implicit solvers\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> <pre><code>#+results: GustXRF3578\n</code></pre> file:</p> <p>The computational times of the different solvers are shown in Table 5. The implicit solvers have taken one order of magnitude more time to run despite the reduction in time step. Therefore the main take away this is that for moderately large frequency dynamics, the explicit solvers offer a much efficient solution. The turning point for using implicit solvers would be when the largest eigenvalue in Eqs. <code>\\ref{eq2:sol_qs}</code> led to prohibitly small time steps. In terms of the Nastran solution, we are not showing the whole simulation time because that would include the time to sample the DLM aerodynamics which are input into the NMROM as a post-processing step. Instead, the increase in time when adding an extra gust subcase to an already existing analysis is shown, i.e. the difference between one simulation that only computes one gust response and another with two. It is remarkable that the explicit solvers are faster on the nonlinear solution than the linear solution by a commercial software. Besides our highly efficient implementation, the main reason for this might be the Nastran solution involves first a frequency domain analysis and then an inverse Fourier transform to obtain the time-domain results.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'XRF{i}'].iloc[0], 2)) for i in [3,5,7,8]])]\nvalues += [0*60*60 + 1*60 + 21]\nheader = [\"NMROM [S1, S2, S3, S4]\" ]\nheader += [\"$\\Delta$ NASTRAN 146\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <p><pre><code>#+results: XRF1_times\n</code></pre>                NMROM        $\\Delta$ NASTRAN 146</p> Time    22.49, 18.94, 273.95, 847.89   81 <p>Computational times XRF1 gust solution. {#table:XRF1_times}</p>"},{"location":"examples/cpc_examples/#differentiation-of-aeroelastic-response","title":"Differentiation of aeroelastic response","text":"<p>Similarly to the examples above, we now verify the AD implementation for the nonlinear aeroelastic response to the gust $G1$. The sensitivity of the six components of the wing root loads are computed with respect to the gust parameters $w_g$ and $L_g$, and the flow parameter $\\rho_{\\inf}$. The results are presented in 1. A very good agreement with the finite differences is found with $\\epsilon=10^{-4}$.</p> <p><pre><code>#+caption: Automatic differentiation in aeroelastic problem\n</code></pre> <pre><code>#+name: table:XRF1_AD\n</code></pre> </p>"},{"location":"examples/cpc_runs/","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = True\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/cpc_runs/#run-models","title":"Run models","text":"<pre><code>import time\n\nTIMES_DICT = dict()\nSOL = dict()\nCONFIG = dict()\n\ndef run(input1, **kwargs):\n    jax.clear_caches()\n    label = kwargs.get('label', 'default')\n    t1 = time.time()\n    config =  configuration.Config(input1)\n    sol = feniax.feniax_main.main(input_obj=config)\n    t2 = time.time()\n    TIMES_DICT[label] = t2 - t1      \n    SOL[label] = sol\n    CONFIG[label] = config\n\ndef save_times():\n    pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),\n                            index=TIMES_DICT.keys())\n    pd_times.to_csv(\"./run_times.csv\")\n</code></pre> <ul> <li> <p>Models run on this exercise:</p> <p>Label   Model           NumModes   Solver                        tol/dt       settings</p> <p>SP1     SailPlane       5          Newton-Raphson (Diffrax)      1e-6/         SP2     ...             15         ...                           1e-6/         SP3     ...             30         ...                           1e-6/         SP4     ...             50         ...                           1e-6/         SP5     ...             100        ...                           1e-6/         WSP1    WingSailPlane   5          RK4                           27.34x1e-3    WSP2    ...             15         RK4                           6.62x1e-3     WSP3    ...             30         RK4                           2.49x1e-3     WSP4    ...             50         RK4                           1.27x1e-3     WSP5    ...             100        RK4                           0.575x1e-3    XRF1    XRF1 Airbus     70         RK4                           0.005        1,Index=1   XRF2    ...             70         RK4                           0.005        1,Index=2   XRF3    ...             70         RK4                           0.005        1,Index=3   XRF4    ...             70         RK4                           0.005        1,Index=4   XRF5    ...             70         Dopri5 (Diffrax)              0.005        1,Index=2   XRF6    ...             70         RK4                           0.02         1,Index=2   XRF7    ...             70         Implicit Euler (Diffrax)      1e-5/0.02    1,Index=2   XRF8    ...             70         Implicit Kvaerno3 (Diffrax)   1e-5/0.02    1,Index=2</p> </li> </ul>"},{"location":"examples/cpc_runs/#sailplane","title":"SailPlane","text":""},{"location":"examples/cpc_runs/#runs","title":"Runs","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n</code></pre> <ol> <li> <p>SP1</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 5\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP2</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 15\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP3</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 30\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP4</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 50\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP5</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 100\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> </ol>"},{"location":"examples/cpc_runs/#wingsp","title":"wingSP","text":""},{"location":"examples/cpc_runs/#runs_1","title":"Runs","text":"<pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\n</code></pre> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ndts = [round(1./ eigenvals[i]**0.5, 2) for i in [5,15,30,50,100]]\n</code></pre> <ol> <li> <p>WSP1</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 5\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP2</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 15\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP3</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 30\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4alpha05</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 0.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 0.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4alpha15</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP5</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 100\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> </ol>"},{"location":"examples/cpc_runs/#xrf1","title":"XRF1","text":"<p>WARNING: private model, not available open source</p> <p>Gust lengths and corresponding gust velocities that have been run here and elsewhere. L~g~ 18.0,67.0,116.0,165.0,214 V0~g~ 11.3047276743,14.0732311562,15.4214195361,16.3541764073,17.0785232867</p> <p>Index   Gust length    Gust intensity   Intensity constant   u~inf~    rho~inf~    Mach</p> 1       67                  14.0732311562    0.01                 200              1.225                     0.81   2       67                  14.0732311562    2                    200              1.225                     0.81   3       165.               16.3541764073    0.01                 200              1.225                     0.81   4       165.               16.3541764073    2                    200              1.225                     0.81   5       67                  14.0732311562    0.01                 200              1.225                     0.   6       67                  14.0732311562    2                    200              1.225                     0.   7       165.               16.3541764073    0.01                 200              1.225                     0.   8       165.               16.3541764073    2                    200              1.225                     0. <p>Table with various gusts on the XRF1 that have been run in this work   or in the past {#Table2}</p> <pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\n</code></pre>"},{"location":"examples/cpc_runs/#xrf1_1","title":"XRF1","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*0.01\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf2","title":"XRF2","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073 * 0.01\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.05\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf3","title":"XRF3","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf4","title":"XRF4","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf5","title":"XRF5","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\",#\"Kvaerno3\",\n                                         )\n\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf6","title":"XRF6","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\ninp.systems.sett.s1.tn = 501\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#wrap-up","title":"Wrap up","text":"<pre><code>save_times()\n</code></pre>"},{"location":"examples/ConcurrentLoads/main/","title":"BUG model: concurrent loads and UQ","text":""},{"location":"examples/ConcurrentLoads/main/#load-modules","title":"Load modules","text":""},{"location":"examples/ConcurrentLoads/main/#imports","title":"Imports","text":"<pre><code>import pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = False\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport pickle\nimport jax.numpy as jnp\nimport pandas as pd\nimport numpy as np\nimport feniax.plotools.uplotly as uplotly\nimport feniax.preprocessor.solution as solution\nimport feniax.preprocessor.configuration as configuration\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/ConcurrentLoads/main/#helper-functions","title":"Helper functions","text":"<ol> <li> <p>Common functions</p> <pre><code>scale_quality = 6\nprint(f\"Format for figures: {figfmt}\")\nprint(f\"Image quality: {scale_quality}\")  \ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=scale_quality)\n            return fig, figname\n        return inner\n    return inner_decorator\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       #titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       #titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          font=dict(\n                              family=\"Arial\",\n                              size=18,\n                              color=\"black\"\n                          ),\n                          #showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n\n# fig.update_layout(\n#     xaxis=dict(\n#         title='X AxisTitle',\n#         title_font=dict(family='Arial Black', size=22, color='black'),\n#         tickfont=dict(family='Arial', size=18, color='black')\n#     ),\n#     yaxis=dict(\n#         title='Y Axis Title',\n#         title_font=dict(family='Arial Black', size=22, color='black'),\n#         tickfont=dict(family='Arial', size=18, color='black')\n#     ),\n#     font=dict(\n#         family=\"Arial\",\n#         size=18,\n#         color=\"black\"\n#     ),\n#     legend=dict(\n#         font=dict(size=16),\n#         x=0.02,\n#         y=0.98,\n#         bgcolor='rgba(255,255,255,0)',  # transparent background\n#         bordercolor='black',\n#         borderwidth=1\n#     ),\n#     margin=dict(l=80, r=40, t=40, b=80),\n#     width=700,\n#     height=500\n# )\n</code></pre> </li> <li> <p>Plot functions</p> <pre><code>@fig_background\ndef plot_wingmeanstd(x, y, ystd):\n\n    fig = make_subplots(\n        rows=2, cols=2,\n        specs=[[{}, {\"rowspan\": 2}],  # Row 1: col1 has plot, col2 is Plot C spanning 2 rows\n               [{} , None]],          # Row 2: col1 has plot, col2 empty due to rowspan\n        #subplot_titles=(\"Plot A\", \"Plot C\", \"Plot B\")  # Adjust titles as needed\n    )\n\n    fig1 = (\n        go.Scatter(\n            name=r'$\\mu_u$',\n            x=x,\n            y=y[0],\n            mode='lines',\n            line=dict(color='rgb(31, 119, 180)'),\n        ),\n        go.Scatter(\n            #name=r'$\\pm 1 \\sigma$',\n            x=x,\n            y=y[0]+ystd[0],\n            mode='lines',\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            showlegend=False\n        ),\n        go.Scatter(\n            name=r'$\\pm 1 \\sigma_u$',\n            x=x,\n            y=y[0]-ystd[0],\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            mode='lines',\n            fillcolor='rgba(68, 68, 68, 0.3)',\n            fill='tonexty',\n            #showlegend=False\n        )\n    )\n    fig2 = (\n        go.Scatter(\n            #name=r'$\\mu_u$',\n            x=x,\n            y=y[1],\n            mode='lines',\n            line=dict(color='rgb(31, 119, 180)'),\n            showlegend=False\n        ),\n        go.Scatter(\n            #name=r'$\\pm 1 \\sigma$',\n            x=x,\n            y=y[1]+ystd[1],\n            mode='lines',\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            showlegend=False\n        ),\n        go.Scatter(\n            #name=r'$\\pm 1 \\sigma_u$',\n            x=x,\n            y=y[1]-ystd[1],\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            mode='lines',\n            fillcolor='rgba(68, 68, 68, 0.3)',\n            fill='tonexty',\n            showlegend=False\n        )\n    )\n\n    fig3 = (\n        go.Scatter(\n            #name=r'$\\mu_u$',\n            x=x,\n            y=y[2],\n            mode='lines',\n            line=dict(color='rgb(31, 119, 180)'),\n            showlegend=False\n        ),\n        go.Scatter(\n            #name=r'$\\pm 1 \\sigma$',\n            x=x,\n            y=y[2]+ystd[2],\n            mode='lines',\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            showlegend=False\n        ),\n        go.Scatter(\n            #name=r'$\\pm 1 \\sigma_u$',\n            x=x,\n            y=y[2]-ystd[2],\n            marker=dict(color=\"#444\"),\n            line=dict(width=0),\n            mode='lines',\n            fillcolor='rgba(68, 68, 68, 0.3)',\n            fill='tonexty',\n            showlegend=False\n        )\n    )\n\n    # Plot A (bottom-left)\n    for fi in fig1:\n        fig.add_trace(\n            fi,\n            row=1, col=1\n        )\n\n    # Plot B (bottom-left)\n    for fi in fig2:\n        fig.add_trace(\n            fi,\n            row=2, col=1\n        )\n\n    # Plot C (bottom-left)\n    for fi in fig3:\n        fig.add_trace(\n            fi,\n            row=1, col=2\n        )\n    #fig.update_xaxes(title_text=\"Wing span\", row=1, col=1)\n    fig.update_yaxes(title_text=r\"$ \\large u_x \\; [m]$\", row=1, col=1)\n    fig.update_xaxes(title_text=\"Wing span\", row=2, col=1)\n    fig.update_yaxes(title_text=\"$ \\large u_y \\; [m]$\", row=2, col=1)\n    fig.update_xaxes(title_text=\"Wing span\", row=1, col=2)\n    fig.update_yaxes(title_text=\"$ \\large u_z \\; [m]$\", row=1, col=2)\n\n    fig.update_layout(\n        legend=dict(x=0.8, y=0.95),\n        # xaxis_title=\"Wing span [m]\",\n        # yaxis_title='Wing vertical displacement [m]',\n        showlegend=True)\n\n    return fig\n\n@fig_background\ndef plot_jacpdiff(x, yobj, yjac):\n\n    fig = None\n    fig = uplotly.lines2d(x, yobj, fig,\n                          dict(name=\"Objective\",\n                               line=dict(color=\"black\"),\n                               marker=dict(symbol=\"circle\")\n                               ),\n                          dict())\n    fig = uplotly.lines2d(x, yjac, fig,\n                          dict(name=\"Jacobian\",\n                               line=dict(color=\"blue\"),\n                               marker=dict(symbol=\"square\")\n                               ),\n                          dict())\n\n    powersx = [1, 2, 3]\n    powersy = [-3, -2, -1]\n    tickvalsx = [10 ** p for p in powersx]\n    tickvalsy = [10 ** p for p in powersy]\n\n    fig.update_xaxes(type=\"log\",\n                     #tickformat= '.0e',\n                     #showexponent = 'first',\n                     #tickvals=tickvalsx,\n                     #ticktext=[f\"10^{p}\" for p in powersx],\n                     exponentformat = 'power'\n                     )\n    fig.update_yaxes(type=\"log\",\n                     #tickformat= '.0e'\n                     #tickvals=tickvalsy,\n                     #showgrid=True,         # Keep all grid lines\n                     #minor=dict(\n                     #    showgrid=True      # THIS enables minor grid lines\n                     #),\n                     #ticktext=[f\"10^{p}\" for p in powersy],                      \n                     exponentformat = 'power'\n                     )\n    fig.update_layout(\n        legend=dict(x=0.7, y=0.95),\n        xaxis_title=\"Number of paths\",\n        yaxis_title='Relative Error',\n        showlegend=True)\n\n    return fig\n\n@fig_background\ndef plot_jacediff(x, yjac):\n\n    fig = None\n    fig = uplotly.lines2d(x, yjac, fig,\n                          dict(#name=\"Jacobian\",\n                               line=dict(color=\"blue\"),\n                               marker=dict(symbol=\"square\")\n                               ),\n                          dict())\n\n    fig.update_xaxes(type=\"log\",\n                     #tickformat= '.0e'\n                     exponentformat = 'power'\n                     )\n    fig.update_yaxes(type=\"log\",\n                     #tickformat= '.0e'\n                     exponentformat = 'power'\n                     )\n    fig.update_layout(xaxis_title=r'$\\text{Finite-Differences } \\Large \\epsilon$',\n                      yaxis_title=\"Relative Error\")\n    #fig.update_layout(xaxis_type=\"log\", yaxis_type=\"log\")\n    return fig\n\n\ndef plot_jacpdiff2(name, x, yobj, yjac, figformat=figfmt):\n\n    # Create figure and axes\n    fig, ax = plt.subplots(figsize=(4.5, 4.5))  # width=8 inches, height=6 inches\n\n    # Plot the data\n    ax.plot(x, yobj,\n            label='Objective',\n            marker='o',          # Circle markers\n            color='black')\n    ax.plot(x, yjac,\n            label='Jacobian',\n                marker='s', \n            color='blue')\n\n    # Set logarithmic scale\n    ax.set_xscale('log')  # Set x-axis to log scale\n    ax.set_yscale('log')  # Optional, y-axis remains linear\n    ax.tick_params(axis='both', which='major', labelsize=12)      \n    # Add labels and title\n    ax.set_xlabel('Number of paths', fontsize=12)\n    ax.set_ylabel(\"Relative error\", fontsize=12)\n\n    # Add grid and legend\n    ax.grid(True, which='both', linestyle='-', linewidth=0.5)\n    ax.legend(fontsize=12)\n    # Automatically adjust layout to prevent clipping\n    plt.tight_layout()\n\n    figname = f\"figs/{name}.{figformat}\"\n    plt.savefig(f\"../{figname}\", dpi=300)  \n\n    return ax, figname\n\ndef plot_jacediff2(name, x, yjac, figformat=figfmt):\n\n    # Create figure and axes\n    fig, ax = plt.subplots(figsize=(4.5, 4.5))  # width=8 inches, height=6 inches\n\n    # Plot the data\n    ax.plot(x, yjac,\n            marker='o',          # Circle markers              \n            #label='y = log10(x)',\n            color='blue')\n\n    # Set logarithmic scale\n    ax.set_xscale('log')  # Set x-axis to log scale\n    ax.set_yscale('log')  # Optional, y-axis remains linear\n    ax.tick_params(axis='both', which='major', labelsize=12)\n    # Add labels and title\n    ax.set_xlabel(r'$\\text{Finite-Differences } \\epsilon$', fontsize=12)\n    ax.set_ylabel(\"Relative Error\", fontsize=12)\n\n    # Add grid and legend\n    ax.grid(True, which='both', linestyle='-', linewidth=0.5)\n    #ax.legend()\n    # Automatically adjust layout to prevent clipping\n    plt.tight_layout()\n\n    figname = f\"figs/{name}.{figformat}\"\n\n    # Save plot to file\n    plt.savefig(f\"../{figname}\", dpi=300)  \n\n    return ax, figname\n\n@fig_background\ndef plot_jacfemold(jac, xindex, yindex, xlabel=\"\", ylabel=\"\"):\n\n    fig = go.Figure(data=go.Heatmap(\n        z=jac[xindex[:,None], yindex], colorscale = 'hot'))\n    xaxis = dict(\n      tickmode = 'array',\n      tickvals = jnp.arange(len(xindex)),\n      ticktext = xindex\n    )\n    yaxis = dict(\n      tickmode = 'array',\n      tickvals = jnp.arange(len(yindex)),\n      ticktext = yindex\n    )\n\n    fig.update_layout(xaxis=xaxis,\n                      yaxis=yaxis,\n                      xaxis_title=xlabel,\n                      yaxis_title=ylabel)\n    #fig.update_layout(xaxis_type=\"log\", yaxis_type=\"log\")\n    return fig\n\n@fig_background\ndef plot_jacfem(jac, jac2=None, xlabel=\"i\", ylabel=\"j\", zlabel=\"\"):\n\n    # fig = go.Figure(data=go.Heatmap(\n    #     z=jac, colorscale = 'hot'))\n\n    fig = go.Figure(data=[\n        go.Surface(z=jac, colorscale='reds'),\n        #go.Surface(z=jac2, showscale=False, opacity=0.9, colorscale='reds'),\n        #go.Surface(z=jac-1, showscale=False, opacity=0.9)\n\n    ])      \n    fig.update_layout(xaxis_title=xlabel,\n                      yaxis_title=ylabel,\n                      #zaxis_title=\"dd\"\n                      scene = dict(\n                          xaxis_title=xlabel,\n                          yaxis_title=ylabel,\n                          zaxis_title=zlabel,\n                          xaxis = dict(\n                              backgroundcolor=\"rgba(0, 0, 0,0)\",\n                              gridcolor=\"black\",\n                              showbackground=True,\n                              zerolinecolor=\"black\",),\n                          yaxis = dict(\n                              backgroundcolor=\"rgba(0, 0, 0,0)\",\n                              gridcolor=\"black\",\n                              showbackground=True,\n                              zerolinecolor=\"black\"),\n                          zaxis = dict(\n                              backgroundcolor=\"rgba(0, 0, 0,0)\",\n                              gridcolor=\"black\",\n                              showbackground=True,\n                              zerolinecolor=\"black\",),\n                      ),\n                      )\n    #fig.update_layout(xaxis_type=\"log\", yaxis_type=\"log\")\n    return fig\n\n@fig_background\ndef plot_manoeuvretip(aoa, ua, ua_lin):\n    fig=None\n    colors = [\"steelblue\", \"black\"]\n    dashes = [\"solid\", \"dash\"]\n    fig = uplotly.lines2d(aoa, ua, fig,\n    dict(name=f\"Nonlinear\",\n    line=dict(color=colors[0],\n    dash=dashes[0])\n    ))\n    fig = uplotly.lines2d(aoa, ua_lin, fig,\n    dict(name=f\"Linear\",\n    line=dict(color=colors[1],\n    dash=dashes[1])\n    ))\n\n    fig.update_yaxes(title=r'$\\large \\hat{u}_z [\\%]$')\n    fig.update_xaxes(#range=aoa,\n    title=r'$AoA [^o]$')\n    return fig\n\n@fig_background\ndef plot_gustshard(x, y, z, component):\n\n    fig = go.Figure(data =\n                    go.Contour(\n                        z= z[:,:, component],\n                        x=x, # horizontal axis\n                        y=y, # vertical axis\n                        colorscale='Blues',\n                        colorbar=dict(\n                            tickfont=dict(size=20)\n                        )  # Set tick font size\n                    )\n                    )\n    fig.update_yaxes(title=\"Gust length [m]\")\n    fig.update_xaxes(title=\"Gust intensity [m/s]\")\n    return fig\n\n@fig_background\ndef plot_jacfem2(z, xlabel=None, ylabel=None):\n\n    fig = go.Figure(data =\n                    go.Contour(\n                        z= z,\n                        #x=x, # horizontal axis\n                        #y=y, # vertical axis\n                        colorscale='blues',\n                        colorbar=dict(\n                            tickfont=dict(size=20)\n                        )  # Set tick font size\n                    )\n                    )\n    fig.update_yaxes(title=ylabel)\n    fig.update_xaxes(title=xlabel)\n    return fig\n</code></pre> </li> </ol>"},{"location":"examples/ConcurrentLoads/main/#models","title":"Models","text":"<p>For a complete walk-through of model and creation see the file modelgeneration.org</p>"},{"location":"examples/ConcurrentLoads/main/#montecarlo-uq","title":"Montecarlo UQ","text":"<ul> <li>Discrete loading field along wings with uncertainty component     (Gaussian)</li> <li>Python file: settings~DiscreteMC1high~.py,     settings~DiscreteMC1MCsmall~.py, settings~DiscreteMC1vsmall~.py</li> <li>Results presented in Sec.     1.3.1</li> </ul>"},{"location":"examples/ConcurrentLoads/main/#derivative-of-expectations","title":"Derivative of expectations","text":"<ul> <li>Compute derivatives of the expectations previously computed     concurrently via Montecarlo simulations.</li> <li>Python file: settings~ADDiscreteMC1t~.py,     settings~ADDiscreteMC1tfdjac~.py, settings~ADDiscreteMC1fem~.py</li> <li>Results presented in Sec.     1.3.2</li> <li>Corresponding test:     ../../../tests/intrinsic/montecarlo/test_BUGUQ.py</li> </ul>"},{"location":"examples/ConcurrentLoads/main/#manoeuvre","title":"Manoeuvre","text":"<ul> <li>Manoeuvre case with clamped AC varying u~inf~ and rho~inf~</li> <li>Testing and benchmarking parallelisation</li> <li>Python file: settings~manoeuvre1shard~.py for computations</li> <li>Results presented in Sec. 1.3.3</li> <li>Corresponding test:     ../../../tests/intrinsic/aeroelastic_static/test_BUGmanoeuvre.py</li> </ul>"},{"location":"examples/ConcurrentLoads/main/#dynamic-load-envelopes","title":"Dynamic-load envelopes","text":"<ul> <li>Construct gusts of different lengths, intensity and airflow density</li> <li>Python file: python settings~gust1shard~.py for plotting (11x11=121     gust) settings~gust1shardbench~.py for benchmark (8x8x8=256 gust)</li> <li>Results presented in Sec. 1.3.4</li> <li>Corresponding test:     ../../../tests/intrinsic/aeroelastic_dynamic/test_BUGgustShard.py</li> </ul>"},{"location":"examples/ConcurrentLoads/main/#gust-ad-forager","title":"Gust AD forager","text":"<ul> <li>Run gusts in parallel and find the worst cases</li> <li>Checking AD of free-flying AC for worst case determined by forager</li> <li>Python file: settings~gustforager~.py</li> <li>Results presented in Sec. 1.3.4.1</li> <li>Corresponding test:     ../../../tests/intrinsic/aeroelastic_dynamic/test_BUGforager.py</li> </ul>"},{"location":"examples/ConcurrentLoads/main/#run","title":"Run","text":"<pre><code>#!/usr/bin/env bash\n\nManoeuvre=\"tru\"\nMontecarlo=\"tru\"\nMontecarloADt=\"true\"\nMontecarloADtjac=\"true\"\nMontecarloADtfd=\"tru\"    \nMontecarloADfem=\"tru\"\nGust=\"tru\"\nGustBench=\"tru\"\nForager=\"tru\"\n\npyenv activate feniax\npathBUG=\"../../../../FENIAXexamples/BUG/\"\ncurrent_dir=$(pwd)\ncd $pathBUG\n\nif [ \"$Manoeuvre\" = \"true\" ]; then\n    echo \"RUNNING MANOEUVRE\"\n    python settings_manoeuvre1shard.py $current_dir\nfi\n\nif [ \"$Montecarlo\" = \"true\" ]; then\n    echo \"RUNNING MONTECARLO\"\n    python settings_DiscreteMC1high.py $current_dir\n    python settings_DiscreteMC1small.py $current_dir\n    python settings_DiscreteMC1vsmall.py $current_dir\nfi\n\nif [ \"$MontecarloADt\" = \"true\" ]; then\n    echo \"RUNNING MONTECARLOADT\"\n    # python settings_ADDiscreteLoadsMC_validation.py $current_dir\n    python settings_ADDiscreteMC1_t.py $current_dir\nfi\n\nif [ \"$MontecarloADtjac\" = \"true\" ]; then\n    echo \"RUNNING MONTECARLOADTJAC\"\n    # python settings_ADDiscreteLoadsMC_validation.py $current_dir\n    python settings_ADDiscreteMC1_t_fdjac.py $current_dir\nfi\n\nif [ \"$MontecarloADtfd\" = \"true\" ]; then\n    echo \"RUNNING MONTECARLOADTFD\"\n    # python settings_ADDiscreteLoadsMC_validation.py $current_dir\n    python settings_ADDiscreteMC1_t_fd.py $current_dir\nfi\n\nif [ \"$MontecarloADfem\" = \"true\" ]; then\n    echo \"RUNNING MONTECARLOADFEM\"\n    python settings_ADDiscreteMC1_fem.py $current_dir\n    #python settings_ADDiscreteLoadsMC.py $current_dir\nfi\n\nif [ \"$Gust\" = \"true\" ]; then\n    echo \"RUNNING GUST\"\n    python settings_gust1shard.py $current_dir\nfi\n\nif [ \"$GustBench\" = \"true\" ]; then\n    echo \"RUNNING GUST BENCHMARK\"\n    python settings_gust1shardbench.py $current_dir\nfi  \n\nif [ \"$Forager\" = \"true\" ]; then\n    echo \"RUNNING FORAGER\"\n    python settings_gustforager.py $current_dir\nfi\n</code></pre>"},{"location":"examples/ConcurrentLoads/main/#results","title":"Results","text":"<p>In this section we show the main strengths of our solvers. We run a representative aircraft model undergoing very large nonlinear displacements, the University of Bristol Ultra-Green (BUG) aircraft model cite:&amp;STODIECK2018 is the chosen platform as it is not based on proprietary data and it showcases high-aspect ratio wings and a GFEM based on beam and shell elements in MSC Nastran. The main components of the aeroelastic model have been presented in cite:&amp;CEA2025a. Leveraging on modern hardware architectures and a parallelisation across devices, to unlock problems such as quantifying the uncertainties in the nonlinear response given a non-deterministic loading field. We build load envelopes of static and dynamic aeroelastic simulations and differentiate across the concurrent simulations to obtain sensitivities of dynamic loads as well as moment statistics. Structural and aeroelastic static simulations follow, solved via a Newton-Raphson solver with tolerance of $10^{-6}$, as well as an assessment of the aircraft dynamics in response to various gust profiles. A high modal resolution of 100 modes is employed in all the results, more than what is necessary for most of the examples. Calculations are carried out on a CPU Intel Xeon Silver 4108 with 1.80GHz speed, 6 cores and a total 12 threads, as well as on an Nvidia GPU A100 80GB SXM.</p>"},{"location":"examples/ConcurrentLoads/main/#uncertainty-quantification-in-nonlinear-simulations","title":"Uncertainty quantification in nonlinear simulations","text":"<pre><code># using jac_ediff2 that was computed in memory instead of loading the result which seems to loose accuracy\nREAD_CONFIG = False\nif 'config_mc1' not in globals():\n    config_mc1 = configuration.Config.from_file(\"./DiscreteMC1high/config.yaml\")\nsol_mc1high = solution.IntrinsicReader(\"./DiscreteMC1high\")\nsol_mc1small = solution.IntrinsicReader(\"./DiscreteMC1small\")\nsol_mc1vsmall = solution.IntrinsicReader(\"./DiscreteMC1vsmall\")\nwing_nodes = list(range(10, 36))\nwing_span = config_mc1.fem.X[wing_nodes[0]:wing_nodes[-1], 1]\ncomponents = [0, 1, 2]\nUtipmean = []\nUtipsmallmean = []\nUtipvsmallmean = []\nUtipstd = []\nUtipsmallstd = []\nUtipvsmallstd = []\nUmean_wing = []\nUstd_wing = []\n\nfor component in components:\n    u_tipmean = np.mean(sol_mc1high.data.staticsystem_s1.ra[:,-1,component,35] - config_mc1.fem.X[35,component])\n    u_tipstd = np.std(sol_mc1high.data.staticsystem_s1.ra[:,-1,component,35])\n    u_tipsmallmean = np.mean(sol_mc1small.data.staticsystem_s1.ra[:,-1,component,35] - config_mc1.fem.X[35,component])\n    u_tipsmallstd = np.std(sol_mc1small.data.staticsystem_s1.ra[:,-1,component,35])\n    u_tipvsmallmean = np.mean(sol_mc1vsmall.data.staticsystem_s1.ra[:,-1,component,35] - config_mc1.fem.X[35,component])\n    u_tipvsmallstd = np.std(sol_mc1vsmall.data.staticsystem_s1.ra[:,-1,component,35])\n    Utipmean.append(u_tipmean)\n    Utipsmallmean.append(u_tipsmallmean)\n    Utipvsmallmean.append(u_tipvsmallmean)    \n    Utipstd.append(u_tipstd)\n    Utipsmallstd.append(u_tipsmallstd)\n    Utipvsmallstd.append(u_tipvsmallstd)\n\n    umean_wing = []\n    ustd_wing = []\n    for ni in wing_nodes:\n        umean_wing.append(np.mean(sol_mc1high.data.staticsystem_s1.ra[:,-1, component, ni] -\n                          config_mc1.fem.X[ni,component]))\n        ustd_wing.append(np.std(sol_mc1high.data.staticsystem_s1.ra[:,-1, component, ni] -\n                          config_mc1.fem.X[ni,component]))\n    umean_wing = np.array(umean_wing)\n    ustd_wing = np.array(ustd_wing)\n    Umean_wing.append(umean_wing)\n    Ustd_wing.append(ustd_wing)\n</code></pre> <p>In this section uncertainty quantification is performed for both linear and nonlinear responses to a loading field that is non-deterministic. Thousands of simulations are employed in Monte Carlo type of analysis to resolve for the statistics, for which parallelisation of the independent simulations become critical. The example resembles the workflow of flight loads and wing stress analysis in an industrial setup. There will always be an element of uncertainty around computed loads, and what we show here is how for large displacements, the statistics need to be computed for every distinct loading. And for this, having a parallisation strategy as the one presented could potentially allow the computation of complex correlations and averages via Montecarlo analysis. Considering this, a static loading field is prescribed along the wings consisting of follower forces in the normal (out-of-plane) direction, as well as torsional moments (to mimic the added aerodynamic forces on an airfoil), with the characteristic that the force follows a normal distribution:</p> <p><pre><code>\\begin{subequations}\n\n$$\\begin{align}\\label{eq:normal_loading}\nN&amp;(\\mu=1.5 \\times 10^4 \\mu_0, \\sigma=0.15 \\mu) \\; \\text{[forces]}  \\\\\nN&amp;(\\mu=3 \\times 10^4 \\mu_0, \\sigma=0.15 \\mu)   \\; \\text{[moments]}\n\\end{align}$$\n\\end{subequations}\n</code></pre> Three scenarios are studied: one in which very large nonlinear deformations are induced with $\\mu_0 = 1$, and two small loading with $\\mu_0 = 10^{-2}$ and $\\mu_0 = 10^{-3}$. The distribution of displacements is characterised by means of Montecarlo simulations that run in parallel for a total of 1600 simulations. Fig. 1 shows the equilibrium at high loading ($\\mu_0 = 1$) for two of the random cases (first and last of the 1600 computed).</p> <p></p> <p>Table 1 shows the normalized statistics gathered from the response, in this case the expectation of tip of the wing displacements in the normal (out-of-plane) direction, $\\mu_u $, and the corresponding standard deviation, $ \\sigma_u  $.</p> Case $\\mu_u / \\mu_0 $ $ \\sigma_u / \\mu_0 $ ($\\mu_0 = 1$) 11.57 1.35 ($\\mu_0 = 0.01$) 14.8 2.4 ($\\mu_0 = 0.001$) 14.9 2.3 <p>We can see the statistics of the linear response ($\\mu_0 = 0.001$) are fully captured by one single Montecarlo analysis, that is, output magnitudes such as equilibrium displacements correlate with the average input load. Whereas in cases with nonlinear deformations ($\\mu_0 = 1$), the whole Montecarlo analysis would need to be carried out. This is akin to deterministic linear versus nonlinear analysis. Expanding this data at the tip to the entire right wing, Fig. 2 shows the mean normal displacement along the wing, $\\mu_u$, and its standard deviation, $\\sigma_u$. Note how despite the standard deviation of the input forces is the same along the wing, the uncertainty in the displacement output grows towards the tip as expected \u2013the aircraft being clamped at the root will only showcase 0 displacements there regardless of the input forces.</p> <pre><code>fig, figname = fig_out(name)(plot_wingmeanstd)(wing_span, Umean_wing, Ustd_wing)\nfigname\n</code></pre> <p></p> <p>Table 2 shows the times taken for the nonlinear case in both CPU and GPU. The computation of 1600 independent simulations in just over a minute, involving deformations of over 40% the wing semi-span as shown in Fig. 1, highlights the potential of this methodology in more complex uncertainty quantification problems. Note that at this level of nonlinearity, our solvers are already two orders of magnitude faster than commercial solvers such as MSC Nastran even for a single simulation as demonstrated in cite:&amp;CEA2025. The extension to thousands of cases with parallelisation on modern architectures is a key feature of this work with far-reaching applications in aircraft loads analysis.</p> Device Time  CPU (single) 16.8 \u00d7 1600 = 26880 CPU (parallel) 317.4 GPU 67.6"},{"location":"examples/ConcurrentLoads/main/#computing-derivatives-of-expectations","title":"Computing derivatives of expectations","text":"<pre><code># using jac_ediff2 that was computed in memory instead of loading the result which seems to loose accuracy\nsol_admc1_t = solution.IntrinsicReader(\"./ADDiscreteMC1_t\")\nsol_admc1_fem = solution.IntrinsicReader(\"./ADDiscreteMC1_fem\")\njac_t = sol_admc1_t.data.staticsystem_s1.jac['t']\nobj_t = sol_admc1_t.data.staticsystem_s1.objective\njac_fem = sol_admc1_fem.data.staticsystem_s1.jac\nsemispan = 25.9 # for normalisation\nmass = 55615.12  # Kg, see BUG modelgeneration.org\nnormalisation = mass / 2 * 9.81   \nmc1_jacpaths = [8, 80, 4e2, 8e2, 4e3] #[8, 80, 4e2, 8e2, 4e3, 8e3, 2e4]\nmc1_eps = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5]\nsol_admc1_e = dict()\nsol_admc1_j = dict()\nmc1_jac = list()\nmc1_jobj = list()\nmc1_eobj = list()  \nmc1_ejac = list()\njac_pdiff = list()\nobj_pdiff = list()  \njac_ediff = list()\njac_ediff2 = list()\nmc1_ejac2 = jnp.load(\"./ADDiscreteMC1_te/jac_e.npy\")\n\nfor i, _ in enumerate(mc1_jacpaths):\n    sol_admc1_j[i] = solution.IntrinsicReader(f\"./ADDiscreteMC1_tjac{i}\")\n    mc1_jobj.append(sol_admc1_j[i].data.staticsystem_s1.objective)\n    mc1_jac.append(sol_admc1_j[i].data.staticsystem_s1.jac['t'])\nfor i, _ in enumerate(mc1_jacpaths): # needing to read all to take last one\n    obj_pdiff.append(jnp.linalg.norm(mc1_jobj[i] - mc1_jobj[-1]) /\n                     jnp.linalg.norm(mc1_jobj[-1]))\n    jac_pdiff.append(jnp.linalg.norm(mc1_jac[i]-mc1_jac[-1]) /\n                     jnp.linalg.norm(mc1_jac[-1]))\n\nfor i, ei in enumerate(mc1_eps):\n    sol_admc1_e[i] = solution.IntrinsicReader(f\"./ADDiscreteMC1_te{i}\")\n    mc1_eobj.append(sol_admc1_e[i].data.staticsystem_s1.objective)\n    mc1_ejac.append((mc1_eobj[i] - obj_t) / ei)\n    jac_ediff.append(jnp.linalg.norm(mc1_ejac[i]-jac_t) / jnp.linalg.norm(jac_t))\n    jac_ediff2.append(jnp.linalg.norm(mc1_ejac2[i]-jac_t) / jnp.linalg.norm(jac_t))\n</code></pre> <p>Now we set out to calculate the derivatives of the expectations previously computed concurrently in Sec. . While the Montecarlo paths are independent of each other and could therefore be run on different machines, having to do AD on the output statistics -gathered via collective operations-, forces the entire chain of operations to be within a single program. This makes for an interesting and challenging problem to propagate gradients through concurrent operations. A linear parameter $\\alpha$ is introduced such that the follower forces and torsional moments in Eq. <code>\\eqref{eq:normal_loading}</code> are $\\mu = 10^4 (\\frac{\\alpha - 1.5}{4-1.5} + 1.5\\times\\frac{\\alpha - 1}{5-1}) $. The selected output is the expectation of a 3-component vector, $\\bm{r}(\\alpha)$ of the wing-tip positions at $\\alpha = 4.5$. Fig. 3 shows a comparison between the derivative $\\partial_{\\alpha} \\bm{r}^a = \\partial \\mathbb{E}[\\bm{r}] / \\partial \\alpha $ using AD, and finite differences $ \\partial_{\\alpha} \\bm{r}^{f}= (\\bm{r}(\\alpha + \\epsilon) - \\bm{r}(\\alpha))/\\epsilon  $. The relative error is calculated as $||\\partial_{\\alpha} \\bm{r}^{a} - \\partial_{\\alpha} \\bm{r}^{f} || / ||\\partial_{\\alpha} \\bm{r}^{a} ||  $, using the $l_2 $ norm.</p> <pre><code>fig, figname = fig_out(name)(plot_jacediff)(mc1_eps, jac_ediff)\nfigname\n</code></pre> <pre><code>fig, figname = plot_jacediff2(name, mc1_eps, mc1_ejac2)\nfigname\n</code></pre> <p></p> <p>Another convergence metric to investigate is the number of paths in the Montecarlo analysis. We take $[8, 80, 400, 800]$ paths and using the same error metric as for the finite differences calculate its evolution taking 4000 paths as the reference. The plot in 4 shows that the convergence of the value function (expectation of the wing tip position) is faster than its derivative with respect to the loading parameter $\\alpha $. This may or not be an issue in optimization studies with expectations as sometimes high accuracy in the gradients is not that important as having a good direction.</p> <pre><code>fig, figname = fig_out(name)(plot_jacpdiff)(mc1_jacpaths[:-1], obj_pdiff[:-1], jac_pdiff[:-1])\nfigname\n</code></pre> <pre><code>fig, figname = plot_jacpdiff2(name, mc1_jacpaths[:-1], obj_pdiff[:-1], jac_pdiff[:-1])\nfigname\n</code></pre> <p></p> <p>While changing the input loading is good for verification studies, more realistic examples are solved in Fig. 5 where the sensitivity of the expectations of wing root loads are calculated with respect to the FE matrices and eigenvectors (only indexes corresponding to the right wing nodes are shown in the heat map as the other are 0 because the model is clamped). The derivatives in Fig. 4 were calculated in forward mode, but the condensed FE matrices of the BUG model contain 99 condensed nodes, each with 6 components, so $(99 \\times 6)^2 = 352836 $ entries, to what all the components in eigenvectors are also added, therefore only backward mode AD is possible in this case. The sensitivity of the loads with respect to the mass matrix increase towards the nodes at tip of the wing, which makes sense if we think a unit mass at the tip will produce much larger loads than the same unit mass close to the root where the aircraft is clamped. The wall-time to calculate the gradient of wing-root loads expectations with respect to the mass matrix using 800 paths in the Montecarlo analysis was 48.0 and 297.9 in the GPU and CPU respectively.</p> <pre><code>m_start = 6*12\nm_end = m_start + 6*23#6*35 #m_start + 136 # 6*35\nf_index = 2\nn_index = 4\njump = 6\nshift = 4\nMa_plot = jac_fem['Ma'][0,f_index,0]\nxindex = jnp.arange(m_start+n_index-shift, m_end+n_index-shift, jump)\nyindex = jnp.arange(m_start+n_index, m_end+n_index, jump)\nfig, figname = fig_out(name)(plot_jacfemold)( Ma_plot /normalisation,\n                                              xindex,\n                                              yindex,\n                                              xlabel=\"i-components\",\n                                              ylabel=\"j-components\"\n                                             )\nfigname\n</code></pre> <p></p> <pre><code>m_start = 6*12\nm_end = m_start + 6*23#6*35 #m_start + 136 # 6*35\nf_index = 2\nn_index = 2\njump = 6\nshift = 6\nMa_plot = jac_fem['Ma'][0,f_index,0]\nxindex = jnp.arange(m_start+n_index-shift, m_end+n_index-shift, jump)\nyindex = jnp.arange(m_start+n_index, m_end+n_index, jump)\nfig, figname = fig_out(name)(plot_jacfemold)( Ma_plot /normalisation,\n                                              xindex,\n                                              yindex,\n                                              xlabel=\"i-components\",\n                                              ylabel=\"j-components\"\n                                             )\nfigname\n</code></pre> <p></p>"},{"location":"examples/ConcurrentLoads/main/#steady-manoeuvre-loads","title":"Steady manoeuvre loads","text":"<pre><code>sol_manoeuvre = solution.IntrinsicReader(\"./manoeuvre1Shard\")\nconfig_manoeuvre = configuration.Config.from_file(\"./manoeuvre1Shard/config.yaml\")\nt = [1/6*1e-2, 1/6, 1/3, 1/2, 2/3, 5/6, 1]\naoa = [6*ti for ti in t]\nra = sol_manoeuvre.data.staticsystem_s1.ra[-1]\ncomponent = 2\nnode = 35\nra_tip0 = config_manoeuvre.fem.X[node]\nra_tip = ra[:, :, node]\nua = ra_tip - ra_tip0\nsemispan = ra_tip0[1] \nuatip = ua[:, component] / semispan * 100\nuatip_lin = [uatip[0]/t[0]*ti for ti in t]\n</code></pre> <p>We extend the previous analysis to a static aeroelastic case for varying angles of attack that represent a manoeuvre scenario. We test the parallelisation by varying the flow density ($\\pm 20 \\%$ of the reference density 0.41 Kg/ m$^3$) as well and the flow velocity ($\\pm 20 \\%$ of the reference velocity 209.6 m/s). 16 different points for both density and velocity make a total number of 256 simulations. The Mach number is fixed at 0.7 corresponding to the reference flow condition values. Fig. fig:BUG_manoeuvre3D illustrates the 3D equilibrium of the airframe at the reference flight conditions.</p> <p>file:figs_ext/monoeuvre3D.pdf</p> <p>In Fig. 7 the tip of the wing in Fig. fig:BUG_manoeuvre3D is plotted for various angles-of-attach (AoA), normalized with the wing semi-span ($b= 25.9$) m. Comparison against linear analysis is carried out and the tip position in the nonlinear analysis falls down the linear counter part as expected. The flow velocities and density are selected at the maximum of the load envelope at 251.6 m/s and 0.5 kg/m$^3$ respectively. This highlights the potential need for geometrically nonlinear aeroelastic tools in future aircraft configurations under high loading scenarios.</p> <pre><code>fig, figname = fig_out(name)(plot_manoeuvretip)(aoa, uatip, uatip_lin)\nfigname\n</code></pre> <p></p> <p>Table 3 shows the computational times to run these simulations, which shows near no overhead in adding a few hundred of static calculations when moving from the single load case in the CPU to the GPU (nearly 8 seconds to 14 seconds, which amounts for 6 seconds cost when adding an extra 255 cases).</p> Device Time  CPU (single) 7.71 \u00d7 256 = 1973.8 CPU (parallel) 52.8 GPU 14.4"},{"location":"examples/ConcurrentLoads/main/#dynamic-loads-at-large-scale","title":"Dynamic loads at large scale","text":"<pre><code>sol_gust1shard = solution.IntrinsicReader(\"./gust1_eaoShard\")\nnode = 13\npoints = sol_gust1shard.data.shards_s1.points\ngust_wn = 11 # 11 intensity points\ngust_w = points[:gust_wn,3]\ngust_l = points[::gust_wn,2]\ngust_ln = 11  # 11 gust lenght points\nmass = 55615.12  # Kg, see BUG modelgeneration.org\nsemispan = 25.9\nnormalisation_force = mass / 2 * 9.81\nnormalisation_moment = normalisation_force * semispan\nx2max = jnp.max(jnp.abs(sol_gust1shard.data.dynamicsystem_s1.X2[:,:, :, node]), axis=1) # points,6\n#x2min = jnp.min(sol_gust1shard.data.dynamicsystem_s1.X2[:,:, :, node], axis=1)\nx2max_mesh = x2max.reshape((gust_ln, gust_wn,6)) # contour: wn is x, ln is y\n#x2min_mesh = x2min.reshape((gust_ln, gust_wn,6))\n</code></pre> <p>In this final example we perform a dynamic aeroelastic analysis to study the response of the aircraft to multiple 1-cos gusts for varying length, intensity and the density of the airflow. The mach number is kept constant at 0.7. In the examples above the aircraft was clamped while the aircraft is free here. A Runge-Kutta solver is employed to march in time the equations with a time step of $10^{-3}$ s and the total number of modes used was 100. Note the large size of the aeroelastic ODE system: 2 \u00d7 100 nonlinear equations plus 5 \u00d7 100 linear equations for the aerodynamic states with 5 poles, plus 4 equations for the quaternion tracking the rigid-body motion, for a combined ODE system of 704 equations. In addition, a total of 512 gusts cases are run concurrently for all possible combinations of 8 gust lengths between 50 and 200 meters, 8 gust intensities between 5 and 25 m/s, and 8 airflow densities between 0.34 and 0.48 Kg/m$^3$. This means that $512 \\times 704 = 360448$ equations are being marched in time, in this case for 2 seconds which is enough to capture peak loads. We have verified the concurrent implementation by satisfactory comparing single-point simulations to the same points within the parallel results. Table 4 contains the simulation times of the calculation, which shows one order of magnitude increase in performance when running in parallel in the CPU versus a complete single simulation running sequentially, and another order of magnitude when moving from the CPU to a modern GPU. This exemplifies the power of modern hardware for scientific computation.</p> Device Time  CPU (single) 27.8 \u00d7 512 = 14233.6 CPU (parallel) 922.6 GPU 38.2 <p>In Fig. 8 the 3D reconstructed flight shape of the airframe is depicted for a gust of 150 m length, intensity of 20 m/s and flow density of 0.41 Kg/m$^3$</p> <p></p> <p>Figs. 9, 10 and 11 show the load diagrams for the maximum shear, torsion and out-of-pane bending at the wing root during the gust encounter, normalized with the aircraft weight and wing semi-span. They reflect the importance of running multiple of these simulations to assess the critical loads: maximum loads occur at different gust lengths of 65, 75, 115 m/s. This analysis would be extended to include various mass cases, flying altitudes etc. in an industrial environment, and it would be straight forward to extend our tools for this.</p> <pre><code>fig, figname = fig_out(name)(plot_gustshard)(gust_w, gust_l, x2max_mesh / normalisation_force,\n                                             component=2)\nfigname\n</code></pre> <p></p> <pre><code>fig, figname = fig_out(name)(plot_gustshard)(gust_w, gust_l, x2max_mesh / normalisation_moment,\n                                             component=3)\nfigname\n</code></pre> <p></p> <pre><code>fig, figname = fig_out(name)(plot_gustshard)(gust_w, gust_l, x2max_mesh / normalisation_moment,\n                                             component=4)\nfigname\n</code></pre> <p></p> <ol> <li> <p>Load envelope differentiation</p> <pre><code>import feniax.intrinsic.objectives as objectives\nsol_gust1forager = solution.IntrinsicReader(\"./gustforager\")\nload_jacs = True\n\nif load_jacs:\n    jac_rho = jnp.load(\"./gustforager_epsilonrho/jac_rho.npy\")\n    jac_length = jnp.load(\"./gustforager_epsilonlength/jac_length.npy\")\n    jac_intensity = jnp.load(\"./gustforager_epsilonintensity/jac_intensity.npy\")\nelse:\n    # this is not working proprerly with FD, loose of accuracy in saving the data??\n    sol_gust1forager_val = solution.IntrinsicReader(\"./gustforager_validation\")\n    sol_gust1forager_erho = solution.IntrinsicReader(\"./gustforager_epsilonrho\")\n    sol_gust1forager_elength = solution.IntrinsicReader(\"./gustforager_epsilonlength\")\n    sol_gust1forager_eintensity = solution.IntrinsicReader(\"./gustforager_epsilonintensity\")  \n    node = 13\n    components = [2,3,4]\n    t_range = jnp.arange(len(sol_gust1forager.data.dynamicsystem_s1.t))\n    points = sol_gust1forager.data.shards_s1.points\n    filtered_map = sol_gust1forager.data.forager_shard2adgust.filtered_map\n    index = list(sol_gust1forager.data.forager_shard2adgust.filtered_indexes)[0]\n    epsilon = 1e-4\n    jac_rho = (objectives.X2_MAX(sol_gust1forager_erho.data.dynamicsystem_s1.X2,\n                                 jnp.array([node]),\n                                 jnp.array(components),\n                                 t_range) -\n                 objectives.X2_MAX(#sol_gust1forager.data.dynamicsystem_s1.X2[index],\n                                   sol_gust1forager_val.data.dynamicsystem_s1.X2,\n                                   jnp.array([node]),\n                                   jnp.array(components),\n                                   t_range)\n                 ) / epsilon\n    epsilon = 1e-4\n    jac_length = (objectives.X2_MAX(sol_gust1forager_elength.data.dynamicsystem_s1.X2,\n                                 jnp.array([node]),\n                                 jnp.array(components),\n                                 t_range) -\n                 objectives.X2_MAX(#sol_gust1forager.data.dynamicsystem_s1.X2[index],\n                     sol_gust1forager_val.data.dynamicsystem_s1.X2,\n                                   jnp.array([node]),\n                                   jnp.array(components),\n                                   t_range)\n                 ) / epsilon\n    epsilon = 1e-4\n    jac_intensity = (objectives.X2_MAX(sol_gust1forager_eintensity.data.dynamicsystem_s1.X2,\n                                       jnp.array([node]),\n                                       jnp.array(components),\n                                       t_range) -\n                     objectives.X2_MAX(#sol_gust1forager.data.dynamicsystem_s1.X2[index],\n                         sol_gust1forager_val.data.dynamicsystem_s1.X2,\n                                       jnp.array([node]),\n                                       jnp.array(components),\n                                       t_range)\n                 ) / epsilon\n\njacdiff_rho = jnp.hstack((sol_gust1forager.data.dynamicsystem_scatter0.jac['rho_inf'] -\n               jac_rho) / jac_rho)\njacdiff_length = jnp.hstack((sol_gust1forager.data.dynamicsystem_scatter0.jac['length'] -\n               jac_length) / jac_length)\njacdiff_intensity = jnp.hstack((sol_gust1forager.data.dynamicsystem_scatter0.jac['intensity'] -\n               jac_intensity) / jac_intensity)\n\nnormalise = 1 / jnp.array([normalisation_force, normalisation_moment, normalisation_moment])\njac_dict = dict(objective=sol_gust1forager.data.dynamicsystem_scatter0.objective[:,0] * normalise,\n                rho=jnp.hstack(sol_gust1forager.data.dynamicsystem_scatter0.jac['rho_inf']) * normalise,\n                rho_fd=jnp.hstack(jac_rho) * normalise,\n                rho_diff=jacdiff_rho,\n                Length=jnp.hstack(sol_gust1forager.data.dynamicsystem_scatter0.jac['length']) * normalise,\n                Length_fd=jnp.hstack(jac_length) * normalise,\n                Length_diff=jacdiff_length, Intensity=jnp.hstack(sol_gust1forager.data.dynamicsystem_scatter0.jac['intensity']),\n                Intensity_fd=jnp.hstack(jac_intensity) * normalise,\n                Intensity_diff=jacdiff_intensity\n                )\ndf_jac = pd.DataFrame(jac_dict, index=['Shear', 'Torsion', 'Bending'])\n#df_jac = df_jac.rename()\n</code></pre> <p>Since dynamic load envelopes have been constructed, the interest is to be able to obtain derivatives at the critical points. In opposition to the derivatives of expectations where all the operations are needed in the construction of the computational graph, here only a few of the most problematic cases are automatically identifies and its derivatives computed. The metrics being tracked are wing-root shear, torsion and out-of plane bending moments. The parallelisation is set for two gust intensities, two flow densities and 16 gust lengths to cover 1-cos gusts from 50 to 200 m/s with 10 m/s separation between points. Rather than a realistic example, this is set to test the machinery of the forager pattern and verify it can indeed discover critical load cases and automatically compute gradients. The gradient of these critical cases is also calculated with respect to the flow density, gust length and intensity (thus they are not only the parameters for the parallelisation but are also chosen to be the input variables of the sensitivity analysis, though any other input such as FE matrices could have been chosen). By looking at Figs. 9 - 11, we can identify maximum loads at around 65, 75, 115 m/s gust lengths for shear, torsion and bending. Of the 64 cases analyzed, the forager step picked those with higher intensity and flow density as expected, but only 2 gust lengths of 70 m/s for the shear and torsion, and 110 m/s for the out-of-plane bending. The finer the discretization in the input of the parallelization, the closer to the actual maximum, but also the more computations that need to be run. It is therefore a balance whose best compromise is to be found on an actual optimization study. Once those peaks are found, the algorithms triggers the sensitivity analysis, for which we have shown a verification for the 70 m/s gust with maximum density and intensity in Table 5. Finite differences are computed with an $\\epsilon = 10^{-4} $ and the absolute relative difference with AD is shown as $ \\Delta $ for each of the input parameters ($ \\partial  \\rho_{\\inf} $ for the flow density derivative, $ \\partial L $ for the gust length, and $ \\partial w $ for the gust intensity). The computational wall-time for entire forager loop (concurrent loads, filtering of critical cases and sensitivities on them) was 60.1 and 359.5 seconds on the GPU and CPU respectively.</p> objective $ \\partial  \\rho_{\\inf} $ $ \\Delta $ $ \\partial L $ $ \\Delta $ $ \\partial w $ $ \\Delta $ Shear 0.897 1.670 $ 1.6 \\times 10^{-5} $ -0.0026 $ 4 \\times 10^{-6} $ 0.035 $ 1. \\times 10^{-7} $ Torsion 0.025 -0.018 $ 4.2 \\times 10^{-4} $ -0.0007 $ 3.9 \\times 10^{-7} $ 0.0018 $ 1.2 \\times 10^{-6} $ Bending 0.300 0.329 $ 2.9 \\times 10^{-5} $ 0.00003 $ 1.7 \\times 10^{-4} $ 0.012 $ 9.2 \\times 10^{-8} $ <pre><code>tabulate(df_jac, headers=df_jac.columns, tablefmt='orgtbl',\n         #columns=[\"\\(\\rho_{\\inf} \\)\", \"\\(\\rho_{\\inf}\\) FD\", \"\\(\\Delta \\)\"]\n         )\n</code></pre> </li> </ol>"},{"location":"examples/SailPlane/sailplane_nb/","title":"Sail Plane","text":"<p>Verifying the structural implementation on a clamped configuration.</p>"},{"location":"examples/SailPlane/sailplane_nb/#load-modules","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = True\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#run-cases","title":"Run cases","text":"<pre><code>import time\n\nTIMES_DICT = dict()\nSOL = dict()\nCONFIG = dict()\n\ndef run(input1, **kwargs):\n    jax.clear_caches()\n    label = kwargs.get('label', 'default')\n    t1 = time.time()\n    config =  configuration.Config(input1)\n    sol = feniax.feniax_main.main(input_obj=config)\n    t2 = time.time()\n    TIMES_DICT[label] = t2 - t1      \n    SOL[label] = sol\n    CONFIG[label] = config\n\ndef save_times():\n    pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),\n                            index=TIMES_DICT.keys())\n    pd_times.to_csv(\"./run_times.csv\")\n</code></pre> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#sp1","title":"SP1","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 5\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#sp2","title":"SP2","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 15\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#sp3","title":"SP3","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 30\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#sp4","title":"SP4","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 50\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#sp5","title":"SP5","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 100\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> <pre><code>save_times()\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#postprocessing","title":"Postprocessing","text":""},{"location":"examples/SailPlane/sailplane_nb/#plotting-functions","title":"Plotting functions","text":"<pre><code>print(f\"Format for figures: {figfmt}\")\ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=6)\n            return fig, figname\n        return inner\n    return inner_decorator\n\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n</code></pre> <pre><code>def fn_spError(sol_list, config, print_info=True):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    err = {f\"M{i}_L{j}\": 0. for i in range(1,6) for j in range(6)}\n    for li in range(6): # loads\n      for mi in range(1,6):  # modes\n        count = 0\n        r_spn = []\n        r_sp = []\n        for index, row in config.fem.df_grid.iterrows():\n          r_spn.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n          r_sp.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n        r_spn = jnp.array(r_spn)\n        r_sp = jnp.array(r_sp)        \n        err[f\"M{mi}_L{li}\"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)\n        err[f\"M{mi}_L{li}\"] /= len(r_sp)\n        if print_info:\n            print(f\"**** LOAD: {li}, NumModes: {mi} ****\")\n            print(err[f\"M{mi}_L{li}\"])\n    return err\n\ndef fn_spWingsection(sol_list, config):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    r_spn = []\n    r_spnl = []\n    r_sp = []\n    for li in range(6): # loads\n      for mi in [4]:#range(1,6):  # modes\n        r_spni = []\n        r_spnli = []\n        r_spi = []\n        r_sp0 = []\n        for index, row in config.fem.df_grid.iterrows():\n          if row.fe_order in list(range(20)):\n            r_sp0.append(config.fem.X[index])  \n            r_spni.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n            r_spnli.append(u_spl[li, row.fe_order,:3] + config.fem.X[index])\n            r_spi.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n\n        r_spn.append(jnp.array(r_spni))\n        r_spnl.append(jnp.array(r_spnli))\n        r_sp.append(jnp.array(r_spi))\n    r_sp0 = jnp.array(r_sp0)\n    return r_sp0, r_sp, r_spn, r_spnl\n\n@fig_background\ndef plot_spWingsection(r0, r, rn, rnl):\n    fig = None\n    # colors=[\"darkgrey\", \"darkgreen\",\n    #         \"blue\", \"magenta\", \"orange\", \"black\"]\n    # dash = ['dash', 'dot', 'dashdot']\n    modes = [5, 15, 30, 50, 100]\n    for li in range(6):\n      if li == 0:   \n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"NMROM\",\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-NL\",\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-Lin\",\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())\n\n      else:\n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())            \n    fig.update_yaxes(title=r'$\\large u_z [m]$')\n    fig.update_xaxes(title=r'$\\large S [m]$', range=[6.81,36])\n    fig.update_layout(legend=dict(x=0.6, y=0.95),\n                      font=dict(size=20))\n    # fig = uplotly.lines2d((rnl[:,0]**2 + rnl[:,1]**2)**0.5, rnl[:,2], fig,\n    #                       dict(name=f\"NASTRAN-101\",\n    #                            line=dict(color=\"grey\",\n    #                                      dash=\"solid\")\n    #                                  ),\n    #                             dict())\n    return fig\n\n@fig_background\ndef fn_spPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    e250 = jnp.array([error[f'M{i}_L1'] for i in range(1,6)])\n    e400 = jnp.array([error[f'M{i}_L3'] for i in range(1,6)])\n    e530 = jnp.array([error[f'M{i}_L5'] for i in range(1,6)])\n    fig = None\n    fig = uplotly.lines2d(num_modes, e250 , fig,\n                              dict(name=\"F = 250 KN\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e400, fig,\n                              dict(name=\"F = 400 KN\",\n                                   line=dict(color=\"green\", dash=\"dash\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e530, fig,\n                              dict(name=\"F = 530 KN\",\n                                   line=dict(color=\"black\", dash=\"dot\")\n                                   ),\n                              dict())\n    fig.update_xaxes(title= {'font': {'size': 20}, 'text': 'Number of modes'})#title=\"Number of modes\",title_font=dict(size=20))\n    fig.update_yaxes(title=r\"$\\Large \\epsilon$\",type=\"log\", # tickformat= '.1r',\n                     tickfont = dict(size=12), exponentformat=\"power\",\n                     #dtick=0.2,\n                     #tickvals=[2e-2, 1e-2, 7e-3,5e-3,3e-3, 2e-3, 1e-3,7e-4, 5e-4,3e-4, 2e-4, 1e-4, 7e-5, 5e-5]\n                     )\n    #fig.update_layout(height=650)\n    fig.update_layout(legend=dict(x=0.7, y=0.95), font=dict(size=20))\n\n    return fig\n\n@fig_background\ndef fn_spPloterror3D(error, error3d):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    if error is not None:\n      fig = uplotly.lines2d(loads, error, fig,\n                                dict(name=\"Error ASET\",\n                                     line=dict(color=\"red\"),\n                                     marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n    fig = uplotly.lines2d(loads, error3d, fig,\n                              dict(name=\"Error full 3D\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      # showlegend=False,\n                      #legend=dict(x=0.7, y=0.95),\n                      xaxis_title='Loading [KN]',\n                      yaxis_title=r'$\\Large \\epsilon$')\n\n    return fig\n\n@fig_background\ndef plot_spAD(rn, r0):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    x = list(range(1,7))\n    y = [rn[i-1][-1, 2] - r0[-1,2] for i in x]\n    fig = uplotly.lines2d(x, y, fig,\n                                dict(#name=\"Error ASET\",\n                                     #line=dict(color=\"red\"),\n                                     #marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n\n    #fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      showlegend=False,\n                      xaxis_title=r'$\\Large{\\tau}$',\n                      yaxis_title='Uz [m]'\n    )\n\n    return fig\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#load-nastran-data","title":"Load Nastran data","text":"<pre><code>import pathlib\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nfrom tabulate import tabulate\n\n\nexamples_path = pathlib.Path(\"../../../../examples\")\n####### SailPlane ###########\nSP_folder = examples_path / \"SailPlane\"\n#nastran_path = wingSP_folder / \"NASTRAN/\"\n\nop2model = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run.op2\",\n                                   SP_folder / \"NASTRAN/static400/run.bdf\",\n                                 static=True)\n\nop2model.readModel()\nt_sp, u_sp = op2model.displacements()\n\nop2modell = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run_linear.op2\",\n                                   SP_folder / \"NASTRAN/static400/run_linear.bdf\",\n                                 static=True)\n\nop2modell.readModel()\nt_spl, u_spl = op2modell.displacements()\nsp_error3d = jnp.load(examples_path/ \"SailPlane/sp_err.npy\")\n</code></pre>"},{"location":"examples/SailPlane/sailplane_nb/#structural-verification-of-a-representative-configuration","title":"Structural verification of a representative configuration","text":"<ol> <li> <p>Geometrically nonlinear static response</p> <p>The static equilibrium of the aircraft under prescribed loads is first studied with follower loads normal to the wing applied at the tip of each wing (nodes 25 and 48). The response for an increasing load stepping of 200, 300, 400, 480 and 530 KN is computed. The snippet of the inputs and simulation call are given in Listing <code>\\ref{code:static}</code>.</p> <p><pre><code>\\begin{listing}[!ht]\n\\begin{minted}[frame=single]{python}\nimport feniax.preprocessor.configuration as configuration\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\ninp = Inputs()\ninp.fem.folder = \"./FEM/\"\ninp.fem.num_modes = 50\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\")\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation =\n[[0., 2e5, 2.5e5, 3.e5, 4.e5, 4.8e5, 5.3e5],\n[0., 2e5, 2.5e5, 3.e5, 4.e5, 4.8e5, 5.3e5]]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\nconfig =  configuration.Config(inp)\nsol = feniax.feniax_main.main(input_obj=config)\n\\end{minted}\n\\caption{FENIAX inputs for structural static simulation}\n\\label{code:static}\n\\end{listing}\n</code></pre> Nonlinear static simulations on the original full model (before condensation) are also carried out in MSC Nastran and are included. The interpolation elements in the full FE solver are used to output the displacements at the condensation nodes for direct comparison with the NMROM results. Geometric nonlinearities are better illustrated by representing a sectional view of the wing as in Fig. 1, where deformations in the z-direction versus the metric $S = \\sqrt{x^2+y^2}$ are shown. MSC Nastran linear solutions (Solution 101) are also included to appreciate more clearly the shortening and follower force effects in the nonlinear computations.</p> <pre><code>import feniax.preprocessor.configuration as configuration\nconfig = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nr_sp0, r_sp, r_spn, r_spnl = fn_spWingsection(sol_sp, config)\nfig, figname = fig_out(name)(plot_spWingsection)(r_sp0, r_sp, r_spn, r_spnl)\nfigname\n</code></pre> <p><pre><code>#+name: fig:SPWingsection\n</code></pre> <pre><code>#+caption: Static geometrically-nonlinear effects on the aircraft main wing\n</code></pre> <pre><code>#+attr_latex: :width 0.5\\textwidth\n</code></pre> <pre><code>#+results: SPWingsection\n</code></pre> file:</p> <p>The tolerance in the Newton solver was set to $10^{-6}$ in all cases. A convergence analysis with the number of modes in the solution is presented in Fig. 1. 5, 15, 30, 50, 100 modes are used to build the corresponding NMROMs. The error metric is defined as the $\\ell^2$ norm divided by the total number of nodes (only the condenses ones in this case): $\\epsilon = ||u_{NMROM} - u_{NASTRAN}||/N_{nodes}$. It can be seen the solution with 50 modes already achieves a very good solution even for the largest load which produces a 25.6$\\%$ tip deformation of the wing semi-span, $b = 28.8$ m. The displacement difference with the full FE solution at the tip in this case is less than 0.2$\\%$.</p> <pre><code>config = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nsp_error = fn_spError(sol_sp, config, print_info=True)\nfig, figname = fig_out(name)(fn_spPloterror)(sp_error)\nfigname\n</code></pre> <p></p> <p>The 3D structural response has been reconstructed using the approach in Fig. . The nodes connected by the interpolation elements (RBE3s) to the ASET solution are reconstructed first and subsequently a model with RBFs kernels is used to extrapolate to the rest of the nodes in the full FE. A very good agreement is found against the geometrically-nonlinear Nastran solution (SOL 400). Fig. 2 shows the overlap in the Nastran solution (in red) and the NMROM (in blue) for the 530 KN loading.</p> <p><pre><code>#+name: SPstatic_3D\n</code></pre> <pre><code>#+caption: Static 3D solution for a solution with 50 modes and 530 KN loading (Full NASTRAN solution in red versus the NMROM in blue).\n</code></pre> <pre><code>#+attr_latex: :width 0.7\\textwidth\n</code></pre>  The error metric of this 3D solution is also assessed in Fig. 2, for the solution with 50 modes. The discrepancy metric is of the same order than the previously shown at the reduction points. This conveys an important point, that there is no significant accuracy loss in the process of reconstructing the 3D solution.</p> <pre><code>sp_error1D = [sp_error[f'M4_L{i}'] for i in range(6)]\n# fig, figname = fig_out(name)(fn_spPloterror3D)(sp_error1D, sp_error3d)\nfig, figname = fig_out(name,update_layout=dict(showlegend=False))(fn_spPloterror3D)(None, sp_error3d)\nfigname\n</code></pre> <p></p> <p>Next we compare the computational times for the various solutions presented in this section in Table 1. Computations of the six load steps in Fig. 1 are included in the assessment. A near 50 times speed-up is achieved with our solvers compared to Nastran nonlinear solution, which is one of the main strengths of the proposed method. As expected, the linear static solution in Nastran is the fastest of the results, given it only entails solving a linear, very sparse system of equations.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'SP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [5*60 + 45]\nvalues += [1.02]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 101\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 101\n</code></pre> Time    6.7, 6.63, 6.79, 7.06, 9.55         345           1.02 <p>Computational times static solution</p> </li> <li> <p>Differentiation of static response</p> <p>The AD for the static solvers is first verified as follows: the load stepping shown above becomes a pseudo-time interpolation load such that a variable $\\tau$ controls the amount of loading and we look at the variation of the wing-tip displacement as a function of this $\\tau$. If $f(\\tau=[1, 2, 3, 4, 5, 6]) = [200, 250, 300, 400, 480, 530]$ KN, with a linear interpolation between points, the derivative of the z-component of the tip of the wing displacement is computed at $\\tau= 1.5, 3.5, 5.5 $, as show in Fig. 3 where the $y$-axis is the tip displacement, $\\tau$ is in the $x$-axis and the big red circles the points where the derivatives are computed (coincident to the graph slope at those points).</p> <pre><code>fig, figname = fig_out(name)(plot_spAD)(r_sp, r_sp0)\n#figname\n</code></pre> <pre><code>#+name: fig:sp_ad\n</code></pre> <pre><code>#+caption: Static tip displacement with pseudo-time stepping load\n</code></pre> <pre><code>#+attr_latex: :width 0.5\\textwidth\n</code></pre>  Table 2 shows a very good agreement against finite-differences (FD) with an epsilon of $10^{-3}$. Note how the derivative at each of the marked points corresponds approximately to the slope in the graph at those very points, which varies as the load steps are not of equal length. And the biggest slope occurs precisely in between $\\tau$ of 4 and 5 when the prescribed loading undergoes the biggest change from 300 to 400 KN. <pre><code>      $\\tau$   $f(\\tau)$ \\[m\\]   $f'(\\tau)$ (AD)   $f'(\\tau)$ (FD)\n      -------- ----------------- ----------------- -----------------\n      1.5      2.81              0.700             0.700\n      3.5      4.527             1.344             1.344\n      5.5      6.538             0.623             0.623\n</code></pre> AD verification structural static problem"},{"location":"examples/SimoFS/main/","title":"Free flying shell structure","text":""},{"location":"examples/industrialAC/main/","title":"IndustrialAC (clamped)","text":"<p>Verifying the nonlinear structural dynamics on a clamped configuration.</p>"},{"location":"examples/industrialAC/main/#load-modules","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = True\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/industrialAC/main/#run-cases","title":"Run cases","text":"<pre><code>import time\n\nTIMES_DICT = dict()\nSOL = dict()\nCONFIG = dict()\n\ndef run(input1, **kwargs):\n    jax.clear_caches()\n    label = kwargs.get('label', 'default')\n    t1 = time.time()\n    config =  configuration.Config(input1)\n    sol = feniax.feniax_main.main(input_obj=config)\n    t2 = time.time()\n    TIMES_DICT[label] = t2 - t1      \n    SOL[label] = sol\n    CONFIG[label] = config\n\ndef save_times():\n    pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),\n                            index=TIMES_DICT.keys())\n    pd_times.to_csv(\"./run_times.csv\")\n</code></pre> <p>WARNING: private model, not available open source</p> <p>Gust lengths and corresponding gust velocities that have been run here and elsewhere. L~g~ 18.0,67.0,116.0,165.0,214 V0~g~ 11.3047276743,14.0732311562,15.4214195361,16.3541764073,17.0785232867</p> <p>Index   Gust length    Gust intensity   Intensity constant   u~inf~    rho~inf~    Mach</p> 1       67                  14.0732311562    0.01                 200              1.225                     0.81   2       67                  14.0732311562    2                    200              1.225                     0.81   3       165.               16.3541764073    0.01                 200              1.225                     0.81   4       165.               16.3541764073    2                    200              1.225                     0.81   5       67                  14.0732311562    0.01                 200              1.225                     0.   6       67                  14.0732311562    2                    200              1.225                     0.   7       165.               16.3541764073    0.01                 200              1.225                     0.   8       165.               16.3541764073    2                    200              1.225                     0. <p>Table with various gusts on the IndustrialAC that have been run in this work   or in the past</p> <pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac","title":"IndustrialAC","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*0.01\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac2","title":"industrialAC2","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073 * 0.01\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.05\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac3","title":"industrialAC3","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac4","title":"industrialAC4","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac5","title":"industrialAC5","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\",#\"Kvaerno3\",\n                                         )\n\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac6","title":"industrialAC6","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\ninp.systems.sett.s1.tn = 501\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac7","title":"industrialAC7","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.tn = 1501\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"ImplicitEuler\",#\"Kvaerno3\",\n          # stepsize_controller=dict(PIDController=dict(atol=1e-5,\n              #                                            rtol=1e-5)),\n          root_finder=dict(Newton=dict(atol=1e-5,\n                                       rtol=1e-5))\n                                         )\n\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/industrialAC/main/#industrialac8","title":"industrialAC8","text":"<pre><code>industrialAC_folder = feniax.PATH / \"../examples/IndustrialAC/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{industrialAC_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{industrialAC_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{industrialAC_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{industrialAC_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{industrialAC_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{industrialAC_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{industrialAC_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{industrialAC_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.tn = 1501\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Kvaerno3\", #\"ImplicitEuler\",#\"Kvaerno3\",\n          # stepsize_controller=dict(PIDController=dict(atol=1e-5,\n          #                                            rtol=1e-5)),\n          root_finder=dict(Chord=dict(atol=1e-5,\n                                      rtol=1e-5))                              \n          # root_finder=dict(Newton=dict(atol=1e-6,\n          #                              rtol=1e-6))\n                                         )\n\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\nrun(inp, label=name)\n</code></pre> <pre><code>save_times()\n</code></pre>"},{"location":"examples/industrialAC/main/#postprocessing","title":"Postprocessing","text":""},{"location":"examples/industrialAC/main/#plotting-functions","title":"Plotting functions","text":"<pre><code>print(f\"Format for figures: {figfmt}\")\ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=6)\n            return fig, figname\n        return inner\n    return inner_decorator\n\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n</code></pre> <pre><code>@fig_background\ndef industrialAC_wingtip2(sol1, sol2, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                  sol1.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                  sol2.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[:], (y1[:]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[0]}\",\n                               line=dict(color=\"orange\")\n                               ))\n    fig = uplotly.lines2d(x2[1:], (y2[:-1]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[1]}\",\n                               line=dict(color=\"steelblue\")\n                               ))\n\n    if nast_scale is not None:\n        offset = 0. #u111m[nast_load[0],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[0]], (u111m[nast_load[0],:,-1, dim] - offset)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[0]}\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\",\n                                             width=1.5)\n                                   ))\n        offset2 = 0. #u111m[nast_load[1],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[1]], (u111m[nast_load[1],:,-1, dim] - offset2)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[1]}\",\n                                   line=dict(color=\"red\",\n                                             dash=\"dot\",\n                                             width=1.5)\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n\ndef subplots_wtips2(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig2.update_xaxes(title=None)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig1.layout.xaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig1.layout.yaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    fig.update_layout(legend=dict(x=0.81, y=1))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n\n\n@fig_background\ndef industrialAC_wingtip4(sol1, sol2, sol3, sol4, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                    sol1.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                    sol2.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x3, y3 = putils.pickIntrinsic2D(sol3.data.dynamicsystem_s1.t,\n                                    sol3.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x4, y4 = putils.pickIntrinsic2D(sol4.data.dynamicsystem_s1.t,\n                                    sol4.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[0]}\",\n                               line=dict(color=\"orange\",\n                                         dash=\"solid\")\n                               ))\n    fig = uplotly.lines2d(x2[:], (y2[:]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[1]}\",\n                               line=dict(color=\"blue\", dash=\"dot\")\n                               ))\n    fig = uplotly.lines2d(x3[:], (y3[:]-y3[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[2]}\",\n                               line=dict(color=\"red\")\n                               ))\n    fig = uplotly.lines2d(x4[:], (y4[:]-y4[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[3]}\",\n                               line=dict(color=\"grey\", dash=\"dash\")\n                               ))\n\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n</code></pre>"},{"location":"examples/industrialAC/main/#load-nastran-data","title":"Load Nastran data","text":"<pre><code># import pathlib\n# import pickle\n# import jax.numpy as jnp\n# import jax\n# import pandas as pd\n# import feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\n# from feniax.preprocessor.inputs import Inputs\n# import feniax.feniax_main\n# import feniax.preprocessor.solution as solution\n# import feniax.unastran.op2reader as op2reader\n# from tabulate import tabulate\n# \nexamples_path = pathlib.Path(\"../../../../examples\")\n\n####### IndustrialAC ###########\nnastran_path = examples_path / \"IndustrialAC/NASTRAN/146-111/\"\nnas111 = op2reader.NastranReader(op2name=(nastran_path / \"IndustrialAC-146run.op2\"))\nnas111.readModel()\nt111, u111 = nas111.displacements()\n\nnastran_pathm = examples_path / \"IndustrialAC/NASTRAN/146-111_081\"\nnas111m = op2reader.NastranReader(op2name=(nastran_pathm / \"IndustrialAC-146run.op2\"))\nnas111m.readModel()\nt111m, u111m = nas111m.displacements()\n</code></pre>"},{"location":"examples/industrialAC/main/#aeroelastic-dynamic-loads-on-an-industrial-configuration","title":"Aeroelastic dynamic loads on an industrial configuration","text":"<p>The studies presented in this section are based on a reference configuration developed to industry standards known as IndustrialAC, which is representative of a long-range wide-body transport airplane. The version with a wing-tip extension in [@CEA2023] is employed to verify a gust response against MSC Nastran linear solution of the full FE model. While the previous results where purely structural, now the dynamic response to an atmospheric disturbance or gust is computed. This aeroelastic analysis is a requirement for certification purposes and it is one of the main drivers in sizing the wings of high aspect ratio wings. Furthermore, the previous examples showed the advantage of our approach in terms of computational speed, but other than that results could be obtained with commercial software. The geometrically nonlinear aeroelastic response, however, it is not currently available in commercial solutions that are bounded to linear analysis in the frequency domain. Other research codes feature those additional physics, yet are limited to simple models. Thus the added value in the proposed approach comes at the intersection between the nonlinear physics arising from large integrated displacements, computational efficiency and the ability to enhance the models already built for industrial use.\\ Fig. 1 shows the reference FE model with three modal shapes. The FE model contains a total of around 177400 nodes, which are condensed into 176 active nodes along the reference load axes through interpolation elements. A Guyan or static condensation approach is used for the reduction and the error in the natural frequencies between full and reduced models is kept below 0.1% well beyond the 30th mode. The aerodynamic model contains $\\sim 1,500$ aerodynamic panels. The simulations are carried out with a modal resolution of 70 modes and a time step in the Runge-Kutta solver of 0.005.</p> <p><pre><code>#+name: fig:industrialAC_modalshapes\n</code></pre> <pre><code>#+caption: Modified IndustrialAC reference configuration with characteristic modal shapes\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> file:figs_ext/industrialAC_modalshapes3.pdf</p> <ol> <li> <p>Linear response for low intensity gust</p> <p>A verification exercise is introduced first by applying two 1-cos gust shapes at a very low intensity, thus producing small deformations and a linear response. The flow Mach number is 0.81. A first gust is applied that we name as G1 of length 67 m and peak velocity 0.141 m/s, and a second gust, G2, of 165 m and peak velocity of 0.164 m/s. A snippet of the inputs to the simulation is display in Listing <code>\\ref{code:dynamic}</code>.</p> <p><pre><code>\\begin{listing}[!ht]\n\\begin{minted}[frame=single]{python}\nfrom feniax.preprocessor.inputs import Inputs\n\\begin{minted}[frame=single]{python}\ninp.fem.folder = \"./FEM/\"\ninp.fem.num_modes = 70\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 7.5\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.aero.folder = \"./AERO/\"\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.intensity = 0.141\ninp.systems.sett.s1.aero.gust.length = 67.\n\\end{minted}\n\\caption{FENIAX of inputs for dynamic gust simulation}\n\\label{code:dynamic}\n\\end{listing}\n</code></pre> Fig. 1 shows the normalised wing-tip response with our NMROM that accurately reproduces the linear solution based on the full FE model.</p> <pre><code>sol1= solution.IntrinsicReader(\"./IndustrialAC\")\nsol2= solution.IntrinsicReader(\"./industrialAC2\")\nfig, figname = fig_out(name)(subplots_wtips2)(industrialAC_wingtip2,sol1, sol2, labels=[1,2], nast_scale=0.01, nast_load=[2,6])\nfigname\n</code></pre> <p></p> </li> <li> <p>Nonlinear response for high intensity gust</p> <p>The gust intensity in the previous section by a factor of 200 in order to show the effects of geometric nonlinearities that are only captured by the nonlinear solver. As seen in Fig. 2, there are major differences in the $x$ and $y$ components of the response due to follower and shortening effects, and a slight reduction in the $z$-component. These are well known geometrically nonlinear effects that are added to the analysis with no significant overhead.</p> <pre><code>sol1= solution.IntrinsicReader(\"./industrialAC3\")\nsol2= solution.IntrinsicReader(\"./industrialAC4\")\nfig, figname = fig_out(name)(subplots_wtips2)(industrialAC_wingtip2, sol1, sol2, labels=[1,2], nast_scale=2., nast_load=[2,6])\nfigname\n</code></pre> <p></p> <p>Snapshots of the 3D response are reconstructed for the G1 gust using the method verified above at the time points where tip displacement are maximum and minimum, i.e. 0.54 and 0.84 seconds. The front and side views together with the aircraft reference configuration are shown in Fig. 3.</p> <p><pre><code>#+name: fig:industrialACgust3D\n</code></pre> <pre><code>#+caption: 3D IndustrialAC Nonlinear gust response\n</code></pre> <pre><code>#+attr_latex: :width 1\\textwidth\n</code></pre> file:figs_ext/industrialACgust3D2.pdf</p> <p>In previous examples the same Runge-Kutta 4 (RK4) time-marching scheme is used and now we explore the dynamic solution with other solvers to assess their accuracy and also their computational performance. Two explicit ODE solvers, RK4 and Dormand-Prince\\'s 5/4 method (labelled S1 and S2), and two implicit, Euler first order and Kvaerno\\'s 3/2 method ((labelled S3 and S4)), are compared in Fig. 3. In order to justify the use of implicit solvers we reduce the time step from 0.005 to 0.02 seconds, at which point both explicit solvers diverge. Kvaerno\\'s implicit solver remain stable and accurate despite the larger time step while the Euler implicit method is stable but do not yield accurate results.</p> <pre><code>sol3= solution.IntrinsicReader(\"./industrialAC3\")\nsol5= solution.IntrinsicReader(\"./industrialAC5\")\nsol7= solution.IntrinsicReader(\"./industrialAC7\")\nsol8= solution.IntrinsicReader(\"./industrialAC8\")\n\nfig, figname = fig_out(name)(subplots_wtips2)(industrialAC_wingtip4, sol1=sol3, sol2=sol5, sol3=sol7, sol4=sol8,\n                                            labels=[\"S1\",\"S2\",\"S3\",\"S4\"])\nfigname\n</code></pre> <p><pre><code>#+name: fig:GustXRF3578\n</code></pre> <pre><code>#+caption: Wing-tip response to high intensity gust using implicit solvers\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> <pre><code>#+results: GustXRF3578\n</code></pre> file:figs/GustXRF3578.png</p> <p>The computational times of the different solvers are shown in Table 2. The implicit solvers have taken one order of magnitude more time to run despite the reduction in time step. Therefore the main take away this is that for moderately large frequency dynamics, the explicit solvers offer a much efficient solution. The turning point for using implicit solvers would be when the largest eigenvalue in Eqs. <code>\\ref{eq2:sol_qs}</code> led to prohibitly small time steps. In terms of the Nastran solution, we are not showing the whole simulation time because that would include the time to sample the DLM aerodynamics which are input into the NMROM as a post-processing step. Instead, the increase in time when adding an extra gust subcase to an already existing analysis is shown, i.e. the difference between one simulation that only computes one gust response and another with two. It is remarkable that the explicit solvers are faster on the nonlinear solution than the linear solution by a commercial software. Besides our highly efficient implementation, the main reason for this might be the Nastran solution involves first a frequency domain analysis and then an inverse Fourier transform to obtain the time-domain results.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'industrialAC{i}'].iloc[0], 2)) for i in [3,5,7,8]])]\nvalues += [0*60*60 + 1*60 + 21]\nheader = [\"NMROM [S1, S2, S3, S4]\" ]\nheader += [\"$\\Delta$ NASTRAN 146\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <pre><code>           NMROM \\[S1, S2, S3, S4\\]       $\\Delta$ NASTRAN 146\n</code></pre> Time    22.49, 18.94, 273.95, 847.89   81 <p>Computational times IndustrialAC gust solution.</p> </li> <li> <p>Differentiation of aeroelastic response</p> <p>Similarly to the examples above, we now verify the AD implementation for the nonlinear aeroelastic response to the gust $G1$. The sensitivity of the six components of the wing root loads are computed with respect to the gust parameters $w_g$ and $L_g$, and the flow parameter $\\rho_{\\inf}$. The results are presented in 1. A very good agreement with the finite differences is found with $\\epsilon=10^{-4}$.</p> <p><pre><code>#+caption: Automatic differentiation in aeroelastic problem\n</code></pre> <pre><code>#+name: table:IndustrialAC_AD\n</code></pre> <pre><code>\\begin{table} [h!]\n\\begin{center}\n\\begin{tabular}{lllll}\n\\toprule\n &amp; $w_g$ &amp; $L_g$ &amp; $\\rho_{\\inf}$ \\\\\n\\midrule\n$f_1$ (AD) &amp; 12.180 &amp; 6.666 &amp; 477.208 \\\\\n$f_1$ (FD)  &amp; 12.180 &amp; 6.190  &amp; 477.198  \\\\\n\\hline\n$f_2 (AD)$ &amp; 19.088 &amp; 6.122 &amp; 712.485 \\\\\n$f_2 (FD)$ &amp; 19.088 &amp; 7.045 &amp; 712.514  \\\\\n\\hline\n$f_3 (AD)$ &amp; 65.574 &amp; 8.218 &amp; 1464.910 \\\\\n$f_3 (FD)$ &amp; 65.574  &amp; 7.813 &amp; 1464.909  \\\\\n\\hline\n$f_4 (AD)$ &amp; 126.648&amp; 21.598 &amp; 2883.370 \\\\\n$f_4 (FD)$ &amp; 126.648&amp; 19.736  &amp; 2883.371  \\\\\n\\hline\n$f_5 (AD)$ &amp; 330.759 &amp; 85.224 &amp; 5931.723 \\\\\n$f_5 (FD)$ &amp; 330.759  &amp; 97.188  &amp; 5930.027  \\\\\n\\hline\n$f_6$ (AD) &amp; 252.128 &amp; 48.423 &amp; 7179.735 \\\\\n$f_6$ (FD) &amp; 252.128  &amp; 14.980  &amp; 7180.023  \\\\\n\\bottomrule\n\\end{tabular}\n\\end{center}\n\\end{table}\n</code></pre></p> </li> </ol>"},{"location":"examples/industrialACtrim/main/","title":"Main","text":""},{"location":"examples/wingSP/wingSP_nb/","title":"Wing Sail Plane","text":"<p>Verifying the nonlinear structural dynamics on a clamped configuration.</p>"},{"location":"examples/wingSP/wingSP_nb/#load-modules","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = True\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/wingSP/wingSP_nb/#run-cases","title":"Run cases","text":"<pre><code>import time\n\nTIMES_DICT = dict()\nSOL = dict()\nCONFIG = dict()\n\ndef run(input1, **kwargs):\n    jax.clear_caches()\n    label = kwargs.get('label', 'default')\n    t1 = time.time()\n    config =  configuration.Config(input1)\n    sol = feniax.feniax_main.main(input_obj=config)\n    t2 = time.time()\n    TIMES_DICT[label] = t2 - t1      \n    SOL[label] = sol\n    CONFIG[label] = config\n\ndef save_times():\n    pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),\n                            index=TIMES_DICT.keys())\n    pd_times.to_csv(\"./run_times.csv\")\n</code></pre> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\n</code></pre> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ndts = [round(1./ eigenvals[i]**0.5, 2) for i in [5,15,30,50,100]]\n</code></pre> <p>WSP1</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 5\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> <p>WSP2</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 15\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> <p>WSP3</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 30\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> <p>WSP4</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> <p>WSP4alpha05</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 0.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 0.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> <p>WSP4alpha15</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> <p>WSP5</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\", max_steps=30000) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 100\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/wingSP/wingSP_nb/#postprocessing","title":"Postprocessing","text":""},{"location":"examples/wingSP/wingSP_nb/#plotting-functions","title":"Plotting functions","text":"<pre><code>print(f\"Format for figures: {figfmt}\")\ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=6)\n            return fig, figname\n        return inner\n    return inner_decorator\n\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n</code></pre> <pre><code>def subplots_wtips2(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig2.update_xaxes(title=None)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig1.layout.xaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig1.layout.yaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    fig.update_layout(legend=dict(x=0.81, y=1))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n@fig_background\ndef wsp_wingtip(sol_list, dim, labels=None, nast_load=None, axes=None,\n                modes = [5, 15, 30, 50, 100],scale = 1./28.8):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.ra,\n                                      fixaxis2=dict(node=23, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    if nast_load is not None:\n        fig = uplotly.lines2d(t_wsp[nast_load], u_wsp[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-NL\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\")\n                                   ))\n        fig = uplotly.lines2d(t_wspl[nast_load], u_wspl[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-Lin\",\n                                   line=dict(color=\"orange\",\n                                             #dash=\"dash\"\n                                             )\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    if axes is None:\n        fig.update_yaxes(title=r'$\\Large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=[0, 15], title='$\\large time \\; [s]$')\n    else:\n        fig.update_yaxes(range=axes[1], title=r'$\\large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=axes[0], title='$\\large time \\; [s]$')\n\n    return fig\n\n@fig_background\ndef wsp_rootload(sol_list, dim,\n                 labels = ['0.5', '1.', '1.5'], nodei=2, scale = 1e-3):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.X2,\n                                      fixaxis2=dict(node=nodei, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large f_%s \\; [MN/m]$'%(dim+1))\n    fig.update_xaxes(range=[0, 10], title='$\\large time \\; [s]$')\n\n    return fig\n\ndef subplots_wsp(sol_list, labels=None, nast_load=None, axes=None):\n\n    fig1 = wsp_wingtip(sol_list, 0, labels, nast_load, axes)\n    fig2 = wsp_wingtip(sol_list, 1, labels, nast_load, axes)\n    fig3 = wsp_wingtip(sol_list, 2, labels, nast_load, axes)\n    fig = make_subplots(rows=2, cols=2, horizontal_spacing=1, vertical_spacing=5,\n                        specs=[[{\"colspan\": 2}, None],\n                               [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=2, col=2\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n\ndef fn_wspError(sol_list):\n    error_dict = dict()\n    for i, si in enumerate(sol_list):\n        for di in range(3):\n            x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                          si.data.dynamicsystem_s1.ra,\n                                          fixaxis2=dict(node=23, dim=di))\n            yinterp = jnp.interp(t_wsp, x, y)\n            ynastran = u_wsp[0,:,-4, di] + y[0]\n            n = 10000\n            error = jnp.linalg.norm((yinterp[1,:n] - ynastran[:n]) / ynastran[:n]) / len(ynastran[:n])\n            label = f\"M{i}x{di}\"\n            error_dict[label] = error\n\n    return error_dict\n\n@fig_background\ndef fn_wspPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    ex1 = [error[f'M{i}x0'] for i in range(5)]\n    ex2 = [error[f'M{i}x1'] for i in range(5)]\n    ex3 = [error[f'M{i}x2'] for i in range(5)]\n    fig = None\n    fig = uplotly.lines2d(num_modes, ex1, fig,\n                              dict(name=\"Error - x1\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex2, fig,\n                              dict(name=\"Error - x2\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex3, fig,\n                              dict(name=\"Error - x3\",\n                                   line=dict(color=\"black\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    return fig\n\n@fig_background\ndef fn_wspPloterror3D(time, error):\n\n    fig = None\n    fig = uplotly.lines2d(time, error, fig,\n                              dict(name=\"Error\",\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=7)\n    fig.update_layout(\n                      #height=700,\n                      xaxis_title=r'$\\Large time [s]$',\n                      yaxis_title=r'$\\Large \\epsilon$')\n    return fig\n</code></pre>"},{"location":"examples/wingSP/wingSP_nb/#load-nastran-data","title":"Load Nastran data","text":"<pre><code>import pathlib\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nfrom tabulate import tabulate\n\nexamples_path = pathlib.Path(\"../../../../examples\")\n\n####### wingSP ###########\nwingSP_folder = examples_path / \"wingSP\"\nnastran_path = wingSP_folder / \"NASTRAN/\"\nnas_wspl = op2reader.NastranReader(op2name=(nastran_path / \"wing_109d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wspl.readModel()\nt_wspl, u_wspl = nas_wspl.displacements()  \n# ###\nnas_wsp = op2reader.NastranReader(op2name=(nastran_path / \"wing400d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wsp.readModel()\nt_wsp, u_wsp = nas_wsp.displacements()\nwsp_error3d = jnp.load(examples_path/ \"wingSP/wsp_err.npy\")\n</code></pre>"},{"location":"examples/wingSP/wingSP_nb/#structural-verification-of-a-representative-configuration","title":"Structural verification of a representative configuration","text":"<ol> <li> <p>Large-amplitude nonlinear dynamics</p> <p>This test case demonstrates the accuracy of the NMROM approach for dynamic geometrically-nonlinear calculations. The right wing of Fig. is considered and dynamic nonlinear simulations are carried out and compared to commercial solutions of the full FE model. A force is applied at the wing tip with a triangular loading profile, followed by a sudden release of the applied force to heavily excite the wing. The force profile is given in Fig. 1. The applied force is then $f_{tip} = \\alpha \\textup{\\pmb{f}}{max} f(0.05, 4)$ with $\\textup{\\pmb{f}} = [-2\\times 10^5, 0., 6\\times 10^5]$ where $\\alpha$ has been set to $1$.</p> <p><pre><code>#+name: fig:ramping_load\n</code></pre> <pre><code>#+caption: Ramping load profile for dynamic simulation of representative wing\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:./figs_ext/ramping_load.pdf The dynamic response is presented in Fig. 1, where results have been normalised with the wing semi-span ($l=28.8$ m). As expected, linear analysis over-predicts vertical displacements and does not capture displacements in the $x$ and $y$ directions. NMROMs were built with 5, 15, 30, 50 and 100 modes. A Runge-Kutta four is used to march the equation in time with time steps corresponding to the inverse of the largest eigenvalue in the NMROM, i.e. $\\Delta t = [27.34, 6.62, 2.49, 1.27, 0.575] \\times 10^{-3}$ s.</p> <pre><code>sol_wsp= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [1,2,4]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.9385,\n    font=dict(size= 10))))(subplots_wtips2)(wsp_wingtip, sol_wsp, labels=None, nast_load=0, modes=[5,15,50])\nfigname\n</code></pre> <p></p> <p>As in the previous example, the 3D shape of the model is retrieved and compared against the full nonlinear dynamic solution, as illustrated in Fig. 2 (Nastran solution in yellow and NMROM with 50 modes in blue). The times at positive and negative peaks are displayed. Even though a wing of such characteristics would never undergo in practice this level of deformations, these results further support the viability of the methodology to solve highly geometrically nonlinear dynamics, on complex models and with minimal computational effort.</p> <p></p> <p>Next we look at the differences of the dynamic simulations with the same metric employed above that now evolves in time. Integration errors accumulate and discrepancies grow with time but still remain small. In fact the differences between MSC Nastran and our dynamic solvers are comparable to the static example with the highest load (around the $5\\times 10^{-5}$ mark). Both cases displaying maximum deformations around 25\\% of the wing semi-span.</p> <pre><code>wsp_error = fn_wspError(sol_wsp)\nwsp_error_time = jnp.linspace(0,15,10001)\nfig, figname = fig_out(name, update_layout=dict(showlegend=False, margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=5,\n                              t=2,\n                              b=0)))(fn_wspPloterror3D)(wsp_error_time,wsp_error3d)\nfigname\n</code></pre> <p><pre><code>#+name: WSP_error\n</code></pre> <pre><code>#+caption: $\\ell^2$ norm per node differences between full FE nonlinear solution and NMROM with 50 modes\n</code></pre> <pre><code>#+attr_latex: :width 0.7\\textwidth\n</code></pre> <pre><code>#+results: WSP_error\n</code></pre> file:figs/WSP_error.pdf</p> <p>An impressive reduction of computational time is achieved by our solvers as highlighted in Table 1. The nonlinear response of the full model took 1 hour 22 minutes, which is over two orders of magnitude slower than the NMROM with 50 modes resolution, which proved very accurate. The significant increase in computational effort when moving from a solution with 50 modes to 100 modes is due to various factors: vectorised operations are limited and the quadratic nonlinearities ultimately lead to O($N_m^3$) algorithms; the time-step needs to be decreased for the Runge-Kutta integration to remain stable; the additional overheads that come with saving and moving larger tensors, from the modal shapes, the cubic modal couplings, to the system states (note times shown account for all the steps from start to end of the simulation, including saving all the data for postprocessing).</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'WSP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [1*60*60 + 22*60]\nvalues += [33.6]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 109\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 109\n</code></pre> Time    2.79, 2.92, 4.85, 12.14, 155.3      4920          33.6 <p>Computational times representative wing dynamic solution</p> </li> <li> <p>Differentiation of dynamic response</p> <p>We move now to a novel feature of this work, i.e. the ability to compute gradients via automatic differentiation in geometrically nonlinear dynamic problems. The maximum root loads occurring in a wing subjected to dynamic loads is a good test case as it can be a critical metric in sizing the aircraft wings, especially high-aspect ratio ones. Thus we look at the variation of the maximum z-component of the vertical internal forces as a function of $\\alpha$ in the loading profile of Fig. 1. Effectively, the slope of the loading increases with $\\alpha$. Table 2 shows the derivatives computed using FD with an epsilon of $10^{-4}$ and AD in reverse-mode on the example with 50 modes resolution. In this case the FD needed tweaking of epsilon while application of AD was straight forward with no need for checkpoints and took around three times the speed of a single calculation.</p> <p>$\\alpha$   $f(\\alpha)$    $f'(\\alpha)$ (AD)   $f'(\\alpha)$ (FD)</p> 0.5        1706.7                 3587.71             3587.77   1.0        3459.9                 3735.26             3735.11   1.5        5398.7                 3957.81             3958.31 <p>AD verification structural dynamic problem</p> <p>It is worth noting the high frequency dynamics excited after the ramping load is suddenly released. In fact in the $z$-component of the wing-tip evolution in Fig. 3 we can see a maximum tip displacement of 4.36 m, 7.91 m and 10.83 m, for $\\alpha = 0.5, 1, 1.5$ i.e smaller than the proportional linear response. On the other hand, in Fig. 4 the evolution of the root loads show a response with much higher frequencies and the maximum occurs in the free dynamical response of the wing, which is higher as we increase $\\alpha$.</p> <pre><code>sol_wspz= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [\"4alpha05\",\n                                                          \"4\",\n                                                          \"4alpha15\"]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.3,\n    font=dict(size= 16))))(wsp_wingtip)(sol_wspz, dim=2, modes=[\"0.5\",\"1\",\"1.5\"], axes=[[0,10],None])\nfigname\n</code></pre> <p></p> <pre><code>fig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.941,\n    font=dict(size= 16))))(wsp_rootload)(sol_wspz, dim=2, scale=1e-6)\nfigname\n</code></pre> <p></p> </li> </ol>"}]}