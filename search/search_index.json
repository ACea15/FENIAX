{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Finite Element models 4 Intrinsic Nonlinear Aeroelastics in JAX [FENIAX]","text":"<p>FEM4INAS is an aeroelastic toolbox  written and parallelized in Python, which acts as a post-processor of commercial software such as MSC Nastran.  Arbitrary FE models built for linear aeroelastic analysis are enhanced with geometric nonlinear effects, flight dynamics and linearized state-space solutions about nonlinear equilibrium.</p>"},{"location":"#t1","title":"t1","text":"<p>fsdf</p>"},{"location":"#t3","title":"t3","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the <code>Getting Started</code> guide for My Project.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>To install the project, run:</p> <pre><code>pip install my-project\n</code></pre>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#reduction-to-load-paths","title":"Reduction to Load paths:","text":"<p>The full FE linear model is splitted into active (ASETs) nodes and ommited nodes such that,</p> <p> </p> <p>A linear dependency is assumed between the omitted and the active degrees of freedom,  </p> <p>with $\\pmb{T}_{oa}$ the transformation matrix between both sets. In general, the condensation is dependent on the frequencies and forms a nonlinear eigenvalue problem where each LNM,  with natural frequency, $\\omega_j$, has one transformation matrix,  </p> <p>This is the so-called exact-condensation matrix, where Kidder's mode expansion is also introduced. The first-order approximation of this equation is attained by letting $\\omega_j =0$, thereby removing inertia effects. This results in a static condensation or Guyan reduction. Note that when the mass model consists only of lumped masses on the active degrees of freedom, $\\pmb{M}{oo} = \\pmb{M}{oa} = \\pmb{0}$, Guyan reduction is the exact condensation.</p> <p>After calculation of $\\pmb{T}{oa}$, the transformation from the active set and the full model is defined as $\\pmb{T} =[\\pmb{I}_a \\; \\pmb{T}{oa}^T]^T$, with $\\pmb{I}_a$ the identity matrix of dimension $a$. The condensed mass and stiffness matrices are obtained by equating the kinetic energy, $\\mathcal{E}_k$ and the potential energy, $\\mathcal{E}_p$ in the linear reduced and complete systems; if external loads are applied to the omitted nodes, equating virtual work gives the equivalent loads in the condensed model:</p> <p> </p>"},{"location":"theory/#intrinsic-modes","title":"Intrinsic modes:","text":"<p>Let $\\pmb{\\Phi}{a}$ be the solution of the eigenvalue problem using the condensed matrices, $\\pmb{M}_a$ and $\\pmb{K}_a$. $\\pmb{\\Phi}{a}$ includes the full set of modes in the condensed system written as displacement and linear rotations at the nodes along the load-paths. Those mode shapes also define velocity and strain distributions. Standard FE solvers yield results in the global reference frame while the intrinsic modes are defined in the initial local configuration (with the convention of the $x$-direction running along the local beam). Therefore, a matrix $\\pmb{\\Xi}_{0}(s) = [\\pmb{R}^{ba}(s,0), \\pmb{0} ; \\pmb{0} , \\pmb{R}^{ba}(s,0)]$ is introduced to rotate the 6-component vectors from the global to the local initial frame, $\\pmb{R}^{ba}(s,0)$ calculated from the structural nodes position.</p> <p>The discrete velocity mode is defined as $\\pmb{\\Phi}{1j} = \\pmb{\\Phi}{0j}$ and a linear interpolation is sought for the continuous displacement, $\\pmb{\\phi}_0(s)$, and velocities modes, $\\pmb{\\phi}_1(s)$:</p> <p> </p> <p>The corresponding distribution of linear and rotational momenta at the master nodes can be  obtained using the condensed inertia matrix, $\\pmb{\\Psi}{1j}  = \\pmb{M}_a \\pmb{\\Phi}{1j} = \\pmb{M}a \\pmb{\\Phi}{0j}$, expressed in their components in the global frame of reference. The introduction of this momentum mode allows the use of arbitrary mass models. Because the mass matrix is already calculated as an integral along the 3D domain and then condensed to a set of master nodes, the continuous momentum mode shapes, $\\pmb{\\psi}_1$, are considered lumped and defined using Dirac's delta function, $\\delta$ as,</p> <p> </p> <p>Each displacement mode also generates a corresponding internal stress state. This defines discrete force/moment modes, $\\pmb{\\Phi}{2}$, which are obtained from the displacement modes and the condensed stiffness matrix using a summation-of-forces approach  where $\\pmb{r}_i$ is the position vector of the nodes summed by $\\mathcal{S}$, and $\\pmb{r}{i+1/2}$ the mid position between nodes $s_i$ and $s_{i+1}$. The first term is the sum of forces due to modal displacements and the second one the sum of moments due to modal rotations and the cross product of the  position vector and the previous calculated force. The strain modes $\\pmb{\\psi}_{2}$ are obtained from spatial derivatives of the displacement modes along along the load paths, and interpolated as piece-wise constant too,</p> <p> </p>"},{"location":"theory/#nonlinear-couplings","title":"Nonlinear couplings:","text":"<p>After a Galerkin projection of the equations, the following tensors need to be approximated: - Alphas must equal the identity matrix  </p> <ul> <li>Gammas give the nonlinear inertia and strain couplings</li> </ul> <p> </p>"},{"location":"theory/#aeroelastic-system","title":"Aeroelastic system:","text":"<p>Systems of equations Different systems of equations are assembled depending on options: </p> <ul> <li>Structural dynamic:    </li> <li>(Clamped) Aeroelastic systems:    </li> </ul>"},{"location":"theory_intrinsic/","title":"Intrinsic modal description","text":""},{"location":"theory_intrinsic/#reduction-to-load-paths","title":"Reduction to Load paths","text":"<p>The full FE linear model is splitted into active (ASETs) nodes and ommited nodes such that,</p> <p> </p> <p>A linear dependency is assumed between the omitted and the active degrees of freedom,  </p> <p>with  the transformation matrix between both sets. In general, the condensation is dependent on the frequencies and forms a nonlinear eigenvalue problem where each LNM,  with natural frequency, , has one transformation matrix,  </p> <p>This is the so-called exact-condensation matrix, where Kidder's mode expansion is also introduced. The first-order approximation of this equation is attained by letting , thereby removing inertia effects. This results in a static condensation or Guyan reduction. Note that when the mass model consists only of lumped masses on the active degrees of freedom, , Guyan reduction is the exact condensation.</p> <p>After calculation of , the transformation from the active set and the full model is defined as , with  the identity matrix of dimension . The condensed mass and stiffness matrices are obtained by equating the kinetic energy,  and the potential energy,  in the linear reduced and complete systems; if external loads are applied to the omitted nodes, equating virtual work gives the equivalent loads in the condensed model:</p> <p> </p>"},{"location":"theory_intrinsic/#intrinsic-modes","title":"Intrinsic modes","text":"<p>Let  be the solution of the eigenvalue problem using the condensed matrices,  and .  includes the full set of modes in the condensed system written as displacement and linear rotations at the nodes along the load-paths. Those mode shapes also define velocity and strain distributions. Standard FE solvers yield results in the global reference frame while the intrinsic modes are defined in the initial local configuration (with the convention of the -direction running along the local beam). Therefore, a matrix  is introduced to rotate the 6-component vectors from the global to the local initial frame,  calculated from the structural nodes position.</p> <p>The discrete velocity mode is defined as  and a linear interpolation is sought for the continuous displacement, , and velocities modes, :</p> <p> </p> <p>The corresponding distribution of linear and rotational momenta at the master nodes can be  obtained using the condensed inertia matrix, , expressed in their components in the global frame of reference. The introduction of this momentum mode allows the use of arbitrary mass models. Because the mass matrix is already calculated as an integral along the 3D domain and then condensed to a set of master nodes, the continuous momentum mode shapes, , are considered lumped and defined using Dirac's delta function,  as,</p> <p> </p> <p>Each displacement mode also generates a corresponding internal stress state. This defines discrete force/moment modes, , which are obtained from the displacement modes and the condensed stiffness matrix using a summation-of-forces approach  where  is the position vector of the nodes summed by , and  the mid position between nodes  and . The first term is the sum of forces due to modal displacements and the second one the sum of moments due to modal rotations and the cross product of the  position vector and the previous calculated force. The strain modes  are obtained from spatial derivatives of the displacement modes along along the load paths, and interpolated as piece-wise constant too,</p> <p> </p>"},{"location":"theory_intrinsic/#nonlinear-couplings","title":"Nonlinear couplings","text":"<p>After a Galerkin projection of the equations, the following tensors need to be approximated: - Alphas must equal the identity matrix  </p> <ul> <li>Gammas give the nonlinear inertia and strain couplings</li> </ul> <p> </p>"},{"location":"theory_intrinsic/#aeroelastic-system","title":"Aeroelastic system","text":"<p>Systems of equations Different systems of equations are assembled depending on options: </p> <ul> <li>Structural dynamic:    </li> <li>(Clamped) Aeroelastic systems:    </li> </ul>"},{"location":"api/couplings/","title":"Nonlinear couplings","text":""},{"location":"api/couplings/#intrinsic.couplings.f_alpha1","title":"<code>f_alpha1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>alpha1 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        alpha1 tensor (NmxNm)\n\n    \"\"\"\n\n    alpha1 = jnp.einsum(\"isn,jsn-&gt;ij\", phi1, psi1)\n    return alpha1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_alpha2","title":"<code>f_alpha2(phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Alpha2 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha2(phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Alpha2 tensor (NmxNm)\n\n    \"\"\"\n\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    alpha2 = jnp.einsum(\"isn,jsn,n-&gt;ij\", phi2i, psi2i, delta_si)\n    return alpha2\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma1","title":"<code>f_gamma1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma1 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        Gamma1 tensor (NmxNmxNm)\n\n    \"\"\"\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L1(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L1 = f2(phi1, psi1)  # Nmx6xNmxNm\n    gamma1 = jnp.einsum(\"isn,jskn-&gt;ijk\", phi1, L1)\n    return gamma1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma2","title":"<code>f_gamma2(phi1m, phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>psi1m</code> <code>array</code> <p>Velocity modal shapes at mid-points (Nmx6xNn)</p> required <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma2 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma2(\n    phi1m: jnp.array, phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array\n) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    psi1m : jnp.array\n        Velocity modal shapes at mid-points (Nmx6xNn)    \n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Gamma2 tensor (NmxNmxNm)\n\n    \"\"\"\n\n    phi1mi = phi1m[:, :, 1:]\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L2(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L2 = f2(phi2i, psi2i)  # Nmx6xNmxNm\n    gamma2 = jnp.einsum(\"isn,jskn,n-&gt;ijk\", phi1mi, L2, delta_si)\n    # L2 = f2(phi2, psi2) # Nmx6xNmxNm\n    # gamma2 = jnp.einsum('isn,jskn,n-&gt;ijk', phi1m, L2, delta_s)\n    return gamma2\n</code></pre>"},{"location":"api/inputs/","title":"Input containers","text":""},{"location":"api/inputs/#intrinsic-modal-solution","title":"Intrinsic modal solution","text":"<p>Containers for the intrinsic modal solution settings</p>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DGustMc","title":"<code>DGustMc</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DGust</code></p> <p>1-cos gust settings (specialisation from DGust)</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>simulation_time</code> <code>Array</code> <code>dfield('', default=None)</code> <code>intensity</code> <code>float</code> <code>dfield('', default=None)</code> <code>step</code> <code>float</code> <code>dfield('', default=None)</code> <code>length</code> <code>float</code> <code>dfield('', default=None)</code> <code>shift</code> <code>float</code> <code>dfield('', default=0.0)</code> <code>panels_dihedral</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>collocation_points</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>shape</code> <code>str</code> <code>dfield('', default='const')</code> <p>Attributes:</p> Name Type Description <code>totaltime</code> <code>float</code> <code>x</code> <code>Array</code> <code>time</code> <code>Array</code> <code>ntime</code> <code>int</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DGustMc(DGust):\n    \"\"\"1-cos gust settings (specialisation from DGust)\n\n    Parameters\n    ----------\n    u_inf : float\n\n    simulation_time : Array\n    intensity : float\n    step : float\n    length : float\n    shift : float\n    panels_dihedral : str | jax.Array\n    collocation_points : str | jax.Array\n    shape : str\n\n    Attributes\n    ----------\n    totaltime : float\n    x : Array\n    time : Array\n    ntime : int\n\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    simulation_time: jnp.ndarray = dfield(\"\", default=None)\n    intensity: float = dfield(\"\", default=None)\n    step: float = dfield(\"\", default=None)\n    length: float = dfield(\"\", default=None)\n    shift: float = dfield(\"\", default=0.0)\n    panels_dihedral: str | jnp.ndarray = dfield(\"\", default=None)\n    collocation_points: str | jnp.ndarray = dfield(\"\", default=None)\n    shape: str = dfield(\"\", default=\"const\")\n    totaltime: float = dfield(\"\", init=False)\n    x: jnp.ndarray = dfield(\"\", init=False)\n    time: jnp.ndarray = dfield(\"\", init=False)\n    ntime: int = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        if isinstance(self.panels_dihedral, (str, pathlib.Path)):\n            object.__setattr__(self, \"panels_dihedral\", jnp.load(self.panels_dihedral))\n        if isinstance(self.collocation_points, (str, pathlib.Path)):\n            object.__setattr__(\n                self, \"collocation_points\", jnp.load(self.collocation_points)\n            )\n\n        gust_totaltime, xgust, time, ntime = self._set_gustDiscretization(\n            self.intensity,\n            self.panels_dihedral,\n            self.shift,\n            self.step,\n            self.simulation_time,\n            self.length,\n            self.u_inf,\n            jnp.min(self.collocation_points[:, 0]),\n            jnp.max(self.collocation_points[:, 0]),\n        )\n        object.__setattr__(self, \"totaltime\", gust_totaltime)\n        object.__setattr__(self, \"x\", xgust)\n        object.__setattr__(self, \"time\", time)\n        object.__setattr__(self, \"ntime\", ntime)\n        # del self.simulation_time\n\n    def _set_gustDiscretization(\n        self,\n        gust_intensity,\n        dihedral,\n        gust_shift,\n        gust_step,\n        simulation_time,\n        gust_length,\n        u_inf,\n        min_collocationpoints,\n        max_collocationpoints,\n    ):\n        #\n        gust_totaltime = gust_length / u_inf\n        xgust = jnp.arange(\n            min_collocationpoints,  # jnp.min(collocation_points[:,0]),\n            max_collocationpoints  # jnp.max(collocation_points[:,0]) +\n            + gust_length\n            + gust_step,\n            gust_step,\n        )\n        time_discretization = (gust_shift + xgust) / u_inf\n        if time_discretization[-1] &lt; simulation_time[-1]:\n            time = jnp.hstack(\n                [\n                    time_discretization,\n                    time_discretization[-1] + 1e-6,\n                    simulation_time[-1],\n                ]\n            )\n        else:\n            time = time_discretization\n        if time[0] != 0.0:\n            time = jnp.hstack([0.0, time[0] - 1e-6, time])\n        ntime = len(time)\n        # npanels = len(collocation_points)\n        return gust_totaltime, xgust, time, ntime\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Daero","title":"<code>Daero</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Modal aerodynamic settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>rho_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>q_inf</code> <code>float</code> <code>dfield('', init=False)</code> <code>c_ref</code> <code>float</code> <code>dfield('', default=None)</code> <code>time</code> <code>Array</code> <code>dfield('', default=None)</code> <code>qalpha</code> <code>Array</code> <code>dfield('', default=None)</code> <code>qx</code> <code>Array</code> <code>dfield('', default=None)</code> <code>elevator_index</code> <code>Array</code> <code>dfield('', default=None)</code> <code>elevator_link</code> <code>Array</code> <code>dfield('', default=None)</code> <code>approx</code> <code>str</code> <code>dfield('', default='Roger')</code> <code>Qk_struct</code> <code>list</code> <code>dfield('Sample frquencies and\\n    corresponding AICs for the structure', default=None, yaml_save=False)</code> <code>Qk_gust</code> <code>list</code> <code>dfield('', default=None, yaml_save=False)</code> <code>Qk_controls</code> <code>list</code> <code>dfield('', default=None, yaml_save=False)</code> <code>Q0_rigid</code> <code>Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>A</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>B</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>C</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>D</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_controls</code> <code>list</code> <code>dfield('', default=None)</code> <code>poles</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>num_poles</code> <code>int</code> <code>dfield('', default=None)</code> <code>gust_profile</code> <code>str</code> <code>dfield('', default='mc', options=['mc'])</code> <code>gust</code> <code>dict | DGust</code> <code>dfield('Gust settings', default=None)</code> <code>controller_name</code> <code>dict</code> <code>dfield('', default=None)</code> <code>controller_settings</code> <code>dict</code> <code>dfield('', default=None)</code> <code>controller</code> <code>DController</code> <code>dfield('', init=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Daero(DataContainer):\n    \"\"\"Modal aerodynamic settings for each system\n\n    Parameters\n    ----------\n    u_inf : float\n    rho_inf : float\n    q_inf : float\n    c_ref : float\n    time : Array\n    qalpha : Array\n    qx : Array\n    elevator_index : Array\n    elevator_link : Array\n    approx : str\n    Qk_struct : list\n    Qk_gust : list\n    Qk_controls : list\n    Q0_rigid : Array\n    A : str | jax.Array\n    B : str | jax.Array\n    C : str | jax.Array\n    D : str | jax.Array\n    _controls : list\n    poles : str | jax.Array\n    num_poles : int\n    gust_profile : str\n    gust : dict | __main__.DGust\n    controller_name : dict\n    controller_settings : dict\n    controller : DController\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    rho_inf: float = dfield(\"\", default=None)\n    q_inf: float = dfield(\"\", init=False)\n    c_ref: float = dfield(\"\", default=None)\n    time: jnp.ndarray = dfield(\"\", default=None)\n    qalpha: jnp.ndarray = dfield(\"\", default=None)\n    qx: jnp.ndarray = dfield(\"\", default=None)\n    elevator_index: jnp.ndarray = dfield(\"\", default=None)\n    elevator_link: jnp.ndarray = dfield(\"\", default=None)\n    #\n    approx: str = dfield(\"\", default=\"Roger\")\n    Qk_struct: list[jnp.ndarray, jnp.ndarray] = dfield(\n        \"\"\"Sample frquencies and\n    corresponding AICs for the structure\"\"\",\n        default=None,\n        yaml_save=False,\n    )\n    Qk_gust: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None, yaml_save=False)\n    Qk_controls: list[jnp.ndarray, jnp.ndarray] = dfield(\n        \"\", default=None, yaml_save=False\n    )\n    Q0_rigid: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    A: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    B: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    C: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    D: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    _controls: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None)\n    poles: str | jnp.ndarray = dfield(\"\", default=None)\n    num_poles: int = dfield(\"\", default=None)\n    gust_profile: str = dfield(\"\", default=\"mc\", options=[\"mc\"])\n    # gust_settings: dict = dfield(\"\", default=None, yaml_save=False)\n    gust: dict | DGust = dfield(\"Gust settings\", default=None)\n    controller_name: dict = dfield(\"\", default=None)\n    controller_settings: dict = dfield(\"\", default=None)\n    controller: DController = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"approx\", self.approx.capitalize())\n        if self.gust is not None:\n            gust_class = globals()[f\"DGust{self.gust_profile.capitalize()}\"]\n            object.__setattr__(\n                self,\n                \"gust\",\n                # initialise_Dclass(self.gust, gust_class))\n                initialise_Dclass(\n                    self.gust, gust_class, u_inf=self.u_inf, simulation_time=self.time\n                ),\n            )\n\n        if self.controller_name is not None:\n            controller_class = globals()[f\"DController{self.controller_name.upper()}\"]\n            controller_obj = initialise_Dclass(\n                self.controller_settings, controller_class\n            )\n            object.__setattr__(self, \"controller\", controller_obj)\n        else:\n            object.__setattr__(self, \"controller\", None)\n        if isinstance(self.poles, (str, pathlib.Path)):\n            object.__setattr__(self, \"poles\", jnp.load(self.poles))\n        if self.elevator_link is not None:\n            object.__setattr__(self, \"elevator_link\", jnp.array(self.elevator_link))\n        if self.elevator_index is not None:\n            object.__setattr__(self, \"elevator_index\", jnp.array(self.elevator_index))\n        if self.poles is not None:\n            object.__setattr__(self, \"num_poles\", len(self.poles))\n        if self.u_inf is not None and self.rho_inf is not None:\n            q_inf = 0.5 * self.rho_inf * self.u_inf**2\n            object.__setattr__(self, \"q_inf\", q_inf)\n        if isinstance(self.A, (str, pathlib.Path)):\n            object.__setattr__(self, \"A\", jnp.load(self.A))\n        if isinstance(self.B, (str, pathlib.Path)):\n            object.__setattr__(self, \"B\", jnp.load(self.B))\n        if isinstance(self.C, (str, pathlib.Path)):\n            object.__setattr__(self, \"C\", jnp.load(self.C))\n        if isinstance(self.D, (str, pathlib.Path)):\n            object.__setattr__(self, \"D\", jnp.load(self.D))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dconst","title":"<code>Dconst</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Constants in the configuration</p> <p>Parameters:</p> Name Type Description Default <code>I3</code> <code>Array</code> <p>3x3 Identity matrix</p> <code>dfield('3x3 Identity matrix', default=eye(3))</code> <code>e1</code> <code>Array</code> <p>3-component vector with beam direction in local frame</p> <code>dfield('3-component vector with beam direction in local frame', default=array([1.0, 0.0, 0.0]))</code> <code>EMAT</code> <code>Array</code> <p>3x3 Identity matrix</p> <code>dfield('3x3 Identity matrix', default=array([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, -1, 0, 0, 0], [0, 1, 0, 0, 0, 0]]))</code> <p>Attributes:</p> Name Type Description <code>EMATT</code> <code>Array</code> <p>Transpose EMAT</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dconst(DataContainer):\n    \"\"\"Constants in the configuration\n\n    Parameters\n    ----------\n    I3 : Array\n       3x3 Identity matrix\n    e1 : Array\n       3-component vector with beam direction in local frame\n    EMAT : Array\n       3x3 Identity matrix\n\n    Attributes\n    ----------\n    EMATT : Array\n       Transpose EMAT\n\n    \"\"\"\n\n    I3: jnp.ndarray = dfield(\"3x3 Identity matrix\", default=jnp.eye(3))\n    e1: jnp.ndarray = dfield(\n        \"3-component vector with beam direction in local frame\",\n        default=jnp.array([1.0, 0.0, 0.0]),\n    )\n    EMAT: jnp.ndarray = dfield(\n        \"3x3 Identity matrix\",\n        default=jnp.array(\n            [\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, -1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n            ]\n        ),\n    )\n    EMATT: jnp.ndarray = dfield(\"3x3 Identity matrix\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"EMATT\", self.EMAT.T)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxNewton","title":"<code>DdiffraxNewton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax Newton solver</p> <p>Parameters:</p> Name Type Description Default <code>rtol</code> <code>float</code> <code>dfield('', default=1e-07)</code> <code>atol</code> <code>float</code> <code>dfield('', default=1e-07)</code> <code>max_steps</code> <code>int</code> <code>dfield('', default=100)</code> <code>norm</code> <code>str</code> <code>dfield('', default='linalg_norm')</code> <code>kappa</code> <code>float</code> <code>dfield('', default=0.01)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DdiffraxNewton(Dlibrary):\n    \"\"\"Settings for Diffrax Newton solver\n\n    Parameters\n    ----------\n    rtol : float\n    atol : float\n    max_steps : int\n    norm : str\n    kappa : float\n\n    \"\"\"\n\n    rtol: float = dfield(\"\", default=1e-7)\n    atol: float = dfield(\"\", default=1e-7)\n    max_steps: int = dfield(\"\", default=100)\n    norm: str = dfield(\"\", default=\"linalg_norm\")\n    kappa: float = dfield(\"\", default=0.01)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"newton\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxOde","title":"<code>DdiffraxOde</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax ODE solvers</p> <p>Parameters:</p> Name Type Description Default <code>root_finder</code> <code>dict</code> <code>dfield('', default=None)</code> <code>stepsize_controller</code> <code>dict</code> <code>dfield('', default=None)</code> <code>solver_name</code> <code>str</code> <code>dfield('', default='Dopri5')</code> <code>save_at</code> <code>Array | list</code> <code>dfield('', default=None)</code> <code>max_steps</code> <code>int</code> <code>dfield('', default=20000)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DdiffraxOde(Dlibrary):\n    \"\"\"Settings for Diffrax ODE solvers\n\n    Parameters\n    ----------\n    root_finder : dict\n    stepsize_controller : dict\n    solver_name : str\n    save_at : jax.Array | list\n    max_steps : int\n\n    \"\"\"\n\n    root_finder: dict = dfield(\"\", default=None)\n    stepsize_controller: dict = dfield(\"\", default=None)\n    solver_name: str = dfield(\"\", default=\"Dopri5\")\n    save_at: jnp.ndarray | list = dfield(\"\", default=None)\n    max_steps: int = dfield(\"\", default=20000)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"ode\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Ddriver","title":"<code>Ddriver</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Program initialisation settings and trigger of simulations </p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <code>dfield('Driver to manage the simulation', default=True, options=['intrinsic'])</code> <code>sol_path</code> <code>str | Path</code> <code>dfield('Folder path to save results', default='./')</code> <code>compute_fem</code> <code>bool</code> <code>dfield('Compute or load presimulation data', default=True)</code> <code>save_fem</code> <code>bool</code> <code>dfield('Save presimulation data', default=True)</code> <code>ad_on</code> <code>bool</code> <code>dfield('', default=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Ddriver(DataContainer):\n    \"\"\"Program initialisation settings and trigger of simulations \n\n    Parameters\n    ----------\n    typeof : str\n    sol_path : str | pathlib.Path\n    compute_fem : bool\n    save_fem : bool\n    ad_on : bool\n    \"\"\"\n\n    typeof: str = dfield(\n        \"Driver to manage the simulation\", default=True, options=[\"intrinsic\"]\n    )\n    sol_path: str | pathlib.Path = dfield(\"Folder path to save results\", default=\"./\")\n    compute_fem: bool = dfield(\"\"\"Compute or load presimulation data\"\"\", default=True)\n    save_fem: bool = dfield(\"\"\"Save presimulation data\"\"\", default=True)\n    ad_on: bool = dfield(\"\", default=False)\n\n    def __post_init__(self):\n        if self.sol_path is not None:\n            object.__setattr__(self, \"sol_path\", pathlib.Path(self.sol_path))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dfem","title":"<code>Dfem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Finite Element and discretisation model settings </p> <p>Parameters:</p> Name Type Description Default <code>connectivity</code> <code>dict | list</code> <code>dfield('Connectivities of components')</code> <code>folder</code> <code>str | Path</code> <code>dfield('Folder in which to find Ka, Ma,\\n    and grid data (with those names)', default=None)</code> <code>Ka_name</code> <code>str | Path</code> <code>dfield('Condensed stiffness matrix', default='Ka.npy')</code> <code>Ma_name</code> <code>str | Path</code> <code>dfield('Condensed mass matrix', default='Ma.npy')</code> <code>Ka</code> <code>Array</code> <code>dfield('Condensed stiffness matrix', default=None, yaml_save=False)</code> <code>Ma</code> <code>Array</code> <code>dfield('Condensed mass matrix', default=None, yaml_save=False)</code> <code>Ka0s</code> <code>Array</code> <code>dfield('Condensed stiffness matrix augmented with 0s', default=None, yaml_save=False)</code> <code>Ma0s</code> <code>Array</code> <code>dfield('Condensed mass matrix augmented with 0s', default=None, yaml_save=False)</code> <code>num_modes</code> <code>int</code> <code>dfield('Number of modes in the solution', default=None)</code> <code>eig_type</code> <code>str</code> <code>dfield('Calculation of eigenvalues/vectors', default='scipy', options=['scipy', 'jax_custom', 'inputs, input_memory'])</code> <code>eigenvals</code> <code>Array</code> <code>dfield('EigenValues', default=None, yaml_save=False)</code> <code>eigenvecs</code> <code>Array</code> <code>dfield('EigenVectors', default=None, yaml_save=False)</code> <code>eig_cutoff</code> <code>float</code> <code>dfield('cut-off frequency such that eigenvalues smaller than this are set to 0', default=0.01)</code> <code>eig_names</code> <code>list</code> <code>dfield('name to load\\n    eigenvalues/vectors in folder', default=['eigenvals.npy', 'eigenvecs.npy'])</code> <code>grid</code> <code>str | Path | Array | DataFrame</code> <code>dfield('Grid file or array with Nodes Coordinates, node ID in the FEM,\\n        and associated component', default='structuralGrid')</code> <code>Cab_xtol</code> <code>float</code> <code>dfield('Tolerance for building the local frame', default=0.0001)</code> <code>df_grid</code> <code>DataFrame</code> <code>dfield('Data Frame associated to Grid file', init=False)</code> <code>X</code> <code>Array</code> <code>dfield('Grid coordinates', default=None, yaml_save=False)</code> <p>Attributes:</p> Name Type Description <code>Xm</code> <code>Array</code> <code>fe_order</code> <code>list[int] | Array</code> <code>fe_order_start</code> <code>int</code> <code>component_vect</code> <code>list</code> <code>dof_vect</code> <code>list</code> <code>num_nodes</code> <code>int</code> <code>component_names</code> <code>list</code> <code>component_father</code> <code>dict</code> <code>component_nodes</code> <code>dict</code> <code>component_names_int</code> <code>tuple</code> <code>component_father_int</code> <code>tuple</code> <code>component_nodes_int</code> <code>tuple</code> <code>component_chain</code> <code>dict</code> <code>clamped_nodes</code> <code>list</code> <code>freeDoF</code> <code>dict</code> <code>clampedDoF</code> <code>dict</code> <code>total_clampedDoF</code> <code>int</code> <code>constrainedDoF</code> <code>int</code> <code>prevnodes</code> <code>list</code> <code>Mavg</code> <code>Array</code> <code>Mdiff</code> <code>Array</code> <code>Mfe_order</code> <code>Array</code> <code>Mfe_order0s</code> <code>Array</code> <code>Mload_paths</code> <code>Array</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dfem(DataContainer):\n    \"\"\"Finite Element and discretisation model settings \n\n    Parameters\n    ----------\n    connectivity : dict | list\n    folder : str | pathlib.Path\n    Ka_name : str | pathlib.Path\n    Ma_name : str | pathlib.Path\n    Ka : Array\n    Ma : Array\n    Ka0s : Array\n    Ma0s : Array\n    num_modes : int\n    eig_type : str\n    eigenvals : Array\n    eigenvecs : Array\n    eig_cutoff : float\n    eig_names : list\n    grid : str | pathlib.Path | jax.Array | pandas.core.frame.DataFrame\n    Cab_xtol : float\n    df_grid : DataFrame\n    X : Array\n\n    Attributes\n    ----------\n    Xm : Array\n    fe_order : list[int] | jax.Array\n    fe_order_start : int\n    component_vect : list\n    dof_vect : list\n    num_nodes : int\n    component_names : list\n    component_father : dict\n    component_nodes : dict\n    component_names_int : tuple\n    component_father_int : tuple\n    component_nodes_int : tuple\n    component_chain : dict\n    clamped_nodes : list\n    freeDoF : dict\n    clampedDoF : dict\n    total_clampedDoF : int\n    constrainedDoF : int\n    prevnodes : list\n    Mavg : Array\n    Mdiff : Array\n    Mfe_order : Array\n    Mfe_order0s : Array\n    Mload_paths : Array\n\n    Methods\n    -------\n\n\n    \"\"\"\n\n    connectivity: dict | list = dfield(\"Connectivities of components\")\n    folder: str | pathlib.Path = dfield(\n        \"\"\"Folder in which to find Ka, Ma,\n    and grid data (with those names)\"\"\",\n        default=None,\n    )  # yaml_save=False)\n    Ka_name: str | pathlib.Path = dfield(\"Condensed stiffness matrix\", default=\"Ka.npy\")\n    Ma_name: str | pathlib.Path = dfield(\"Condensed mass matrix\", default=\"Ma.npy\")\n    Ka: jnp.ndarray = dfield(\n        \"Condensed stiffness matrix\", default=None, yaml_save=False\n    )\n    Ma: jnp.ndarray = dfield(\"Condensed mass matrix\", default=None, yaml_save=False)\n    Ka0s: jnp.ndarray = dfield(\n        \"Condensed stiffness matrix augmented with 0s\", default=None, yaml_save=False\n    )\n    Ma0s: jnp.ndarray = dfield(\n        \"Condensed mass matrix augmented with 0s\", default=None, yaml_save=False\n    )\n    num_modes: int = dfield(\"Number of modes in the solution\", default=None)\n    eig_type: str = dfield(\n        \"Calculation of eigenvalues/vectors\",\n        default=\"scipy\",\n        options=[\"scipy\", \"jax_custom\", \"inputs, input_memory\"],\n    )\n    eigenvals: jnp.ndarray = dfield(\"EigenValues\", default=None, yaml_save=False)\n    eigenvecs: jnp.ndarray = dfield(\"EigenVectors\", default=None, yaml_save=False)\n    eig_cutoff: float = dfield(\n        \"cut-off frequency such that eigenvalues smaller than this are set to 0\",\n        default=1e-2,\n    )  # -jnp.inf?\n    eig_names: list[str | pathlib.Path] = dfield(\n        \"\"\"name to load\n    eigenvalues/vectors in folder\"\"\",\n        default=[\"eigenvals.npy\", \"eigenvecs.npy\"],\n    )\n    grid: str | pathlib.Path | jnp.ndarray | pd.DataFrame = dfield(\n        \"\"\"Grid file or array with Nodes Coordinates, node ID in the FEM,\n        and associated component\"\"\",\n        default=\"structuralGrid\",\n    )\n    Cab_xtol: float = dfield(\"Tolerance for building the local frame\", default=1e-4)    \n    df_grid: pd.DataFrame = dfield(\"\"\"Data Frame associated to Grid file\"\"\", init=False)\n    X: jnp.ndarray = dfield(\"Grid coordinates\", default=None, yaml_save=False)\n    Xm: jnp.ndarray = dfield(\n        \"Grid coordinates mid-points\", default=None, init=False\n    )\n    fe_order: list[int] | jnp.ndarray = dfield(\"node ID in the FEM\", default=None)\n    fe_order_start: int = dfield(\"fe_order starting with this index\", default=0)\n    component_vect: list[str] = dfield(\n        \"Array with component associated to each node\", default=None\n    )\n    dof_vect: list[str] = dfield(\n        \"Array with DoF associated to each node (for constrained systems)\", default=None\n    )\n    num_nodes: int = dfield(\"Number of nodes\", init=False)\n    num_nodes: int = dfield(\"Number of nodes\", init=False)\n    component_names: list = dfield(\n        \"Name of components defining the structure\", init=False\n    )\n    component_father: dict[str:str] = dfield(\n        \"Map between each component and its father\", init=False\n    )\n    component_nodes: dict[str : list[int]] = dfield(\n        \"Node indexes of the component\", init=False\n    )\n    component_names_int: tuple[int] = dfield(\n        \"Name of components defining the structure\", init=False\n    )\n    component_father_int: tuple[int] = dfield(\n        \"Map between each component and its father\", init=False\n    )\n    component_nodes_int: tuple[list[int]] = dfield(\n        \"Node indexes of the component\", init=False\n    )\n\n    component_chain: dict[str : list[str]] = dfield(\" \", init=False)\n    #\n    clamped_nodes: list[int] = dfield(\"List of clamped or multibody nodes\", init=False)\n    freeDoF: dict[str:list] = dfield(\"Grid coordinates\", init=False)\n    clampedDoF: dict[str:list] = dfield(\"Grid coordinates\", init=False)\n    total_clampedDoF: int = dfield(\"Grid coordinates\", init=False)\n    constrainedDoF: int = dfield(\n        \"whether the analysis presents nodes with some DoF clamped\", init=False\n    )\n    #\n    prevnodes: list[int] = dfield(\"\"\"Immediate previous node following \"\"\", init=False)\n    Mavg: jnp.ndarray = dfield(\"Matrix for tensor average between nodes\", init=False)\n    Mdiff: jnp.ndarray = dfield(\n        \"Matrix for tensor difference between nodes\", init=False\n    )\n    Mfe_order: jnp.ndarray = dfield(\n        \"\"\"Matrix with 1s and 0s that reorders quantities\n    such as eigenvectors in the FE model; nodes in horizontal arrangement.\"\"\",\n        init=False,\n    )\n    Mfe_order0s: jnp.ndarray = dfield(\n        \"\"\"Matrix with 1s and 0s that reorders quantities\n    such as eigenvectors in the FE model; nodes in horizontal arrangement.\"\"\",\n        init=False,\n    )\n    Mload_paths: jnp.ndarray = dfield(\n        \"\"\"Matrix with with 1s and 0s for the load paths\n    that each node, in vertical arrangement, need to transverse to sum up to a free-end.\"\"\",\n        init=False,\n    )\n\n    def __post_init__(self):\n        # set attributes in frozen instance\n        setobj = lambda k, v: object.__setattr__(self, k, v)\n        connectivity = geometry.list2dict(self.connectivity)\n        setobj(\"connectivity\", connectivity)\n        Ka_name, Ma_name, grid = geometry.find_fem(\n            self.folder, self.Ka_name, self.Ma_name, self.grid\n        )\n        setobj(\"Ka_name\", Ka_name)\n        setobj(\"Ma_name\", Ma_name)\n        setobj(\"grid\", grid)\n        if self.folder is not None:\n            setobj(\"folder\", pathlib.Path(self.folder).absolute())\n        if self.Ka is None:\n            if self.folder is None:\n                setobj(\"Ka\", load_jnp(self.Ka_name))\n            else:\n                setobj(\"Ka\", load_jnp(self.folder / self.Ka_name))\n        if self.Ma is None:\n            if self.folder is None:\n                setobj(\"Ma\", load_jnp(self.Ma_name))\n            else:\n                setobj(\"Ma\", load_jnp(self.folder / self.Ma_name))\n                # setobj(\"Ma\", load_jnp(self.Ma_name))\n        if self.num_modes is None:\n            # full set of modes in the solution\n            setobj(\"num_modes\", len(self.Ka))\n        if self.folder is None:\n            df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n                self.grid,\n                self.X,\n                self.fe_order,\n                self.fe_order_start,\n                self.component_vect,\n                self.dof_vect,\n            )\n        else:\n            df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n                self.folder / self.grid,\n                self.X,\n                self.fe_order,\n                self.fe_order_start,\n                self.component_vect,\n                self.dof_vect,\n            )\n        setobj(\"df_grid\", df_grid)\n        setobj(\"X\", X)\n        setobj(\"fe_order\", fe_order)\n        setobj(\"component_vect\", component_vect)\n        setobj(\"dof_vect\", dof_vect)\n        num_nodes = len(self.X)\n        setobj(\"num_nodes\", num_nodes)\n        component_names, component_father = geometry.compute_component_father(\n            self.connectivity\n        )\n        setobj(\"component_names\", component_names)\n        setobj(\"component_father\", component_father)\n        setobj(\"component_nodes\", geometry.compute_component_nodes(self.component_vect))\n        setobj(\n            \"component_chain\",\n            geometry.compute_component_chain(self.component_names, self.connectivity),\n        )\n        clamped_nodes, freeDoF, clampedDoF, total_clampedDoF, constrainedDoF = (\n            geometry.compute_clamped(self.fe_order.tolist(), self.dof_vect)\n        )\n        setobj(\"clamped_nodes\", clamped_nodes)\n        setobj(\"freeDoF\", freeDoF)\n        setobj(\"clampedDoF\", clampedDoF)\n        setobj(\"total_clampedDoF\", total_clampedDoF)\n        setobj(\"constrainedDoF\", constrainedDoF)\n        if constrainedDoF:\n            Ka0s, Ma0s = geometry.compute_Mconstrained(\n                self.Ka, self.Ma, self.fe_order, clamped_nodes, clampedDoF\n            )\n            setobj(\"Ka0s\", Ka0s)\n            setobj(\"Ma0s\", Ma0s)\n        setobj(\n            \"prevnodes\",\n            geometry.compute_prevnode(\n                self.component_vect, self.component_nodes, self.component_father\n            ),\n        )\n        setobj(\"Mavg\", geometry.compute_Maverage(self.prevnodes, self.num_nodes))\n        setobj(\"Xm\", jnp.matmul(self.X.T, self.Mavg))\n        setobj(\"Mdiff\", geometry.compute_Mdiff(self.prevnodes, self.num_nodes))\n        Mfe_order, Mfe_order0s = geometry.compute_Mfe_order(\n            self.fe_order,\n            self.clamped_nodes,\n            self.freeDoF,\n            self.total_clampedDoF,\n            self.component_nodes,\n            self.component_chain,\n            self.num_nodes,\n        )\n        setobj(\"Mfe_order\", Mfe_order)\n        setobj(\"Mfe_order0s\", Mfe_order0s)\n        setobj(\n            \"Mload_paths\",\n            geometry.compute_Mloadpaths(\n                self.component_vect,\n                self.component_nodes,\n                self.component_chain,\n                self.num_nodes,\n            ),\n        )\n        (component_names_int, component_nodes_int, component_father_int) = (\n            geometry.convert_components(\n                self.component_names, self.component_nodes, self.component_father\n            )\n        )\n        setobj(\"component_names_int\", component_names_int)\n        setobj(\"component_nodes_int\", component_nodes_int)\n        setobj(\"component_father_int\", component_father_int)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dlibrary","title":"<code>Dlibrary</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Solution library</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Dlibrary(DataContainer):\n    \"\"\"Solution library\"\"\"\n    function: str = dfield(\"Function wrapper calling the library\", default=None)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DobjectiveArgs","title":"<code>DobjectiveArgs</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for the objective function in the AD</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <code>dfield('Function wrapper calling the library', default=None)</code> <code>nodes</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>t</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>components</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>axis</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numtime</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numnodes</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numcomponents</code> <code>int</code> <code>dfield('', default=6)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, unsafe_hash=True, kw_only=True)\nclass DobjectiveArgs(Dlibrary):\n    \"\"\"Settings for the objective function in the AD\n\n    Parameters\n    ----------\n    function : str\n    nodes : tuple\n    t : tuple\n    components : tuple\n    axis : int\n    _numtime : int\n    _numnodes : int\n    _numcomponents : int\n\n    \"\"\"\n\n\n    nodes: tuple = dfield(\"\", default=None)\n    t: tuple = dfield(\"\", default=None)\n    components: tuple = dfield(\"\", default=None)\n    axis: int = dfield(\"\", default=None)\n    _numtime: int = dfield(\"\", default=None)\n    _numnodes: int = dfield(\"\", default=None)\n    _numcomponents: int = dfield(\"\", default=6)\n\n    def __post_init__(self):\n        if self.nodes is None:\n            object.__setattr__(self, \"nodes\", tuple(range(self._numnodes)))\n        if self.t is None:\n            object.__setattr__(self, \"t\", tuple(range(self._numtime)))\n        if self.components is None:\n            object.__setattr__(self, \"components\", tuple(range(self._numcomponents)))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Drunge_kuttaOde","title":"<code>Drunge_kuttaOde</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Solution settings for Runge-Kutta in-house solvers</p> <p>Parameters:</p> Name Type Description Default <code>solver_name</code> <code>str</code> <code>dfield('', default='rk4')</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Drunge_kuttaOde(Dlibrary):\n    \"\"\"Solution settings for Runge-Kutta in-house solvers\n\n    Parameters\n    ----------\n    solver_name : str\n    \"\"\"\n    solver_name: str = dfield(\"\", default=\"rk4\")\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"ode\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsimulation","title":"<code>Dsimulation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Simulation settings for the management the way each system is run </p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <p>Type of simulation [\"single\", \"serial\", \"parallel\"]</p> <code>dfield('Type of simulation', default='single', options=['single', 'serial', 'parallel'])</code> <code>workflow</code> <code>dict</code> <p>Dictionary that defines which system is run after which. The default None implies systems are run in order of the input</p> <code>dfield('Dictionary that defines which system is run after which.\\n        The default None implies systems are run in order of the input', default=None)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dsimulation(DataContainer):\n    \"\"\"Simulation settings for the management the way each system is run \n\n    Parameters\n    ----------\n    typeof : str\n        Type of simulation [\"single\", \"serial\", \"parallel\"]\n    workflow : dict\n        Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\n    \"\"\"\n\n    typeof: str = dfield(\n        \"Type of simulation\", default=\"single\", options=[\"single\", \"serial\", \"parallel\"]\n    )\n    workflow: dict = dfield(\n        \"\"\"Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\"\"\",\n        default=None,\n    )\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystem","title":"<code>Dsystem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>System settings for the corresponding equations to be solved</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <code>dfield('System name')</code> <code>_fem</code> <code>Dfem</code> <code>dfield('', default=None, yaml_save=False)</code> <code>solution</code> <code>str</code> <code>dfield('Type of solution to be solved', options=['static', 'dynamic', 'multibody', 'stability'])</code> <code>target</code> <code>str</code> <code>dfield('The simulation goal of this system', default='Level', options=_member_names_)</code> <code>bc1</code> <code>str</code> <code>dfield('Boundary condition first node', default='clamped', options=_member_names_)</code> <code>save</code> <code>bool</code> <code>dfield('Save results of the run system', default=True)</code> <code>xloads</code> <code>dict | Dxloads</code> <code>dfield('External loads dataclass', default=None)</code> <code>aero</code> <code>dict | Daero</code> <code>dfield('Aerodynamic dataclass', default=None)</code> <code>t0</code> <code>float</code> <code>dfield('Initial time', default=0.0)</code> <code>t1</code> <code>float</code> <code>dfield('Final time', default=1.0)</code> <code>tn</code> <code>int</code> <code>dfield('Number of time steps', default=None)</code> <code>dt</code> <code>float</code> <code>dfield('Delta time', default=None)</code> <code>t</code> <code>Array</code> <code>dfield('Time vector', default=None)</code> <code>solver_library</code> <code>str</code> <code>dfield('Library solving our system of equations', default=None)</code> <code>solver_function</code> <code>str</code> <code>dfield('Name for the solver of the previously defined library', default=None)</code> <code>solver_settings</code> <code>str</code> <code>dfield('Settings for the solver', default=None)</code> <code>q0treatment</code> <code>int</code> <code>dfield('Modal velocities, q1, and modal forces, q2, are the main variables\\n        in the intrinsic structural description,\\n        but the steady aerodynamics part needs a displacement component, q0;\\n        proportional gain to q2 or  integration of velocities q1\\n        can be used to obtain this.', default=2, options=[2, 1])</code> <code>rb_treatment</code> <code>int</code> <code>dfield('Rigid-body treatment: 1 to use the first node quaternion to track the body\\n        dynamics (integration of strains thereafter; 2 to use quaternions at every node.)', default=1, options=[1, 2])</code> <code>nonlinear</code> <code>bool</code> <code>dfield('whether to include the nonlinear terms in the eqs. (Gammas)\\n        and in the integration', default=1, options=[1, 0, -1, -2])</code> <code>residualise</code> <code>bool</code> <code>dfield('average the higher frequency eqs and make them algebraic', default=False)</code> <code>residual_modes</code> <code>int</code> <code>dfield('number of modes to residualise', default=0)</code> <code>label</code> <code>str</code> <code>dfield('System label that maps to the solution functional', default=None)</code> <code>label_map</code> <code>dict</code> <code>dfield('label dictionary assigning ', default=None)</code> <code>states</code> <code>dict</code> <code>dfield('Dictionary with the state variables.', default=None)</code> <code>num_states</code> <code>int</code> <code>dfield('Total number of states', default=None)</code> <code>init_states</code> <code>dict</code> <code>dfield('Dictionary with initial conditions for each state', default=None)</code> <code>init_mapper</code> <code>dict</code> <code>dfield('Dictionary mapping states types to functions in initcond', default=dict(q1='velocity', q2='force'))</code> <code>ad</code> <code>DtoAD</code> <code>dfield('Dictionary for AD', default=None)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Dsystem(DataContainer):\n    \"\"\"System settings for the corresponding equations to be solved\n\n    Parameters\n    ----------\n    name : str\n    _fem : Dfem\n    solution : str\n    target : str\n    bc1 : str\n    save : bool\n    xloads : dict | __main__.Dxloads\n    aero : dict | __main__.Daero\n    t0 : float\n    t1 : float\n    tn : int\n    dt : float\n    t : Array\n    solver_library : str\n    solver_function : str\n    solver_settings : str\n    q0treatment : int\n    rb_treatment : int\n    nonlinear : bool\n    residualise : bool\n    residual_modes : int\n    label : str\n    label_map : dict\n    states : dict\n    num_states : int\n    init_states : dict\n    init_mapper : dict\n    ad : DtoAD\n\n    \"\"\"\n\n    name: str = dfield(\"System name\")\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n    solution: str = dfield(\n        \"Type of solution to be solved\",\n        options=[\"static\", \"dynamic\", \"multibody\", \"stability\"],\n    )\n    target: str = dfield(\n        \"The simulation goal of this system\",\n        default=\"Level\",\n        options=SimulationTarget._member_names_,\n    )\n    bc1: str = dfield(\n        \"Boundary condition first node\",\n        default=\"clamped\",\n        options=BoundaryCond._member_names_,\n    )\n    save: bool = dfield(\"Save results of the run system\", default=True)\n    xloads: dict | Dxloads = dfield(\"External loads dataclass\", default=None)\n    aero: dict | Daero = dfield(\"Aerodynamic dataclass\", default=None)\n    t0: float = dfield(\"Initial time\", default=0.0)\n    t1: float = dfield(\"Final time\", default=1.0)\n    tn: int = dfield(\"Number of time steps\", default=None)\n    dt: float = dfield(\"Delta time\", default=None)\n    t: jnp.ndarray = dfield(\"Time vector\", default=None)\n    solver_library: str = dfield(\n        \"Library solving our system of equations\", default=None\n    )\n    solver_function: str = dfield(\n        \"Name for the solver of the previously defined library\", default=None\n    )\n    solver_settings: str = dfield(\"Settings for the solver\", default=None)\n    q0treatment: int = dfield(\n        \"\"\"Modal velocities, q1, and modal forces, q2, are the main variables\n        in the intrinsic structural description,\n        but the steady aerodynamics part needs a displacement component, q0;\n        proportional gain to q2 or  integration of velocities q1\n        can be used to obtain this.\"\"\",\n        default=2,\n        options=[2, 1],\n    )\n    rb_treatment: int = dfield(\n        \"\"\"Rigid-body treatment: 1 to use the first node quaternion to track the body\n        dynamics (integration of strains thereafter; 2 to use quaternions at every node.)\"\"\",\n        default=1,\n        options=[1, 2],\n    )\n    nonlinear: bool = dfield(\n        \"\"\"whether to include the nonlinear terms in the eqs. (Gammas)\n        and in the integration\"\"\",\n        default=1,\n        options=[1, 0, -1, -2],\n    )\n    residualise: bool = dfield(\n        \"average the higher frequency eqs and make them algebraic\", default=False\n    )\n    residual_modes: int = dfield(\"number of modes to residualise\", default=0)\n    label: str = dfield(\n        \"\"\"System label that maps to the solution functional\"\"\", default=None\n    )\n    label_map: dict = dfield(\"\"\"label dictionary assigning \"\"\", default=None)\n\n    states: dict = dfield(\"\"\"Dictionary with the state variables.\"\"\", default=None)\n    num_states: int = dfield(\"\"\"Total number of states\"\"\", default=None)\n    init_states: dict[str:list] = dfield(\n        \"\"\"Dictionary with initial conditions for each state\"\"\", default=None\n    )\n    init_mapper: dict[str:str] = dfield(\n        \"\"\"Dictionary mapping states types to functions in initcond\"\"\",\n        default=dict(q1=\"velocity\", q2=\"force\"),\n    )\n    ad: DtoAD = dfield(\"\"\"Dictionary for AD\"\"\", default=None)\n\n    def __post_init__(self):\n        if self.t is not None:\n            object.__setattr__(self, \"t1\", self.t[-1])\n            if (len_t := len(self.t)) &lt; 2:\n                object.__setattr__(self, \"dt\", 0.0)\n            else:\n                object.__setattr__(self, \"dt\", self.t[1] - self.t[0])\n            object.__setattr__(self, \"tn\", len_t)\n        else:\n            if self.dt is not None and self.tn is not None:\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            elif self.tn is not None and self.t1 is not None:\n                object.__setattr__(self, \"dt\", (self.t1 - self.t0) / (self.tn - 1))\n            elif self.t1 is not None and self.dt is not None:\n                object.__setattr__(\n                    self, \"tn\", math.ceil((self.t1 - self.t0) / self.dt + 1)\n                )\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            object.__setattr__(self, \"t\", jnp.linspace(self.t0, self.t1, self.tn))\n\n        object.__setattr__(self, \"xloads\", initialise_Dclass(self.xloads, Dxloads))\n        if self.aero is not None:\n            object.__setattr__(\n                self, \"aero\", initialise_Dclass(self.aero, Daero, time=self.t)\n            )\n        # self.xloads = initialise_Dclass(self.xloads, Dxloads)\n        if self.solver_settings is None:\n            object.__setattr__(self, \"solver_settings\", dict())\n\n        libsettings_class = globals()[\n            f\"D{self.solver_library}{self.solver_function.capitalize()}\"\n        ]\n        object.__setattr__(\n            self,\n            \"solver_settings\",\n            initialise_Dclass(self.solver_settings, libsettings_class),\n        )\n        if self.ad is not None and isinstance(self.ad, dict):\n            libsettings_class = globals()[\"DtoAD\"]\n            object.__setattr__(\n                self,\n                \"ad\",\n                initialise_Dclass(\n                    self.ad,\n                    libsettings_class,\n                    _numtime=len(self.t),\n                    _numnodes=self._fem.num_nodes,\n                ),\n            )\n        if self.label is None:\n            self.build_label()\n\n    def build_states(self, num_modes: int, num_nodes: int):\n        tracker = StateTrack()\n        # TODO: keep upgrading/ add residualise\n        if self.solution == \"static\" or self.solution == \"staticAD\":\n            tracker.update(q2=num_modes)\n            if self.target.lower() == \"trim\":\n                tracker.update(qx=1)\n        elif self.solution == \"dynamic\" or self.solution == \"dynamicAD\":\n            tracker.update(q1=num_modes, q2=num_modes)\n            if self.label_map[\"aero_sol\"] and self.aero.approx.lower() == \"roger\":\n                tracker.update(ql=self.aero.num_poles * num_modes)\n            if self.q0treatment == 1:\n                tracker.update(q0=num_modes)\n            if self.bc1.lower() != \"clamped\":\n                if self.rb_treatment == 1:\n                    tracker.update(qr=4)\n                elif self.rb_treatment == 2:\n                    tracker.update(qr=4 * num_nodes)\n        # if self.solution == \"static\":\n        #     state_dict.update(m, kwargs)\n        object.__setattr__(self, \"states\", tracker.states)\n        object.__setattr__(self, \"num_states\", tracker.num_states)\n\n    def build_label(self):\n        # WARNING: order dependent for the label\n        # nonlinear and residualise should always come last as they are represented\n        # with letters\n        lmap = dict()\n        lmap[\"soltype\"] = SystemSolution[self.solution.upper()].value\n        lmap[\"target\"] = SimulationTarget[self.target.upper()].value - 1\n        if self.xloads.gravity_forces:\n            lmap[\"gravity\"] = \"G\"\n        else:\n            lmap[\"gravity\"] = \"g\"\n        lmap[\"bc1\"] = BoundaryCond[self.bc1.upper()].value - 1\n        lmap[\"aero_sol\"] = int(self.xloads.modalaero_forces)\n        if lmap[\"aero_sol\"] &gt; 0:\n            if self.aero.approx.lower() == \"roger\":\n                lmap[\"aero_sol\"] = 1\n            elif self.aero.approx.lower() == \"loewner\":\n                lmap[\"aero_sol\"] = 2\n            if self.aero.qalpha is None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 0\n            elif self.aero.qalpha is not None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 1\n            elif self.aero.qalpha is None and self.aero.qx is not None:\n                lmap[\"aero_steady\"] = 2\n            else:\n                lmap[\"aero_steady\"] = 3\n            #\n            if self.aero.gust is None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 0\n            elif self.aero.gust is not None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 1\n            elif self.aero.gust is None and self.aero.controller is not None:\n                lmap[\"aero_unsteady\"] = 2\n            else:\n                lmap[\"aero_unsteady\"] = 3\n        else:\n            lmap[\"aero_steady\"] = 0\n            lmap[\"aero_unsteady\"] = 0\n        if self.xloads.follower_forces and self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 3\n        elif self.xloads.follower_forces:\n            lmap[\"point_loads\"] = 1\n        elif self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 2\n        else:\n            lmap[\"point_loads\"] = 0\n        if self.q0treatment == 2:\n            lmap[\"q0treatment\"] = 0\n        elif self.q0treatment == 1:\n            lmap[\"q0treatment\"] = 1\n        if self.nonlinear == 1:\n            lmap[\"nonlinear\"] = \"\"\n        elif self.nonlinear == -1:\n            lmap[\"nonlinear\"] = \"l\"\n        elif self.nonlinear == -2:\n            lmap[\"nonlinear\"] = \"L\"\n        if self.residualise:\n            lmap[\"residualise\"] = \"r\"\n        else:\n            lmap[\"residualise\"] = \"\"\n        labelx = list(lmap.values())\n        label = label_generator(labelx)\n\n        # TODO: label dependent\n        object.__setattr__(self, \"label_map\", lmap)\n        object.__setattr__(self, \"label\", label)  # f\"dq_{label}\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystems","title":"<code>Dsystems</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Input setting for the range of systems in the simulation</p> <p>Parameters:</p> Name Type Description Default <code>sett</code> <code>dict</code> <code>dfield('Settings ', yaml_save=True)</code> <code>mapper</code> <code>dict</code> <code>dfield('Dictionary with systems in the simulation', init=False)</code> <code>borrow</code> <code>dict</code> <code>dfield('Borrow settings from another system:\\n    if there is only one system, then inactive; otherwise default to take settings from\\n    the first system unless specified.\\n    ', default=None)</code> <code>_fem</code> <code>Dfem</code> <code>dfield('', default=None, yaml_save=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dsystems(DataContainer):\n    \"\"\"Input setting for the range of systems in the simulation\n\n    Parameters\n    ----------\n    sett : dict\n    mapper : dict\n    borrow : dict\n    _fem : Dfem\n\n    Attributes\n    ----------\n\n\n    \"\"\"\n\n    sett: dict[str:dict] = dfield(\"Settings \", yaml_save=True)\n    mapper: dict[str:Dsystem] = dfield(\n        \"Dictionary with systems in the simulation\", init=False\n    )\n    borrow: dict[str:str] = dfield(\n        \"\"\"Borrow settings from another system:\n    if there is only one system, then inactive; otherwise default to take settings from\n    the first system unless specified.\n    \"\"\",\n        default=None,\n    )\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n\n    def __post_init__(self):\n        mapper = dict()\n        counter = 0\n        for k, v in self.sett.items():\n            if self.borrow is None:\n                # pass self._fem to the system here, the others should already have\n                # a reference\n                mapper[k] = initialise_Dclass(v, Dsystem, name=k, _fem=self._fem)\n            elif isinstance(self.borrow, str):\n                assert self.borrow in self.sett.keys(), \"borrow not in system names\"\n                if k == self.borrow:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n                else:\n                    v0 = self.sett[self.borrow]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n            else:\n                if k in self.borrow.keys():\n                    v0 = self.sett[self.borrow[k]]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n                else:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n\n            counter += 1\n        object.__setattr__(self, \"mapper\", mapper)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DtoAD","title":"<code>DtoAD</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Algorithm differentiation settings</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <code>dfield('Function wrapper calling the library', default=None)</code> <code>inputs</code> <code>dict</code> <code>dfield('', default=None, yaml_save=False)</code> <code>input_type</code> <code>str</code> <code>dfield('', default=None, options=_member_names_)</code> <code>grad_type</code> <code>str</code> <code>dfield('', default=None, options=['jacrev', 'jacfwd', 'value'])</code> <code>objective_fun</code> <code>str</code> <code>dfield('', default=None)</code> <code>objective_var</code> <code>str</code> <code>dfield('', default=None)</code> <code>objective_args</code> <code>dict</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numnodes</code> <code>int</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numtime</code> <code>int</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numcomponents</code> <code>int</code> <code>dfield('', default=6, yaml_save=False)</code> <code>label</code> <code>str</code> <code>dfield('', default=None, init=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DtoAD(Dlibrary):\n    \"\"\"Algorithm differentiation settings\n\n    Parameters\n    ----------\n    function : str\n    inputs : dict\n    input_type : str\n    grad_type : str\n    objective_fun : str\n    objective_var : str\n    objective_args : dict\n    _numnodes : int\n    _numtime : int\n    _numcomponents : int\n    label : str\n\n    \"\"\"\n\n    inputs: dict = dfield(\"\", default=None, yaml_save=False)\n    input_type: str = dfield(\"\", default=None, options=ADinputType._member_names_)\n    grad_type: str = dfield(\n        \"\",\n        default=None,\n        options=[  # \"grad\", \"value_grad\",\n            \"jacrev\",\n            \"jacfwd\",\n            \"value\",\n        ],\n    )\n    objective_fun: str = dfield(\"\", default=None)\n    objective_var: str = dfield(\"\", default=None)\n    objective_args: dict | DobjectiveArgs  = dfield(\"\", default=None, yaml_save=False)\n    _numnodes: int = dfield(\"\", default=None, yaml_save=False)\n    _numtime: int = dfield(\"\", default=None, yaml_save=False)\n    _numcomponents: int = dfield(\"\", default=6, yaml_save=False)\n    label: str = dfield(\"\", default=None, init=False)\n\n    def __post_init__(self):\n        label = ADinputType[self.input_type.upper()].value\n        object.__setattr__(self, \"label\", label)\n\n        object.__setattr__(\n            self,\n            \"objective_args\",\n            initialise_Dclass(\n                self.objective_args,\n                DobjectiveArgs,\n                _numtime=self._numtime,\n                _numnodes=self._numnodes,\n                _numcomponents=self._numcomponents,\n            ),\n        )\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dxloads","title":"<code>Dxloads</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>External loads settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>follower_forces</code> <code>bool</code> <code>dfield('Include point follower forces', default=False)</code> <code>dead_forces</code> <code>bool</code> <code>dfield('Include point dead forces', default=False)</code> <code>gravity_forces</code> <code>bool</code> <code>dfield('Include gravity in the analysis', default=False)</code> <code>modalaero_forces</code> <code>bool</code> <code>dfield('Include aerodynamic forces', default=False)</code> <code>x</code> <code>Array</code> <code>dfield('x-axis vector for interpolation', default=None)</code> <code>force_follower</code> <code>Array</code> <code>dfield('Point follower forces\\n    (len(x)x6xnum_nodes)', default=None)</code> <code>force_dead</code> <code>Array</code> <code>dfield('Point follower forces\\n    (len(x)x6xnum_nodes)', default=None)</code> <code>follower_points</code> <code>list</code> <code>dfield('Follower force points [Node, coordinate]', default=None)</code> <code>dead_points</code> <code>list</code> <code>dfield('Dead force points [Node, coordinate]', default=None)</code> <code>follower_interpolation</code> <code>list</code> <code>dfield('(Linear) interpolation of the follower forces on t         [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]', default=None)</code> <code>dead_interpolation</code> <code>list</code> <code>dfield('(Linear) interpolation of the dead forces on t         [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]', default=None)</code> <code>gravity</code> <code>float</code> <code>dfield('gravity force [m/s]', default=9.807)</code> <code>gravity_vect</code> <code>Array</code> <code>dfield('gravity vector', default=array([0, 0, -1]))</code> <p>Attributes:</p> Name Type Description <code>Methods</code> <code>-------</code> <code>build_point_follower</code> <code>build_point_dead</code> <code>build_gravity</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dxloads(DataContainer):\n    \"\"\"External loads settings for each system\n\n    Parameters\n    ----------\n    follower_forces : bool\n    dead_forces : bool\n    gravity_forces : bool\n    modalaero_forces : bool\n    x : Array\n    force_follower : Array\n    force_dead : Array\n    follower_points : list\n    dead_points : list\n    follower_interpolation : list\n    dead_interpolation : list\n    gravity : float\n    gravity_vect : Array\n\n    Attributes\n    ----------\n\n    Methods\n    -------\n    build_point_follower\n    build_point_dead\n    build_gravity\n\n    \"\"\"\n    follower_forces: bool = dfield(\"Include point follower forces\", default=False)\n    dead_forces: bool = dfield(\"Include point dead forces\", default=False)\n    gravity_forces: bool = dfield(\"Include gravity in the analysis\", default=False)\n    modalaero_forces: bool = dfield(\"Include aerodynamic forces\", default=False)\n    x: jnp.ndarray = dfield(\"x-axis vector for interpolation\", default=None)\n    force_follower: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    force_dead: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    follower_points: list[list[int, int]] = dfield(\n        \"Follower force points [Node, coordinate]\",\n        default=None,\n    )\n    dead_points: list[list[int, int]] = dfield(\n        \"Dead force points [Node, coordinate]\",\n        default=None,\n    )\n\n    follower_interpolation: list[list[float]] = dfield(\n        \"(Linear) interpolation of the follower forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n    dead_interpolation: list[list[int]] = dfield(\n        \"(Linear) interpolation of the dead forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n\n    gravity: float = dfield(\"gravity force [m/s]\", default=9.807)\n    gravity_vect: jnp.ndarray = dfield(\"gravity vector\", default=jnp.array([0, 0, -1]))\n\n    # gravity_steps: int = dfield(\"steps in which gravity is applied in trim simulation\",\n    #                                    default=1) manage by t\n    # label: str = dfield(\"\"\"Description of the loading type:\n    # '1001' = follower point forces, no dead forces, no gravity, aerodynamic forces\"\"\",\n    #                     init=False)\n    def __post_init__(self):\n        if self.x is not None:\n            object.__setattr__(self, \"x\", jnp.array(self.x))\n        else:\n            object.__setattr__(self, \"x\", jnp.linspace(0, 1, 2))\n        # self.label = f\"{int(self.follower_forces)}\\\n        # {int(self.dead_forces)}{self.gravity_forces}{self.aero_forces}\"\n\n    def build_point_follower(self, num_nodes, C06ab):\n        num_interpol_points = len(self.x)\n        forces = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.follower_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.follower_points[fi][0]\n                dim = self.follower_points[fi][1]\n                forces = forces.at[li, dim, fnode].set(\n                    self.follower_interpolation[fi][li]\n                )  # Nx_6_Nn\n        force_follower = coordinate_transform(forces, C06ab, jax.lax.Precision.HIGHEST)\n        object.__setattr__(self, \"force_follower\", force_follower)\n        # return self.force_follower\n\n    def build_point_dead(self, num_nodes):\n        # TODO: add gravity force, also in modes as M@g\n        num_interpol_points = len(self.x)\n        force_dead = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.dead_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.dead_points[fi][0]\n                dim = self.dead_points[fi][1]\n                force_dead = force_dead.at[li, dim, fnode].set(\n                    self.dead_interpolation[fi][li]\n                )\n        object.__setattr__(self, \"force_dead\", force_dead)\n        # return self.force_dead\n\n    def build_gravity(self, Ma, Mfe_order):\n        num_nodes = Mfe_order.shape[1] // 6\n        num_nodes_out = Mfe_order.shape[0] // 6\n        if self.x is not None and len(self.x) &gt; 1:\n            len_x = len(self.x)\n        else:\n            len_x = 2\n        # force_gravity = jnp.zeros((2, 6, num_nodes))\n        gravity = self.gravity * self.gravity_vect\n        gravity_field = jnp.hstack([jnp.hstack([gravity, 0.0, 0.0, 0.0])] * num_nodes)\n        _force_gravity = jnp.matmul(Mfe_order, Ma @ gravity_field)\n        gravity_interpol = jnp.vstack(\n            [xi * _force_gravity for xi in jnp.linspace(0, 1, len_x)]\n        ).T\n        force_gravity = reshape_field(\n            gravity_interpol, len_x, num_nodes_out\n        )  # Becomes  (len_x, 6, Nn)\n        # num_forces = len(self.dead_interpolation)\n        # for li in range(num_interpol_points):\n        #     for fi in range(num_forces):\n        #         fnode = self.dead_points[fi][0]\n        #         dim = self.dead_points[fi][1]\n        #         force_dead = force_dead.at[li, dim, fnode].set(\n        #             self.dead_interpolation[fi][li])\n        object.__setattr__(self, \"force_gravity\", force_gravity)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.generate_docstring","title":"<code>generate_docstring(cls)</code>","text":"<p>Generate a docstring for a data class based on its fields.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def generate_docstring(cls: Any) -&gt; Any:\n    \"\"\"\n    Generate a docstring for a data class based on its fields.\n    \"\"\"\n    if not is_dataclass(cls):\n        return cls\n\n    lines = [f\"{cls.__name__}:\\n\"]\n    for field in fields(cls):\n        field_type = field.type.__name__ if hasattr(field.type, '__name__') else str(field.type)\n        lines.append(f\"    {field.name} : {field_type}\")\n        # Here you could add more detailed documentation for each field if needed\n    cls.__doc__ = \"\\n\".join(lines)\n    return cls\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.update_docstrings","title":"<code>update_docstrings(module)</code>","text":"<p>Update docstrings for all data classes in the given module.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def update_docstrings(module: Any) -&gt; None:\n    \"\"\"Update docstrings for all data classes in the given module.\"\"\"\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj) and is_dataclass(obj):\n            obj = generate_docstring(obj)\n            print(obj.__doc__)\n</code></pre>"},{"location":"api/modes/","title":"Modes","text":""},{"location":"api/modes/#intrinsic.modes.axis_tilde","title":"<code>axis_tilde(tensor)</code>","text":"<p>Apply tilde0010 to a tensor</p> <p>The input tesor is iterated through axis 2 first, and axis 1 subsequently; tilde0010 is applied to axis 0.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>ndarray</code> <p>3xN1xN2 tensor</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6xN1xN2 tensor</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef axis_tilde(tensor: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Apply tilde0010 to a tensor\n\n    The input tesor is iterated through axis 2 first, and axis 1\n    subsequently; tilde0010 is applied to axis 0.\n\n    Parameters\n    ----------\n    tensor : jnp.ndarray\n        3xN1xN2 tensor\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6xN1xN2 tensor\n\n    \"\"\"\n\n    f1 = jax.vmap(tilde0010, in_axes=1, out_axes=2)\n    f2 = jax.vmap(f1, in_axes=2, out_axes=3)\n    f = f2(tensor)\n\n    return f\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.contraction","title":"<code>contraction(moments, loadpaths, precision)</code>","text":"<p>Sums the moments from the nodal forces along the corresponding load path</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) x num_nodes(moment at the previous index due to forces at this node)</p> required <code>loadpaths</code> <code>ndarray</code> <p>num_node x num_node such that [ni, nj] is 1 or 0 depending on whether ni is a node in the loadpath of nj respectively</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) as the sum of moments due to forces at each node</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef contraction(moments: jnp.ndarray, loadpaths: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Sums the moments from the nodal forces along the corresponding load path\n\n    Parameters\n    ----------\n    moments : jnp.ndarray\n        num_modes x 6 x num_nodes(index) x num_nodes(moment at the\n        previous index due to forces at this node)\n    loadpaths : jnp.ndarray\n        num_node x num_node such that [ni, nj] is 1 or 0 depending on\n        whether ni is a node in the loadpath of nj respectively\n\n    Returns\n    -------\n    jnp.ndarray\n        num_modes x 6 x num_nodes(index) as the sum of moments\n        due to forces at each node\n\n    \"\"\"\n\n    f = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(2, 0), precision=precision),\n        in_axes=(2, 1),\n        out_axes=2,\n    )\n    fuv = f(moments, loadpaths)\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.coordinates_difftensor","title":"<code>coordinates_difftensor(X, Xm, precision)</code>","text":"<p>Computes coordinates</p> <p>The tensor represents the following: Coordinates, middle point of each element, minus the position of each node in the structure</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Grid coordinates</p> required <code>Mavg</code> <code>ndarray</code> <p>Matrix to calculate the averege point between nodes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required <p>Returns:</p> Name Type Description <code>X3</code> <code>jnp.ndarray: (3xNnxNn)</code> <p>Tensor, Xm1 -(X1)' : [Coordinates, Middle point of segment, Node]</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef coordinates_difftensor(X: jnp.ndarray, Xm: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Computes coordinates\n\n    The tensor represents the following: Coordinates, middle point of each element,\n    minus the position of each node in the structure\n\n    Parameters\n    ----------\n    X : jnp.ndarray\n        Grid coordinates\n    Mavg : jnp.ndarray\n        Matrix to calculate the averege point between nodes\n    num_nodes : int\n        Number of nodes\n\n    Returns\n    -------\n    X3 : jnp.ndarray: (3xNnxNn)\n        Tensor, Xm*1 -(X*1)' : [Coordinates, Middle point of segment, Node]\n\n\n    \"\"\"\n\n    # Xm = jnp.matmul(X, Mavg, precision=precision)\n    num_nodes = X.shape[1]\n    ones = jnp.ones(num_nodes)\n    Xm3 = jnp.tensordot(\n        Xm, ones, axes=0, precision=precision\n    )  # copy Xm along a 3rd dimension\n    Xn3 = jnp.transpose(\n        jnp.tensordot(X, ones, axes=0, precision=precision), axes=[0, 2, 1]\n    )  # copy X along the 2nd dimension\n    X3 = Xm3 - Xn3\n    return X3\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh","title":"<code>eigh(a, b)</code>","text":"<p>Compute the solution to the symmetrized generalized eigenvalue problem.</p> <p>a_s @ w = b_s @ w @ np.diag(v)</p> <p>where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the inputs and H is the Hermitian (conjugate transpose) operator.</p> <p>For self-adjoint inputs the solution should be consistent with <code>scipy.linalg.eigh</code> i.e.</p> <p>v, w = eigh(a, b) v_sp, w_sp = scipy.linalg.eigh(a, b) np.testing.assert_allclose(v, v_sp) np.testing.assert_allclose(w, standardize_angle(w_sp))</p> <p>Note this currently uses <code>jax.linalg.eig(jax.linalg.solve(b, a))</code>, which will be slow because there is no GPU implementation of <code>eig</code> and it's just a generally inefficient way of doing it. Future implementations should wrap cuda primitives. This implementation is provided primarily as a means to test <code>eigh_jvp_rule</code>.</p> <p>Args:     a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)     b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)</p> <p>Returns:     v: eigenvalues of the generalized problem in ascending order.     w: eigenvectors of the generalized problem, normalized such that         w.H @ b @ w = I.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jax.custom_jvp  # jax.scipy.linalg.eigh doesn't support general problem i.e. b not None\ndef eigh(a, b):\n    \"\"\"\n    Compute the solution to the symmetrized generalized eigenvalue problem.\n\n    a_s @ w = b_s @ w @ np.diag(v)\n\n    where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the\n    inputs and H is the Hermitian (conjugate transpose) operator.\n\n    For self-adjoint inputs the solution should be consistent with `scipy.linalg.eigh`\n    i.e.\n\n    v, w = eigh(a, b)\n    v_sp, w_sp = scipy.linalg.eigh(a, b)\n    np.testing.assert_allclose(v, v_sp)\n    np.testing.assert_allclose(w, standardize_angle(w_sp))\n\n    Note this currently uses `jax.linalg.eig(jax.linalg.solve(b, a))`, which will be\n    slow because there is no GPU implementation of `eig` and it's just a generally\n    inefficient way of doing it. Future implementations should wrap cuda primitives.\n    This implementation is provided primarily as a means to test `eigh_jvp_rule`.\n\n    Args:\n        a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)\n        b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)\n\n    Returns:\n        v: eigenvalues of the generalized problem in ascending order.\n        w: eigenvectors of the generalized problem, normalized such that\n            w.H @ b @ w = I.\n    \"\"\"\n    a = symmetrize(a)\n    b = symmetrize(b)\n    b_inv_a = jax.scipy.linalg.cho_solve(jax.scipy.linalg.cho_factor(b), a)\n    v, w = jax.jit(jax.numpy.linalg.eig, backend=\"cpu\")(b_inv_a)\n    v = v.real\n    # with loops.Scope() as s:\n    #     for _ in s.cond_range(jnp.isrealobj)\n    if jnp.isrealobj(a) and jnp.isrealobj(b):\n        w = w.real\n    # reorder as ascending in w\n    order = jnp.argsort(v)\n    v = v.take(order, axis=0)\n    w = w.take(order, axis=1)\n    # renormalize so v.H @ b @ H == 1\n    norm2 = jax.vmap(lambda wi: (wi.conj() @ b @ wi).real, in_axes=1)(w)\n    norm = jnp.sqrt(norm2)\n    w = w / norm\n    w = standardize_angle(w, b)\n    return v, w\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh_jvp_rule","title":"<code>eigh_jvp_rule(primals, tangents)</code>","text":"<p>Derivation based on Boedekker et al.</p> <p>https://arxiv.org/pdf/1701.00392.pdf</p> <p>Note diagonal entries of Winv dW/dt != 0 as they claim.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@eigh.defjvp\ndef eigh_jvp_rule(primals, tangents):\n    \"\"\"\n    Derivation based on Boedekker et al.\n\n    https://arxiv.org/pdf/1701.00392.pdf\n\n    Note diagonal entries of Winv dW/dt != 0 as they claim.\n    \"\"\"\n    a, b = primals\n    da, db = tangents\n    if not all(jnp.isrealobj(x) for x in (a, b, da, db)):\n        raise NotImplementedError(\"jvp only implemented for real inputs.\")\n    da = symmetrize(da)\n    db = symmetrize(db)\n\n    v, w = eigh(a, b)\n\n    # compute only the diagonal entries\n    dv = jax.vmap(\n        lambda vi, wi: -wi.conj() @ db @ wi * vi + wi.conj() @ da @ wi,\n        in_axes=(0, 1),\n    )(v, w)\n\n    dv = dv.real\n\n    E = v[jnp.newaxis, :] - v[:, jnp.newaxis]\n\n    # diagonal entries: compute as column then put into diagonals\n    diags = jnp.diag(-0.5 * jax.vmap(lambda wi: wi.conj() @ db @ wi, in_axes=1)(w))\n    # off-diagonals: there will be NANs on the diagonal, but these aren't used\n    off_diags = jnp.reciprocal(E) * (_H(w) @ (da @ w - db @ w * v[jnp.newaxis, :]))\n\n    dw = w @ jnp.where(jnp.eye(a.shape[0], dtype=np.bool), diags, off_diags)\n\n    return (v, w), (dv, dw)\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.make_C6","title":"<code>make_C6(v1)</code>","text":"<p>Given a 3x3xNn tensor, make the diagonal 6x6xNn</p> <p>It iterates over a third dimension in the input tensor</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>A tensor of the form (3x3xNn)</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef make_C6(v1) -&gt; jnp.ndarray:\n    \"\"\"Given a 3x3xNn tensor, make the diagonal 6x6xNn\n\n    It iterates over a third dimension in the input tensor\n\n    Parameters\n    ----------\n    v1 : jnp.ndarray\n        A tensor of the form (3x3xNn)\n\n    \"\"\"\n    f = jax.vmap(\n        lambda v: jnp.vstack(\n            [jnp.hstack([v, jnp.zeros((3, 3))]), jnp.hstack([jnp.zeros((3, 3)), v])]\n        ),\n        in_axes=2,\n        out_axes=2,\n    )\n    fv = f(v1)\n    return fv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.moment_force","title":"<code>moment_force(force, X3t, precision)</code>","text":"<p>Yields moments associated to each node due to the forces</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>ndarray</code> <p>Force tensor (Nmx6xNn) for which we want to obtain the resultant moments</p> required <code>X3t</code> <code>ndarray</code> <p>Tilde positions tensor (6x6xNnxNn)</p> required <p>Returns:</p> Type Description <code>jnp.ndarray: (Nmx6xNnxNn)</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef moment_force(force: jnp.ndarray, X3t: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Yields moments associated to each node due to the forces\n\n    Parameters\n    ----------\n    force : jnp.ndarray\n        Force tensor (Nmx6xNn) for which we want to obtain the\n        resultant moments\n    X3t : jnp.ndarray\n        Tilde positions tensor (6x6xNnxNn)\n\n    Returns\n    -------\n    jnp.ndarray: (Nmx6xNnxNn)\n\n    \"\"\"\n\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(1, 1), precision=precision),\n        in_axes=(None, 2),\n        out_axes=2,\n    )  # tensordot along coordinate axis (len=6)\n    f2 = jax.vmap(f1, in_axes=(2, 3), out_axes=3)\n    fuv = f2(force, X3t)\n\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.reshape_modes","title":"<code>reshape_modes(_phi, num_modes, num_nodes)</code>","text":"<p>Reshapes vectors in the input matrix to form a 3rd-order tensor</p> <p>Each vector is made into a 6xNn matrix</p> <p>Parameters:</p> Name Type Description Default <code>_phi</code> <code>ndarray</code> <p>Matrix as in the output of eigenvector analysis (6NnxNm)</p> required <code>num_modes</code> <code>int</code> <p>Number of modes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"num_modes\", \"num_nodes\"])\ndef reshape_modes(_phi: jnp.ndarray, num_modes: int, num_nodes: int):\n    \"\"\"Reshapes vectors in the input matrix to form a 3rd-order tensor\n\n    Each vector is made into a 6xNn matrix\n\n    Parameters\n    ----------\n    _phi : jnp.ndarray\n        Matrix as in the output of eigenvector analysis (6NnxNm)\n    num_modes : int\n        Number of modes\n    num_nodes : int\n        Number of nodes\n\n\n    \"\"\"\n\n    phi = jnp.reshape(_phi, (num_nodes, 6, num_modes), order=\"C\")\n    return phi.T\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.scale","title":"<code>scale(phi1, psi1, phi2, phi1l, phi1ml, psi1l, phi2l, psi2l, omega, X_xdelta, C0ab, C06ab, *args, **kwargs)</code>","text":"<p>Sacales the intrinsic modes</p> <p>The porpuse is that the integrals alpha1 and alpha2 are the identity</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>ndarray</code> required <code>psi1</code> <code>ndarray</code> required <code>phi2</code> <code>ndarray</code> required <code>phi1l</code> <code>ndarray</code> required <code>phi1ml</code> <code>ndarray</code> required <code>psi1l</code> <code>ndarray</code> required <code>phi2l</code> <code>ndarray</code> required <code>psi2l</code> <code>ndarray</code> required <code>omega</code> <code>ndarray</code> required <code>X_xdelta</code> <code>ndarray</code> required <code>C0ab</code> <code>ndarray</code> required <code>C06ab</code> <code>ndarray</code> required <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>def scale(\n    phi1: jnp.ndarray,\n    psi1: jnp.ndarray,\n    phi2: jnp.ndarray,\n    phi1l: jnp.ndarray,\n    phi1ml: jnp.ndarray,\n    psi1l: jnp.ndarray,\n    phi2l: jnp.ndarray,\n    psi2l: jnp.ndarray,\n    omega: jnp.ndarray,\n    X_xdelta: jnp.ndarray,\n    C0ab: jnp.ndarray,\n    C06ab: jnp.ndarray,\n    *args,\n    **kwargs,\n):\n    \"\"\"Sacales the intrinsic modes\n\n    The porpuse is that the integrals alpha1 and alpha2 are the\n    identity\n\n    Parameters\n    ----------\n    phi1 : jnp.ndarray\n    psi1 : jnp.ndarray\n    phi2 : jnp.ndarray\n    phi1l : jnp.ndarray\n    phi1ml : jnp.ndarray\n    psi1l : jnp.ndarray\n    phi2l : jnp.ndarray\n    psi2l : jnp.ndarray\n    omega : jnp.ndarray\n    X_xdelta : jnp.ndarray\n    C0ab : jnp.ndarray\n    C06ab : jnp.ndarray\n    *args :\n    **kwargs :\n\n\n    \"\"\"\n\n    alpha1 = couplings.f_alpha1(phi1, psi1)\n    alpha2 = couplings.f_alpha2(phi2l, psi2l, X_xdelta)\n    num_modes = len(alpha1)\n    # Broadcasting in division\n    alpha1_diagonal = alpha1.diagonal()\n    alpha2_diagonal = alpha2.diagonal()\n    # filter for rigid-body modes\n    alpha2d_filtered = jnp.where(alpha2_diagonal &gt; 1e-4, alpha2_diagonal, 1.0)\n    phi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1ml /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi2 /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    phi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    psi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n\n    return (\n        phi1,\n        psi1,\n        phi2,\n        phi1l,\n        phi1ml,\n        psi1l,\n        phi2l,\n        psi2l,\n        omega,\n        X_xdelta,\n        C0ab,\n        C06ab,\n    )\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.tilde0010","title":"<code>tilde0010(vector)</code>","text":"<p>Tilde matrix for cross product (moments due to forces)</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>A 3-element array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6 matrix with (3:6 x 0:3) tilde operator</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef tilde0010(vector: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Tilde matrix for cross product (moments due to forces)\n\n    Parameters\n    ----------\n    vector : jnp.ndarray\n        A 3-element array\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6 matrix with (3:6 x 0:3) tilde operator\n\n    \"\"\"\n\n    vector_tilde = jnp.vstack(\n        [jnp.zeros((3, 6)), jnp.hstack([tilde(vector), jnp.zeros((3, 3))])]\n    )\n    return vector_tilde\n</code></pre>"},{"location":"examples/cpc_examples/","title":"JAX-based Aeroelastic Simulation Engine for Differentiable Aircraft Dynamics","text":"<pre><code>#+setupfile: ./config.org\n</code></pre>"},{"location":"examples/cpc_examples/#house-keeping","title":"House keeping","text":""},{"location":"examples/cpc_examples/#load-modules","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = False\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/cpc_examples/#plotting","title":"Plotting","text":""},{"location":"examples/cpc_examples/#helper-functions","title":"Helper functions","text":"<pre><code>print(f\"Format for figures: {figfmt}\")\ndef fig_out(name, figformat=figfmt, update_layout=None):\n    def inner_decorator(func):\n        def inner(*args, **kwargs):\n            fig = func(*args, **kwargs)\n            if update_layout is not None:\n                fig.update_layout(**update_layout)\n            fig.show()\n            figname = f\"figs/{name}.{figformat}\"\n            fig.write_image(f\"../{figname}\", scale=6)\n            return fig, figname\n        return inner\n    return inner_decorator\n\n\ndef fig_background(func):\n\n    def inner(*args, **kwargs):\n        fig = func(*args, **kwargs)\n        # if fig.data[0].showlegend is None:\n        #     showlegend = True\n        # else:\n        #     showlegend = fig.data[0].showlegend\n\n        fig.update_xaxes(\n                       titlefont=dict(size=20),\n                       tickfont = dict(size=20),\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n            #zeroline=True,\n        #zerolinewidth=2,\n            #zerolinecolor='LightPink',\n                       gridcolor='lightgrey')\n        fig.update_yaxes(tickfont = dict(size=20),\n                       titlefont=dict(size=20),\n                       zeroline=True,\n                       mirror=True,\n                       ticks='outside',\n                       showline=True,\n                       linecolor='black',\n                       gridcolor='lightgrey')\n        fig.update_layout(plot_bgcolor='white',\n                          yaxis=dict(zerolinecolor='lightgrey'),\n                          showlegend=True, #showlegend,\n                          margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=0,\n                              t=2,\n                              b=0\n                          ))\n        return fig\n    return inner\n\n@fig_background\ndef plot_ffb_times(modes, y1, y2, label1, label2):\n\n    fig = None\n    fig = uplotly.lines2d(modes, y1, fig,\n                              dict(name=label1,\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n\n    fig = uplotly.lines2d(modes, y2, fig,\n                          dict(name=label2,\n                               line=dict(color=\"red\")\n                               ),\n                          dict())          \n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=8)\n    fig.update_layout(legend=dict(x=0.7, y=0.95),\n                      height=650,\n                      xaxis_title='Num. modes',\n                      yaxis_title='Computational times [s]')\n    return fig\n\n@fig_background\ndef plot_ffb_error(modes, y1, label1):\n\n    fig = None\n    fig = uplotly.lines2d(modes, y1, fig,\n                              dict(name=label1,\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=8)\n    fig.update_layout(showlegend=False,\n                      #height=800,\n                      xaxis_title='Num. modes',\n                      yaxis_title='Cg error')\n    return fig\n\n@fig_background\ndef xrf1_wingtip2(sol1, sol2, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                  sol1.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                  sol2.data.dynamicsystem_s1.ra,\n                                  fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[:], (y1[:]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[0]}\",\n                               line=dict(color=\"orange\")\n                               ))\n    fig = uplotly.lines2d(x2[1:], (y2[:-1]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-G{labels[1]}\",\n                               line=dict(color=\"steelblue\")\n                               ))\n\n    if nast_scale is not None:\n        offset = 0. #u111m[nast_load[0],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[0]], (u111m[nast_load[0],:,-1, dim] - offset)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[0]}\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\",\n                                             width=1.5)\n                                   ))\n        offset2 = 0. #u111m[nast_load[1],0,-1, dim]\n        fig = uplotly.lines2d(t111m[nast_load[1]], (u111m[nast_load[1],:,-1, dim] - offset2)*nast_scale*scale, fig,\n                              dict(name=f\"Lin. FE-G{labels[1]}\",\n                                   line=dict(color=\"red\",\n                                             dash=\"dot\",\n                                             width=1.5)\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n\ndef subplots_wtips(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        specs=[[{\"colspan\": 2}, None],\n                               [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=2, col=2\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\ndef subplots_wtips2(fun, *args, **kwargs):\n\n    fig1 = fun(*args, dim=0, **kwargs)\n    fig2 = fun(*args, dim=1, **kwargs)\n    fig3 = fun(*args, dim=2, **kwargs)\n    fig3.update_xaxes(title=None)\n    fig2.update_xaxes(title=None)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig1.layout.xaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig1.layout.yaxis,row=3, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1,titlefont=dict(size=15),\n                       tickfont = dict(size=15))\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    fig.update_layout(legend=dict(x=0.81, y=1))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n\ndef subplots_xrf1wtips(sol1, sol2, labels=None, nast_scale=None, nast_load=None):\n\n    fig1 = xrf1_wingtip2(sol1, sol2, 0, labels,nast_scale, nast_load)\n    fig2 = xrf1_wingtip2(sol1, sol2, 1, labels,nast_scale, nast_load)\n    fig3 = xrf1_wingtip2(sol1, sol2, 2, labels,nast_scale, nast_load)\n    fig = make_subplots(rows=3, cols=1, horizontal_spacing=0.135, vertical_spacing=0.1,\n                        # specs=[[{\"colspan\": 2}, None],\n                        #       [{}, {}]]\n                        )\n\n    # fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.1, vertical_spacing=0.1,\n    #                    specs=[[{\"colspan\": 2}, None],\n    #                           [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=3, col=1\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\n@fig_background\ndef xrf1_wingtip4(sol1, sol2, sol3, sol4, dim, labels=None,nast_scale=None, nast_load=None):\n    scale = 1./33.977\n    fig=None\n    x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,\n                                    sol1.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,\n                                    sol2.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x3, y3 = putils.pickIntrinsic2D(sol3.data.dynamicsystem_s1.t,\n                                    sol3.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n    x4, y4 = putils.pickIntrinsic2D(sol4.data.dynamicsystem_s1.t,\n                                    sol4.data.dynamicsystem_s1.ra,\n                                    fixaxis2=dict(node=150, dim=dim))\n\n    fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[0]}\",\n                               line=dict(color=\"orange\",\n                                         dash=\"solid\")\n                               ))\n    fig = uplotly.lines2d(x2[:], (y2[:]-y2[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[1]}\",\n                               line=dict(color=\"blue\", dash=\"dot\")\n                               ))\n    fig = uplotly.lines2d(x3[:], (y3[:]-y3[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[2]}\",\n                               line=dict(color=\"red\")\n                               ))\n    fig = uplotly.lines2d(x4[:], (y4[:]-y4[0])*scale, fig,\n                          dict(name=f\"NMROM-{labels[3]}\",\n                               line=dict(color=\"grey\", dash=\"dash\")\n                               ))\n\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large u_%s / l$'%dim_dict[dim])\n    fig.update_xaxes(range=[0, 4], title=r'$\\large time \\; [s]$')\n    return fig\n\n@fig_background\ndef wsp_wingtip(sol_list, dim, labels=None, nast_load=None, axes=None,\n                modes = [5, 15, 30, 50, 100],scale = 1./28.8):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.ra,\n                                      fixaxis2=dict(node=23, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{modes[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    if nast_load is not None:\n        fig = uplotly.lines2d(t_wsp[nast_load], u_wsp[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-NL\",\n                                   line=dict(color=\"black\",\n                                             dash=\"dash\")\n                                   ))\n        fig = uplotly.lines2d(t_wspl[nast_load], u_wspl[nast_load,:,-4, dim]* scale, fig,\n                              dict(name=\"FullFE-Lin\",\n                                   line=dict(color=\"orange\",\n                                             #dash=\"dash\"\n                                             )\n                                   ))\n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    if axes is None:\n        fig.update_yaxes(title=r'$\\Large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=[0, 15], title='$\\large time \\; [s]$')\n    else:\n        fig.update_yaxes(range=axes[1], title=r'$\\large u_%s / l$'%dim_dict[dim])\n        fig.update_xaxes(range=axes[0], title='$\\large time \\; [s]$')\n\n    return fig\n\n@fig_background\ndef wsp_rootload(sol_list, dim,\n                 labels = ['0.5', '1.', '1.5'], nodei=2, scale = 1e-3):\n\n    fig = None\n    colors=[\"red\", \"darkgreen\",\n            \"steelblue\", \"magenta\", \"blue\"]\n    dash = ['dash', 'dot', 'dashdot']\n\n    for i, si in enumerate(sol_list):\n        x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                      si.data.dynamicsystem_s1.X2,\n                                      fixaxis2=dict(node=nodei, dim=dim))\n        if i != len(sol_list) - 1:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i],\n                                               dash=dash[i % 3])\n                                     ),\n                                dict())\n        else:\n          fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,\n                                dict(name=f\"NMROM-{labels[i]}\",\n                                     line=dict(color=colors[i])\n                                     ),\n                                dict())              \n    dim_dict = {0:'x', 1:'y', 2:'z'}\n    fig.update_yaxes(title=r'$\\large f_%s \\; [MN/m]$'%(dim+1))\n    fig.update_xaxes(range=[0, 10], title='$\\large time \\; [s]$')\n\n    return fig\n\ndef subplots_wsp(sol_list, labels=None, nast_load=None, axes=None):\n\n    fig1 = wsp_wingtip(sol_list, 0, labels, nast_load, axes)\n    fig2 = wsp_wingtip(sol_list, 1, labels, nast_load, axes)\n    fig3 = wsp_wingtip(sol_list, 2, labels, nast_load, axes)\n    fig = make_subplots(rows=2, cols=2, horizontal_spacing=1, vertical_spacing=5,\n                        specs=[[{\"colspan\": 2}, None],\n                               [{}, {}]])\n    for i, f3i in enumerate(fig3.data):\n        fig.add_trace(f3i,\n                      row=1, col=1\n                      )\n    for i, f1i in enumerate(fig1.data):\n        f1inew = f1i\n        f1inew.showlegend = False          \n        fig.add_trace(f1inew,\n                      row=2, col=1\n                      )\n    for i, f2i in enumerate(fig2.data):\n        f2inew = f2i\n        f2inew.showlegend = False          \n        fig.add_trace(f2inew,\n                      row=2, col=2\n                      )\n\n    fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)\n    fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)\n    fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)\n    fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)\n    fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)\n    fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)\n    fig.update_layout(plot_bgcolor='white',\n                      yaxis=dict(zerolinecolor='lightgrey'),\n                      showlegend=True, #showlegend,\n                      margin=dict(\n                          autoexpand=True,\n                          l=0,\n                          r=0,\n                          t=2,\n                          b=0\n                          ))\n    #fig.update_layout(showlegend=False,row=2, col=1)\n    # fig.update_layout(showlegend=False,row=2, col=2)\n    #fig.update_layout(fig1.layout)\n    return fig\n\ndef fn_spErrorold(sol_list, config, print_info=True):\n\n  sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n  err = {f\"M{i}_L{j}\": 0. for i in range(1,6) for j in range(6)}\n  for li in range(6): # loads\n    for mi in range(1,6):  # modes\n      count = 0  \n      for index, row in config.fem.df_grid.iterrows():\n        r_spn = u_sp[li, row.fe_order,:3] + config.fem.X[index]\n        r_sp = sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index]\n        err[f\"M{mi}_L{li}\"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)\n        # print(f\"nas = {r_spn}  ,  {r_sp}\")\n        count += 1\n      err[f\"M{mi}_L{li}\"] /= count\n      if print_info:\n          print(f\"**** LOAD: {li}, NumModes: {mi} ****\")\n          print(err[f\"M{mi}_L{li}\"])\n  return err\n\ndef fn_spError(sol_list, config, print_info=True):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    err = {f\"M{i}_L{j}\": 0. for i in range(1,6) for j in range(6)}\n    for li in range(6): # loads\n      for mi in range(1,6):  # modes\n        count = 0\n        r_spn = []\n        r_sp = []\n        for index, row in config.fem.df_grid.iterrows():\n          r_spn.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n          r_sp.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n        r_spn = jnp.array(r_spn)\n        r_sp = jnp.array(r_sp)        \n        err[f\"M{mi}_L{li}\"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)\n        err[f\"M{mi}_L{li}\"] /= len(r_sp)\n        if print_info:\n            print(f\"**** LOAD: {li}, NumModes: {mi} ****\")\n            print(err[f\"M{mi}_L{li}\"])\n    return err\n\ndef fn_spWingsection(sol_list, config):\n\n    sol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\n    r_spn = []\n    r_spnl = []\n    r_sp = []\n    for li in range(6): # loads\n      for mi in [4]:#range(1,6):  # modes\n        r_spni = []\n        r_spnli = []\n        r_spi = []\n        r_sp0 = []\n        for index, row in config.fem.df_grid.iterrows():\n          if row.fe_order in list(range(20)):\n            r_sp0.append(config.fem.X[index])  \n            r_spni.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])\n            r_spnli.append(u_spl[li, row.fe_order,:3] + config.fem.X[index])\n            r_spi.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])\n          # print(f\"nas = {r_spn}  ,  {r_sp}\")\n          # count += 1\n\n        r_spn.append(jnp.array(r_spni))\n        r_spnl.append(jnp.array(r_spnli))\n        r_sp.append(jnp.array(r_spi))\n    r_sp0 = jnp.array(r_sp0)\n    return r_sp0, r_sp, r_spn, r_spnl\n\n@fig_background\ndef plot_spWingsection(r0, r, rn, rnl):\n    fig = None\n    # colors=[\"darkgrey\", \"darkgreen\",\n    #         \"blue\", \"magenta\", \"orange\", \"black\"]\n    # dash = ['dash', 'dot', 'dashdot']\n    modes = [5, 15, 30, 50, 100]\n    for li in range(6):\n      if li == 0:   \n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"NMROM\",\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-NL\",\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(name=f\"FullFE-Lin\",\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())\n\n      else:\n          fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"blue\",\n                                               dash=\"solid\")\n                                     ),\n                                  dict())\n          fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"black\",\n                                               dash=\"dash\")\n                                     ),\n                                dict())\n          fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,\n                                dict(showlegend=False,\n                                     line=dict(color=\"orange\",\n                                               dash=\"solid\")\n                                     ),\n                                dict())            \n    fig.update_yaxes(title=r'$\\large u_z [m]$')\n    fig.update_xaxes(title=r'$\\large S [m]$', range=[6.81,36])\n    fig.update_layout(legend=dict(x=0.6, y=0.95),\n                      font=dict(size=20))\n    # fig = uplotly.lines2d((rnl[:,0]**2 + rnl[:,1]**2)**0.5, rnl[:,2], fig,\n    #                       dict(name=f\"NASTRAN-101\",\n    #                            line=dict(color=\"grey\",\n    #                                      dash=\"solid\")\n    #                                  ),\n    #                             dict())\n    return fig\n\n@fig_background\ndef fn_spPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    e250 = jnp.array([error[f'M{i}_L1'] for i in range(1,6)])\n    e400 = jnp.array([error[f'M{i}_L3'] for i in range(1,6)])\n    e530 = jnp.array([error[f'M{i}_L5'] for i in range(1,6)])\n    fig = None\n    fig = uplotly.lines2d(num_modes, e250 , fig,\n                              dict(name=\"F = 250 KN\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e400, fig,\n                              dict(name=\"F = 400 KN\",\n                                   line=dict(color=\"green\", dash=\"dash\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, e530, fig,\n                              dict(name=\"F = 530 KN\",\n                                   line=dict(color=\"black\", dash=\"dot\")\n                                   ),\n                              dict())\n    fig.update_xaxes(title= {'font': {'size': 20}, 'text': 'Number of modes'})#title=\"Number of modes\",title_font=dict(size=20))\n    fig.update_yaxes(title=r\"$\\Large \\epsilon$\",type=\"log\", # tickformat= '.1r',\n                     tickfont = dict(size=12), exponentformat=\"power\",\n                     #dtick=0.2,\n                     #tickvals=[2e-2, 1e-2, 7e-3,5e-3,3e-3, 2e-3, 1e-3,7e-4, 5e-4,3e-4, 2e-4, 1e-4, 7e-5, 5e-5]\n                     )\n    #fig.update_layout(height=650)\n    fig.update_layout(legend=dict(x=0.7, y=0.95), font=dict(size=20))\n\n    return fig\n\n@fig_background\ndef fn_spPloterror3D(error, error3d):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    if error is not None:\n      fig = uplotly.lines2d(loads, error, fig,\n                                dict(name=\"Error ASET\",\n                                     line=dict(color=\"red\"),\n                                     marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n    fig = uplotly.lines2d(loads, error3d, fig,\n                              dict(name=\"Error full 3D\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      # showlegend=False,\n                      #legend=dict(x=0.7, y=0.95),\n                      xaxis_title='Loading [KN]',\n                      yaxis_title=r'$\\Large \\epsilon$')\n\n    return fig\n\n@fig_background\ndef plot_spAD(rn, r0):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    fig = None\n    x = list(range(1,7))\n    y = [rn[i-1][-1, 2] - r0[-1,2] for i in x]\n    fig = uplotly.lines2d(x, y, fig,\n                                dict(#name=\"Error ASET\",\n                                     #line=dict(color=\"red\"),\n                                     #marker=dict(symbol=\"square\")\n                                     ),\n                                dict())\n\n\n    #fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    fig.update_layout(#height=700,\n                      showlegend=False,\n                      xaxis_title=r'$\\Large{\\tau}$',\n                      yaxis_title='Uz [m]'\n    )\n\n    return fig\n\ndef fn_wspError(sol_list):\n    error_dict = dict()\n    for i, si in enumerate(sol_list):\n        for di in range(3):\n            x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,\n                                          si.data.dynamicsystem_s1.ra,\n                                          fixaxis2=dict(node=23, dim=di))\n            yinterp = jnp.interp(t_wsp, x, y)\n            ynastran = u_wsp[0,:,-4, di] + y[0]\n            n = 10000\n            error = jnp.linalg.norm((yinterp[1,:n] - ynastran[:n]) / ynastran[:n]) / len(ynastran[:n])\n            label = f\"M{i}x{di}\"\n            error_dict[label] = error\n\n    return error_dict\n\n@fig_background\ndef fn_wspPloterror(error):\n\n    loads = [200, 250, 300, 400, 480, 530]\n    num_modes = [5, 15, 30, 50, 100]\n    ex1 = [error[f'M{i}x0'] for i in range(5)]\n    ex2 = [error[f'M{i}x1'] for i in range(5)]\n    ex3 = [error[f'M{i}x2'] for i in range(5)]\n    fig = None\n    fig = uplotly.lines2d(num_modes, ex1, fig,\n                              dict(name=\"Error - x1\",\n                                   line=dict(color=\"red\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex2, fig,\n                              dict(name=\"Error - x2\",\n                                   line=dict(color=\"green\")\n                                   ),\n                              dict())\n    fig = uplotly.lines2d(num_modes, ex3, fig,\n                              dict(name=\"Error - x3\",\n                                   line=dict(color=\"black\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e')\n    return fig\n\n@fig_background\ndef fn_wspPloterror3D(time, error):\n\n    fig = None\n    fig = uplotly.lines2d(time, error, fig,\n                              dict(name=\"Error\",\n                                   line=dict(color=\"blue\")\n                                   ),\n                              dict())\n\n    fig.update_yaxes(type=\"log\", tickformat= '.0e', nticks=7)\n    fig.update_layout(\n                      #height=700,\n                      xaxis_title=r'$\\Large time [s]$',\n                      yaxis_title=r'$\\Large \\epsilon$')\n    return fig\n</code></pre>"},{"location":"examples/cpc_examples/#nastran-data","title":"NASTRAN data","text":"<p>Read data from Nastran simulations</p> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n\n\nexamples_path = pathlib.Path(\"../../../../examples\")\n####### SailPlane ###########\nSP_folder = examples_path / \"SailPlane\"\n#nastran_path = wingSP_folder / \"NASTRAN/\"\n\nop2model = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run.op2\",\n                                   SP_folder / \"NASTRAN/static400/run.bdf\",\n                                 static=True)\n\nop2model.readModel()\nt_sp, u_sp = op2model.displacements()\n\nop2modell = op2reader.NastranReader(SP_folder / \"NASTRAN/static400/run_linear.op2\",\n                                   SP_folder / \"NASTRAN/static400/run_linear.bdf\",\n                                 static=True)\n\nop2modell.readModel()\nt_spl, u_spl = op2modell.displacements()\n\n####### wingSP ###########\nwingSP_folder = examples_path / \"wingSP\"\nnastran_path = wingSP_folder / \"NASTRAN/\"\nnas_wspl = op2reader.NastranReader(op2name=(nastran_path / \"wing_109d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wspl.readModel()\nt_wspl, u_wspl = nas_wspl.displacements()  \n# ###\nnas_wsp = op2reader.NastranReader(op2name=(nastran_path / \"wing400d.op2\"),\n                                   bdfname=(nastran_path / \"wing_109b.bdf\"))\nnas_wsp.readModel()\nt_wsp, u_wsp = nas_wsp.displacements()\n####### XRF1 ###########\nnastran_path = examples_path / \"XRF1/NASTRAN/146-111/\"\nnas111 = op2reader.NastranReader(op2name=(nastran_path / \"XRF1-146run.op2\"))\nnas111.readModel()\nt111, u111 = nas111.displacements()\n\nnastran_pathm = examples_path / \"XRF1/NASTRAN/146-111_081\"\nnas111m = op2reader.NastranReader(op2name=(nastran_pathm / \"XRF1-146run.op2\"))\nnas111m.readModel()\nt111m, u111m = nas111m.displacements()\n\nsp_error3d = jnp.load(examples_path/ \"SailPlane/sp_err.npy\")\nwsp_error3d = jnp.load(examples_path/ \"wingSP/wsp_err.npy\")\n</code></pre>"},{"location":"examples/cpc_examples/#examples","title":"Examples","text":"<p>The cases presented are a demonstration of our solution approach to manage geometric nonlinearities, the accuracy of the solvers when compared to full FE simulations, and the computational gains that can be achieved. All computations are carried out on a single CPU with an i7-6700 processor of 3.4 GHz clock speed.</p>"},{"location":"examples/cpc_examples/#structural-verification-of-a-representative-configuration","title":"Structural verification of a representative configuration","text":"<p>A representative FE model of a full aircraft without engines is used to demonstrate a versatile solution that accounts for geometric nonlinearities in a very efficient manner and only needs modal shapes and linear FE matrices from a generic FE solver as inputs. Another of the goals set for this work was to achieve an equally flexible strategy in the automatic calculation of derivatives across the various solvers in the code. The structural static and dynamic responses and their sensitivities with respect to input parameters are verified against MSC Nastran and finite differences respectively.\\ The aircraft's main wing is composed of wing surfaces, rear and front spars, wing box and ribs with composite materials employed in the construction. Flexible tail and rear stabiliser are rigidly attached to the wing (28.8 m of span), as shown in Fig. 1. This aircraft was first used in cite:&amp;CEA2021a and is a good test case as it is not very complex yet representative of aircraft FE models and it is available open source.</p> <p>{#fig:SailPlane2}</p> <p>A Guyan reduction is employed in the reduction process and Fig. 2 illustrates the accuracy of the condensed model by comparing the 3D modal shapes. No differences can be appreciated for the first few modes (the lowest frequency corresponding to a bending mode agrees in both models at $\\omega_1=4.995$ rads/s), so we show higher frequency modes: a high order bending mode ($\\omega_{10}=60.887/60.896$ rads/s in full versus reduced models) and a torsional mode ($\\omega_{20}=107.967/107.969$ rads/s). This very good preservation of the full model leads to an excellent accuracy in the static and dynamic results presented below. It is important to remark this aircraft model is typical of previous generations airliners and does not feature high-aspect ratio wings. Therefore while this modelling strategy would not be suitable for every engineering structure, as long as there is a dominant dimension and deformations in the other two remain small (as is the case in high level descriptions of aircraft, bridges or wind turbines) it has been found to produce very good approximations when compared with full dimensional solutions.</p> <p><pre><code>#+name: fig:modes2\n</code></pre> <pre><code>#+caption: Full VS reduced order models on the 10th modal shape $\\omega_{10}=60.887/60.896$ rads/s\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:figs_ext/SPM7af2.pdf</p> <p><pre><code>#+name: fig:modes\n</code></pre> <pre><code>#+caption: Full VS reduced order models on the 20th modal shape, $\\omega_{20}=107.97$ rads/s\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:figs_ext/SPM19af2.pdf</p>"},{"location":"examples/cpc_examples/#geometrically-nonlinear-static-response","title":"Geometrically nonlinear static response","text":"<p>The static equilibrium of the aircraft under prescribed loads is first studied with follower loads normal to the wing applied at the tip of each wing (nodes 25 and 48). The response for an increasing load stepping of 200, 300, 400, 480 and 530 KN is computed. The snippet of the inputs and simulation call are given in Listing <code>\\ref{code:static}</code>{=latex}.</p> <p> </p> <p>Nonlinear static simulations on the original full model (before condensation) are also carried out in MSC Nastran and are included. The interpolation elements in the full FE solver are used to output the displacements at the condensation nodes for direct comparison with the NMROM results. Geometric nonlinearities are better illustrated by representing a sectional view of the wing as in Fig. 2, where deformations in the z-direction versus the metric $S = \\sqrt{x^2+y^2}$ are shown. MSC Nastran linear solutions (Solution 101) are also included to appreciate more clearly the shortening and follower force effects in the nonlinear computations.</p> <pre><code>import feniax.preprocessor.configuration as configuration\nconfig = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nr_sp0, r_sp, r_spn, r_spnl = fn_spWingsection(sol_sp, config)\nfig, figname = fig_out(name)(plot_spWingsection)(r_sp0, r_sp, r_spn, r_spnl)\nfigname\n</code></pre> <p>{#fig:SPWingsection}</p> <p>The tolerance in the Newton solver was set to $10^{-6}$ in all cases. A convergence analysis with the number of modes in the solution is presented in Fig. 3. 5, 15, 30, 50, 100 modes are used to build the corresponding NMROMs. The error metric is defined as the $\\ell^2$ norm divided by the total number of nodes (only the condenses ones in this case): $\\epsilon = ||u_{NMROM} - u_{NASTRAN}||/N_{nodes}$. It can be seen the solution with 50 modes already achieves a very good solution even for the largest load which produces a 25.6$\\%$ tip deformation of the wing semi-span, $b = 28.8$ m. The displacement difference with the full FE solution at the tip in this case is less than 0.2$\\%$.</p> <pre><code>config = configuration.Config.from_file(\"SP1/config.yaml\")\nsol_sp= [solution.IntrinsicReader(f\"./SP{i}\") for i in range(1,6)]\nsp_error = fn_spError(sol_sp, config, print_info=True)\nfig, figname = fig_out(name)(fn_spPloterror)(sp_error)\nfigname\n</code></pre> <p>{#SPstatic_convergence}</p> <p>The 3D structural response has been reconstructed using the approach in Fig. . The nodes connected by the interpolation elements (RBE3s) to the ASET solution are reconstructed first and subsequently a model with RBFs kernels is used to extrapolate to the rest of the nodes in the full FE. A very good agreement is found against the geometrically-nonlinear Nastran solution (SOL 400). Fig. 4 shows the overlap in the Nastran solution (in red) and the NMROM (in blue) for the 530 KN loading.</p> <p><pre><code>#+name: SPstatic_3D\n</code></pre> <pre><code>#+caption: Static 3D solution for a solution with 50 modes and 530 KN loading (Full NASTRAN solution in red versus the NMROM in blue).\n</code></pre> <pre><code>#+attr_latex: :width 0.7\\textwidth\n</code></pre>  The error metric of this 3D solution is also assessed in Fig. 4, for the solution with 50 modes. The discrepancy metric is of the same order than the previously shown at the reduction points. This conveys an important point, that there is no significant accuracy loss in the process of reconstructing the 3D solution.</p> <pre><code>sp_error1D = [sp_error[f'M4_L{i}'] for i in range(6)]\n# fig, figname = fig_out(name)(fn_spPloterror3D)(sp_error1D, sp_error3d)\nfig, figname = fig_out(name,update_layout=dict(showlegend=False))(fn_spPloterror3D)(None, sp_error3d)\nfigname\n</code></pre> <p>{#fig:SPerror3D}</p> <p>Next we compare the computational times for the various solutions presented in this section in Table 1. Computations of the six load steps in Fig. 2 are included in the assessment. A near 50 times speed-up is achieved with our solvers compared to Nastran nonlinear solution, which is one of the main strengths of the proposed method. As expected, the linear static solution in Nastran is the fastest of the results, given it only entails solving a linear, very sparse system of equations.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'SP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [5*60 + 45]\nvalues += [1.02]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 101\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 101\n</code></pre> <p>Time    1.97, 2.05, 2.13, 2.17, 2.3         345           1.02</p> <pre><code>           NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 101\n</code></pre> <p>Time    6.7, 6.63, 6.79, 7.06, 9.55         345           1.02</p> <p>: Computational times static solution {#table:SP_times}</p>"},{"location":"examples/cpc_examples/#differentiation-of-static-response","title":"Differentiation of static response","text":"<p>The AD for the static solvers is first verified as follows: the load stepping shown above becomes a pseudo-time interpolation load such that a variable $\\tau$ controls the amount of loading and we look at the variation of the wing-tip displacement as a function of this $\\tau$. If $f(\\tau=[1, 2, 3, 4, 5, 6]) = [200, 250, 300, 400, 480, 530]$ KN, with a linear interpolation between points, the derivative of the z-component of the tip of the wing displacement is computed at $\\tau= 1.5, 3.5, 5.5 $, as show in Fig. 5 where the $y$-axis is the tip displacement, $\\tau$ is in the $x$-axis and the big red circles the points where the derivatives are computed (coincident to the graph slope at those points).</p> <pre><code>fig, figname = fig_out(name)(plot_spAD)(r_sp, r_sp0)\n#figname\n</code></pre> <p><pre><code>#+results: SP_AD\n</code></pre> file:</p> <p><pre><code>#+name: fig:sp_ad\n</code></pre> <pre><code>#+caption: Static tip displacement with pseudo-time stepping load\n</code></pre> <pre><code>#+attr_latex: :width 0.5\\textwidth\n</code></pre>  Table 2 shows a very good agreement against finite-differences (FD) with an epsilon of $10^{-3}$. Note how the derivative at each of the marked points corresponds approximately to the slope in the graph at those very points, which varies as the load steps are not of equal length. And the biggest slope occurs precisely in between $\\tau$ of 4 and 5 when the prescribed loading undergoes the biggest change from 300 to 400 KN. <p>$\\tau$   $f(\\tau)$    $f'(\\tau)$ (AD)   $f'(\\tau)$ (FD)</p> <p>1.5      2.81              0.700             0.700   3.5      4.527             1.344             1.344   5.5      6.538             0.623             0.623</p> <p>: AD verification structural static problem {#table:SP_AD}</p>"},{"location":"examples/cpc_examples/#large-amplitude-nonlinear-dynamics","title":"Large-amplitude nonlinear dynamics","text":"<p>This test case demonstrates the accuracy of the NMROM approach for dynamic geometrically-nonlinear calculations. The right wing of Fig. 1 is considered and dynamic nonlinear simulations are carried out and compared to commercial solutions of the full FE model. A force is applied at the wing tip with a triangular loading profile, followed by a sudden release of the applied force to heavily excite the wing. The force profile is given in Fig. 5. The applied force is then $f_{tip} = \\alpha \\textup{\\pmb{f}}{max} f(0.05, 4)$ with $\\textup{\\pmb{f}}{max} = [-2\\times 10^5, 0., 6\\times 10^5]$ where $\\alpha$ has been set to $1$.</p> <p><pre><code>#+name: fig:ramping_load\n</code></pre> <pre><code>#+caption: Ramping load profile for dynamic simulation of representative wing\n</code></pre> <pre><code>#+attr_latex: :width 0.6\\textwidth\n</code></pre> file:./figs_ext/ramping_load.pdf The dynamic response is presented in Fig. 5, where results have been normalised with the wing semi-span ($l=28.8$ m). As expected, linear analysis over-predicts vertical displacements and does not capture displacements in the $x$ and $y$ directions. NMROMs were built with 5, 15, 30, 50 and 100 modes. A Runge-Kutta four is used to march the equation in time with time steps corresponding to the inverse of the largest eigenvalue in the NMROM, i.e. $\\Delta t = [27.34, 6.62, 2.49, 1.27, 0.575] \\times 10^{-3}$ s.</p> <pre><code>sol_wsp= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [1,2,4]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.9385,\n    font=dict(size= 10))))(subplots_wtips2)(wsp_wingtip, sol_wsp, labels=None, nast_load=0, modes=[5,15,50])\nfigname\n</code></pre> <p>{#fig:wsp_3d}</p> <p>As in the previous example, the 3D shape of the model is retrieved and compared against the full nonlinear dynamic solution, as illustrated in Fig. 6 (Nastran solution in yellow and NMROM with 50 modes in blue). The times at positive and negative peaks are displayed. Even though a wing of such characteristics would never undergo in practice this level of deformations, these results further support the viability of the methodology to solve highly geometrically nonlinear dynamics, on complex models and with minimal computational effort.</p> <p>{#wsp_3d}</p> <p>Next we look at the differences of the dynamic simulations with the same metric employed above that now evolves in time. Integration errors accumulate and discrepancies grow with time but still remain small. In fact the differences between MSC Nastran and our dynamic solvers are comparable to the static example with the highest load (around the $5\\times 10^{-5}$ mark). Both cases displaying maximum deformations around 25\\% of the wing semi-span.</p> <pre><code>wsp_error = fn_wspError(sol_wsp)\nwsp_error_time = jnp.linspace(0,15,10001)\nfig, figname = fig_out(name, update_layout=dict(showlegend=False, margin=dict(\n                              autoexpand=True,\n                              l=0,\n                              r=5,\n                              t=2,\n                              b=0)))(fn_wspPloterror3D)(wsp_error_time,wsp_error3d)\nfigname\n</code></pre> <p>{#WSP_error}</p> <p>An impressive reduction of computational time is achieved by our solvers as highlighted in Table 3. The nonlinear response of the full model took 1 hour 22 minutes, which is over two orders of magnitude slower than the NMROM with 50 modes resolution, which proved very accurate. The significant increase in computational effort when moving from a solution with 50 modes to 100 modes is due to various factors: vectorised operations are limited and the quadratic nonlinearities ultimately lead to O($N_m^3$) algorithms; the time-step needs to be decreased for the Runge-Kutta integration to remain stable; the additional overheads that come with saving and moving larger tensors, from the modal shapes, the cubic modal couplings, to the system states (note times shown account for all the steps from start to end of the simulation, including saving all the data for postprocessing).</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'WSP{i+1}'].iloc[0], 2)) for i in range(5)])]\nvalues += [1*60*60 + 22*60]\nvalues += [33.6]\nheader = [\"NMROM (modes: 5, 15, 30, 50, 100)\"]\nheader += [\"NASTRAN 400\"]\nheader += [\"NASTRAN 109\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <p><pre><code>#+results: WSP_times\n</code></pre>                NMROM (modes: 5, 15, 30, 50, 100)   NASTRAN 400   NASTRAN 109</p> <p>Time    2.79, 2.92, 4.85, 12.14, 155.3      4920          33.6</p> <p>: Computational times representative wing dynamic solution   {#table:WSP_times}</p>"},{"location":"examples/cpc_examples/#differentiation-of-dynamic-response","title":"Differentiation of dynamic response","text":"<p>We move now to a novel feature of this work, i.e. the ability to compute gradients via automatic differentiation in geometrically nonlinear dynamic problems. The maximum root loads occurring in a wing subjected to dynamic loads is a good test case as it can be a critical metric in sizing the aircraft wings, especially high-aspect ratio ones. Thus we look at the variation of the maximum z-component of the vertical internal forces as a function of $\\alpha$ in the loading profile of Fig. 5. Effectively, the slope of the loading increases with $\\alpha$. Table 4 shows the derivatives computed using FD with an epsilon of $10^{-4}$ and AD in reverse-mode on the example with 50 modes resolution. In this case the FD needed tweaking of epsilon while application of AD was straight forward with no need for checkpoints and took around three times the speed of a single calculation.</p> <p>$\\alpha$   $f(\\alpha)$    $f'(\\alpha)$ (AD)   $f'(\\alpha)$ (FD)</p> <p>0.5        1706.7                 3587.71             3587.77   1.0        3459.9                 3735.26             3735.11   1.5        5398.7                 3957.81             3958.31</p> <p>: AD verification structural dynamic problem {#table:AD_WSP}</p> <p>It is worth noting the high frequency dynamics excited after the ramping load is suddenly released. In fact in the $z$-component of the wing-tip evolution in Fig. 8 we can see a maximum tip displacement of 4.36 m, 7.91 m and 10.83 m, for $\\alpha = 0.5, 1, 1.5$ i.e smaller than the proportional linear response. On the other hand, in Fig. 9 the evolution of the root loads show a response with much higher frequencies and the maximum occurs in the free dynamical response of the wing, which is higher as we increase $\\alpha$.</p> <pre><code>sol_wspz= [solution.IntrinsicReader(f\"./WSP{i}\") for i in [\"4alpha05\",\n                                                          \"4\",\n                                                          \"4alpha15\"]] #range(1,6)]\n# fig, figname = fig_out(name)(wsp_wingtip)(sol_wsp, dim=0, labels=None, nast_load=0)\n#fig = subplots_wsp(sol_wsp, labels=None, nast_load=0)\n#figname\nfig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.3,\n    font=dict(size= 16))))(wsp_wingtip)(sol_wspz, dim=2, modes=[\"0.5\",\"1\",\"1.5\"], axes=[[0,10],None])\nfigname\n</code></pre> <p>{#fig:wsp_adz}</p> <pre><code>fig, figname = fig_out(name, update_layout=dict(legend=dict(x=0.13, y=0.941,\n    font=dict(size= 16))))(wsp_rootload)(sol_wspz, dim=2, scale=1e-6)\nfigname\n</code></pre> <p>{#fig:wsp_adx2}</p>"},{"location":"examples/cpc_examples/#aeroelastic-dynamic-loads-on-an-industrial-configuration","title":"Aeroelastic dynamic loads on an industrial configuration","text":"<p>The studies presented in this section are based on a reference configuration developed to industry standards known as XRF1, which is representative of a long-range wide-body transport airplane. The version with a wing-tip extension in [@CEA2023] is employed to verify a gust response against MSC Nastran linear solution of the full FE model. While the previous results where purely structural, now the dynamic response to an atmospheric disturbance or gust is computed. This aeroelastic analysis is a requirement for certification purposes and it is one of the main drivers in sizing the wings of high aspect ratio wings. Furthermore, the previous examples showed the advantage of our approach in terms of computational speed, but other than that results could be obtained with commercial software. The geometrically nonlinear aeroelastic response, however, it is not currently available in commercial solutions that are bounded to linear analysis in the frequency domain. Other research codes feature those additional physics, yet are limited to simple models. Thus the added value in the proposed approach comes at the intersection between the nonlinear physics arising from large integrated displacements, computational efficiency and the ability to enhance the models already built for industrial use.\\ Fig. 10 shows the reference FE model with three modal shapes. The FE model contains a total of around 177400 nodes, which are condensed into 176 active nodes along the reference load axes through interpolation elements. A Guyan or static condensation approach is used for the reduction and the error in the natural frequencies between full and reduced models is kept below 0.1% well beyond the 30th mode. The aerodynamic model contains $\\sim 1,500$ aerodynamic panels. The simulations are carried out with a modal resolution of 70 modes and a time step in the Runge-Kutta solver of 0.005.</p> <p><pre><code>#+name: fig:xrf1_modalshapes\n</code></pre> <pre><code>#+caption: Modified XRF1 reference configuration with characteristic modal shapes\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> file:figs_ext/xrf1_modalshapes3.pdf</p>"},{"location":"examples/cpc_examples/#linear-response-for-low-intensity-gust","title":"Linear response for low intensity gust","text":"<p>A verification exercise is introduced first by applying two 1-cos gust shapes at a very low intensity, thus producing small deformations and a linear response. The flow Mach number is 0.81. A first gust is applied that we name as G1 of length 67 m and peak velocity 0.141 m/s, and a second gust, G2, of 165 m and peak velocity of 0.164 m/s. A snippet of the inputs to the simulation is display in Listing <code>\\ref{code:dynamic}</code>{=latex}.</p> <p> </p> <p>Fig. 10 shows the normalised wing-tip response with our NMROM that accurately reproduces the linear solution based on the full FE model.</p> <pre><code>sol1= solution.IntrinsicReader(\"./XRF1\")\nsol2= solution.IntrinsicReader(\"./XRF2\")\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip2,sol1, sol2, labels=[1,2], nast_scale=0.01, nast_load=[2,6])\nfigname\n</code></pre> <p>{#fig:GustXRF12}</p>"},{"location":"examples/cpc_examples/#nonlinear-response-for-high-intensity-gust","title":"Nonlinear response for high intensity gust","text":"<p>The gust intensity in the previous section by a factor of 200 in order to show the effects of geometric nonlinearities that are only captured by the nonlinear solver. As seen in Fig. 11, there are major differences in the $x$ and $y$ components of the response due to follower and shortening effects, and a slight reduction in the $z$-component. These are well known geometrically nonlinear effects that are added to the analysis with no significant overhead.</p> <pre><code>sol1= solution.IntrinsicReader(\"./XRF3\")\nsol2= solution.IntrinsicReader(\"./XRF4\")\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip2, sol1, sol2, labels=[1,2], nast_scale=2., nast_load=[2,6])\nfigname\n</code></pre> <p>{#fig:GustXRF34}</p> <p>Snapshots of the 3D response are reconstructed for the G1 gust using the method verified above at the time points where tip displacement are maximum and minimum, i.e. 0.54 and 0.84 seconds. The front and side views together with the aircraft reference configuration are shown in Fig. 12.</p> <p><pre><code>#+name: fig:xrf1gust3D\n</code></pre> <pre><code>#+caption: 3D XRF1 Nonlinear gust response\n</code></pre> <pre><code>#+attr_latex: :width 1\\textwidth\n</code></pre> file:figs_ext/xrf1gust3D2.pdf</p> <p>In previous examples the same Runge-Kutta 4 (RK4) time-marching scheme is used and now we explore the dynamic solution with other solvers to assess their accuracy and also their computational performance. Two explicit ODE solvers, RK4 and Dormand-Prince\\'s 5/4 method (labelled S1 and S2), and two implicit, Euler first order and Kvaerno\\'s 3/2 method ((labelled S3 and S4)), are compared in Fig. 12. In order to justify the use of implicit solvers we reduce the time step from 0.005 to 0.02 seconds, at which point both explicit solvers diverge. Kvaerno\\'s implicit solver remain stable and accurate despite the larger time step while the Euler implicit method is stable but do not yield accurate results.</p> <pre><code>sol3= solution.IntrinsicReader(\"./XRF3\")\nsol5= solution.IntrinsicReader(\"./XRF5\")\nsol7= solution.IntrinsicReader(\"./XRF7\")\nsol8= solution.IntrinsicReader(\"./XRF8\")\n\nfig, figname = fig_out(name)(subplots_wtips2)(xrf1_wingtip4, sol1=sol3, sol2=sol5, sol3=sol7, sol4=sol8,\n                                            labels=[\"S1\",\"S2\",\"S3\",\"S4\"])\nfigname\n</code></pre> <p><pre><code>#+name: fig:GustXRF3578\n</code></pre> <pre><code>#+caption: Wing-tip response to high intensity gust using implicit solvers\n</code></pre> <pre><code>#+attr_latex: :width 0.8\\textwidth\n</code></pre> <pre><code>#+results: GustXRF3578\n</code></pre> file:</p> <p>The computational times of the different solvers are shown in Table 5. The implicit solvers have taken one order of magnitude more time to run despite the reduction in time step. Therefore the main take away this is that for moderately large frequency dynamics, the explicit solvers offer a much efficient solution. The turning point for using implicit solvers would be when the largest eigenvalue in Eqs. <code>\\ref{eq2:sol_qs}</code>{=latex} led to prohibitly small time steps. In terms of the Nastran solution, we are not showing the whole simulation time because that would include the time to sample the DLM aerodynamics which are input into the NMROM as a post-processing step. Instead, the increase in time when adding an extra gust subcase to an already existing analysis is shown, i.e. the difference between one simulation that only computes one gust response and another with two. It is remarkable that the explicit solvers are faster on the nonlinear solution than the linear solution by a commercial software. Besides our highly efficient implementation, the main reason for this might be the Nastran solution involves first a frequency domain analysis and then an inverse Fourier transform to obtain the time-domain results.</p> <pre><code>dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()\nvalues = [\"Time [s]\"]\nvalues += [', '.join([str(round(dfruns[f'XRF{i}'].iloc[0], 2)) for i in [3,5,7,8]])]\nvalues += [0*60*60 + 1*60 + 21]\nheader = [\"NMROM [S1, S2, S3, S4]\" ]\nheader += [\"$\\Delta$ NASTRAN 146\"]\n# df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),\n#                         index=TIMES_DICT.keys())\n\n# df_ = results_df['shift_conm2sLM25']\n# df_ = df_.rename(columns={\"xlabel\": \"%Chord\"})\ntabulate([values], headers=header, tablefmt='orgtbl')\n</code></pre> <p><pre><code>#+results: XRF1_times\n</code></pre>                NMROM        $\\Delta$ NASTRAN 146</p> <p>Time    22.49, 18.94, 273.95, 847.89   81</p> <p>: Computational times XRF1 gust solution. {#table:XRF1_times}</p>"},{"location":"examples/cpc_examples/#differentiation-of-aeroelastic-response","title":"Differentiation of aeroelastic response","text":"<p>Similarly to the examples above, we now verify the AD implementation for the nonlinear aeroelastic response to the gust $G1$. The sensitivity of the six components of the wing root loads are computed with respect to the gust parameters $w_g$ and $L_g$, and the flow parameter $\\rho_{\\inf}$. The results are presented in 1. A very good agreement with the finite differences is found with $\\epsilon=10^{-4}$.</p> <p><pre><code>#+caption: Automatic differentiation in aeroelastic problem\n</code></pre> <pre><code>#+name: table:XRF1_AD\n</code></pre> </p>"},{"location":"examples/cpc_runs/","title":"Load modules","text":"<pre><code>import plotly.express as px\nimport pyNastran.op4.op4 as op4\nimport matplotlib.pyplot as plt\nimport pdb\nimport datetime\nimport os\nimport shutil\nREMOVE_RESULTS = True\n#   for root, dirs, files in os.walk('/path/to/folder'):\n#       for f in files:\n#           os.unlink(os.path.join(root, f))\n#       for d in dirs:\n#           shutil.rmtree(os.path.join(root, d))\n# \nif os.getcwd().split('/')[-1] != 'results':\n    if not os.path.isdir(\"./figs\"):\n        os.mkdir(\"./figs\")\n    if REMOVE_RESULTS:\n        if os.path.isdir(\"./results\"):\n            shutil.rmtree(\"./results\")\n    if not os.path.isdir(\"./results\"):\n        print(\"***** creating results folder ******\")\n        os.mkdir(\"./results\")\n    os.chdir(\"./results\")\n</code></pre> <pre><code>import pathlib\nimport plotly.express as px\nimport pickle\nimport jax.numpy as jnp\nimport jax\nimport pandas as pd\nfrom plotly.subplots import make_subplots\nimport numpy as np\nimport feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml\nfrom feniax.preprocessor.inputs import Inputs\nimport feniax.feniax_main\nimport feniax.plotools.uplotly as uplotly\nimport feniax.plotools.utils as putils\nimport feniax.preprocessor.solution as solution\nimport feniax.unastran.op2reader as op2reader\nimport feniax.plotools.nastranvtk.bdfdef as bdfdef\nfrom tabulate import tabulate\n</code></pre>"},{"location":"examples/cpc_runs/#run-models","title":"Run models","text":"<pre><code>import time\n\nTIMES_DICT = dict()\nSOL = dict()\nCONFIG = dict()\n\ndef run(input1, **kwargs):\n    jax.clear_caches()\n    label = kwargs.get('label', 'default')\n    t1 = time.time()\n    config =  configuration.Config(input1)\n    sol = feniax.feniax_main.main(input_obj=config)\n    t2 = time.time()\n    TIMES_DICT[label] = t2 - t1      \n    SOL[label] = sol\n    CONFIG[label] = config\n\ndef save_times():\n    pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),\n                            index=TIMES_DICT.keys())\n    pd_times.to_csv(\"./run_times.csv\")\n</code></pre> <ul> <li> <p>Models run on this exercise:</p> <p>Label   Model           NumModes   Solver                        tol/dt       settings</p> <p>SP1     SailPlane       5          Newton-Raphson (Diffrax)      1e-6/         SP2     ...             15         ...                           1e-6/         SP3     ...             30         ...                           1e-6/         SP4     ...             50         ...                           1e-6/         SP5     ...             100        ...                           1e-6/         WSP1    WingSailPlane   5          RK4                           27.34x1e-3    WSP2    ...             15         RK4                           6.62x1e-3     WSP3    ...             30         RK4                           2.49x1e-3     WSP4    ...             50         RK4                           1.27x1e-3     WSP5    ...             100        RK4                           0.575x1e-3    XRF1    XRF1 Airbus     70         RK4                           0.005        1,Index=1   XRF2    ...             70         RK4                           0.005        1,Index=2   XRF3    ...             70         RK4                           0.005        1,Index=3   XRF4    ...             70         RK4                           0.005        1,Index=4   XRF5    ...             70         Dopri5 (Diffrax)              0.005        1,Index=2   XRF6    ...             70         RK4                           0.02         1,Index=2   XRF7    ...             70         Implicit Euler (Diffrax)      1e-5/0.02    1,Index=2   XRF8    ...             70         Implicit Kvaerno3 (Diffrax)   1e-5/0.02    1,Index=2</p> </li> </ul>"},{"location":"examples/cpc_runs/#sailplane","title":"SailPlane","text":""},{"location":"examples/cpc_runs/#runs","title":"Runs","text":"<pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n</code></pre> <ol> <li> <p>SP1</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 5\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP2</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 15\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP3</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 30\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP4</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 50\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>SP5</p> <pre><code>SP_folder = feniax.PATH / \"../examples/SailPlane\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"inputs\"\ninp.fem.connectivity = dict(FuselageFront=['RWingInner',\n                                         'LWingInner'],\n                            FuselageBack=['BottomTail',\n                                          'Fin'],\n                            RWingInner=['RWingOuter'],\n                            RWingOuter=None,\n                            LWingInner=['LWingOuter'],\n                            LWingOuter=None,\n                            BottomTail=['LHorizontalStabilizer',\n                                        'RHorizontalStabilizer'],\n                            RHorizontalStabilizer=None,\n                            LHorizontalStabilizer=None,\n                            Fin=None\n                            )\n\ninp.fem.folder = pathlib.Path(SP_folder / 'FEM/')\ninp.fem.num_modes = 50\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"static\"\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"newton\"\ninp.systems.sett.s1.solver_settings = dict(rtol=1e-6,\n                                           atol=1e-6,\n                                           max_steps=50,\n                                           norm=\"linalg_norm\",\n                                           kappa=0.01)\n# inp.systems.sett.s1.solver_library = \"scipy\"\n# inp.systems.sett.s1.solver_function = \"root\"\n# inp.systems.sett.s1.solver_settings = dict(method='hybr',#'krylov',\n#                                           tolerance=1e-9)\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[25, 2], [48, 2]]\n\ninp.systems.sett.s1.xloads.x = [0, 1, 2, 3, 4, 5, 6]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5],\n                                                     [0.,\n                                                      2e5,\n                                                      2.5e5,\n                                                      3.e5,\n                                                      4.e5,\n                                                      4.8e5,\n                                                      5.3e5]\n                                                     ]\ninp.systems.sett.s1.t = [1, 2, 3, 4, 5, 6]\n\ninp.fem.num_modes = 100\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> </ol>"},{"location":"examples/cpc_runs/#wingsp","title":"wingSP","text":""},{"location":"examples/cpc_runs/#runs_1","title":"Runs","text":"<pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\n</code></pre> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ndts = [round(1./ eigenvals[i]**0.5, 2) for i in [5,15,30,50,100]]\n</code></pre> <ol> <li> <p>WSP1</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 5\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP2</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 15\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP3</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 30\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4alpha05</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 0.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 0.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP4alpha15</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 50\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1.5 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1.5 * 6e5,  0., 0.]\n                                                     ]\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\nrun(inp, label=name)\n</code></pre> </li> <li> <p>WSP5</p> <pre><code>wingSP_folder = feniax.PATH / \"../examples/wingSP\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.connectivity = {'c1': None}\ninp.fem.grid = \"structuralGrid\"\ninp.fem.folder = pathlib.Path(f'{wingSP_folder}/FEM/')\neigenvals = jnp.load(inp.fem.folder / \"eigenvals.npy\")\ninp.fem.eig_type = \"inputs\"\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 15.\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\")#, max_steps=) #\"rk4\")\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.xloads.follower_forces = True\ninp.systems.sett.s1.xloads.follower_points = [[23, 0],\n                                              [23, 2]]\ninp.systems.sett.s1.xloads.x = [0, 4, 4+1e-6, 20]\ninp.systems.sett.s1.xloads.follower_interpolation = [[0.05 * -2e5, 1 * -2e5, 0., 0.],\n                                                     [0.05 * 6e5, 1 * 6e5,  0., 0.]\n                                                     ]\ndts = [round(1./ eigenvals[i]**0.5, 6) for i in [5,15,30,50,100]]\nprint(dts)\ninp.fem.num_modes = 100\ninp.systems.sett.s1.dt = round(1./ eigenvals[inp.fem.num_modes]**0.5, 6)\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\nrun(inp, label=name)\n</code></pre> </li> </ol>"},{"location":"examples/cpc_runs/#xrf1","title":"XRF1","text":"<p>WARNING: private model, not available open source</p> <p>Gust lengths and corresponding gust velocities that have been run here and elsewhere. L~g~ 18.0,67.0,116.0,165.0,214 V0~g~ 11.3047276743,14.0732311562,15.4214195361,16.3541764073,17.0785232867</p> <p>Index   Gust length    Gust intensity   Intensity constant   u~inf~    rho~inf~    Mach</p> <p>1       67                  14.0732311562    0.01                 200              1.225                     0.81   2       67                  14.0732311562    2                    200              1.225                     0.81   3       165.               16.3541764073    0.01                 200              1.225                     0.81   4       165.               16.3541764073    2                    200              1.225                     0.81   5       67                  14.0732311562    0.01                 200              1.225                     0.   6       67                  14.0732311562    2                    200              1.225                     0.   7       165.               16.3541764073    0.01                 200              1.225                     0.   8       165.               16.3541764073    2                    200              1.225                     0.</p> <p>: Table with various gusts on the XRF1 that have been run in this work   or in the past {#Table2}</p> <pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\n</code></pre>"},{"location":"examples/cpc_runs/#xrf1_1","title":"XRF1","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*0.01\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf2","title":"XRF2","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073 * 0.01\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.05\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf3","title":"XRF3","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf4","title":"XRF4","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 16.3541764073*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 165.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf5","title":"XRF5","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\n\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.solver_library = \"diffrax\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"Dopri5\",#\"Kvaerno3\",\n                                         )\n\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#xrf6","title":"XRF6","text":"<pre><code>xrf1_folder = feniax.PATH / \"../examples/XRF1/\"\ninp = Inputs()\ninp.engine = \"intrinsicmodal\"\ninp.fem.eig_type = \"input_memory\"\ninp.fem.eigenvals = jnp.load(f\"{xrf1_folder}/FEM/Dreal70.npy\")\ninp.fem.eigenvecs = jnp.load(f\"{xrf1_folder}/FEM/Vreal70.npy\").T\ninp.fem.connectivity = [[1, 7, 13, 31], [2], [3], [4, 5], [27], [6], [],\n                        [8], [9], [10, 11], [29], [12], [],\n                        [14], [15], [16, 21], [17, 23, 25],\n                        [18], [19], [20], [], [22], [], [24], [],\n                        [26], [], [28], [], [30], [], []]\ninp.fem.folder = pathlib.Path(f\"{xrf1_folder}/FEM/\")\ninp.fem.grid = \"structuralGridc.txt\"\ninp.fem.num_modes = 70\ninp.driver.typeof = \"intrinsic\"\ninp.simulation.typeof = \"single\"\nmach = \"081\"\ninp.systems.sett.s1.aero.u_inf = 200.\ninp.systems.sett.s1.aero.rho_inf = 1.225\ninp.systems.sett.s1.aero.A = f\"{xrf1_folder}/AERO/AICs{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.D = f\"{xrf1_folder}/AERO/AICsQhj{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.aero.poles = f\"{xrf1_folder}/AERO/Poles{mach}_8r{inp.fem.num_modes}.npy\"\ninp.systems.sett.s1.solution = \"dynamic\"\ninp.systems.sett.s1.t1 = 10.\ninp.systems.sett.s1.tn = 2001\ninp.systems.sett.s1.xloads.modalaero_forces = True\ninp.systems.sett.s1.q0treatment = 2\ninp.systems.sett.s1.aero.c_ref = 7.271\ninp.systems.sett.s1.aero.gust_profile = \"mc\"\ninp.systems.sett.s1.aero.gust.shift = 0.\ninp.systems.sett.s1.aero.gust.panels_dihedral = f\"{xrf1_folder}/AERO/Dihedral.npy\"\ninp.systems.sett.s1.aero.gust.collocation_points = f\"{xrf1_folder}/AERO/Control_nodes.npy\"\ninp.driver.sol_path = pathlib.Path(\n    f\"./{name}\")\ninp.systems.sett.s1.tn = 501\ninp.systems.sett.s1.solver_library = \"runge_kutta\"\ninp.systems.sett.s1.solver_function = \"ode\"\ninp.systems.sett.s1.solver_settings = dict(solver_name=\"rk4\")\ninp.systems.sett.s1.aero.gust.intensity = 14.0732311562*2 #11.304727674272842/10000\ninp.systems.sett.s1.aero.gust.length = 67.\ninp.systems.sett.s1.aero.gust.step = 0.5\n\nrun(inp, label=name)\n</code></pre>"},{"location":"examples/cpc_runs/#wrap-up","title":"Wrap up","text":"<pre><code>save_times()\n</code></pre>"}]}