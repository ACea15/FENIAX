{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Finite Element models 4 Intrinsic Nonlinear Aeroelastics in JAX [FENIAX]","text":"<p>FEM4INAS is an aeroelastic toolbox  written and parallelized in Python, which acts as a post-processor of commercial software such as MSC Nastran.  Arbitrary FE models built for linear aeroelastic analysis are enhanced with geometric nonlinear effects, flight dynamics and linearized state-space solutions about nonlinear equilibrium.</p>"},{"location":"#t1","title":"t1","text":"<p>fsdf</p>"},{"location":"#t3","title":"t3","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the <code>Getting Started</code> guide for My Project.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>To install the project, run:</p> <pre><code>pip install my-project\n</code></pre>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#reduction-to-load-paths","title":"Reduction to Load paths:","text":"<p>The full FE linear model is splitted into active (ASETs) nodes and ommited nodes such that,</p> <p> </p> <p>A linear dependency is assumed between the omitted and the active degrees of freedom,  </p> <p>with $\\pmb{T}_{oa}$ the transformation matrix between both sets. In general, the condensation is dependent on the frequencies and forms a nonlinear eigenvalue problem where each LNM,  with natural frequency, $\\omega_j$, has one transformation matrix,  </p> <p>This is the so-called exact-condensation matrix, where Kidder's mode expansion is also introduced. The first-order approximation of this equation is attained by letting $\\omega_j =0$, thereby removing inertia effects. This results in a static condensation or Guyan reduction. Note that when the mass model consists only of lumped masses on the active degrees of freedom, $\\pmb{M}{oo} = \\pmb{M}{oa} = \\pmb{0}$, Guyan reduction is the exact condensation.</p> <p>After calculation of $\\pmb{T}{oa}$, the transformation from the active set and the full model is defined as $\\pmb{T} =[\\pmb{I}_a \\; \\pmb{T}{oa}^T]^T$, with $\\pmb{I}_a$ the identity matrix of dimension $a$. The condensed mass and stiffness matrices are obtained by equating the kinetic energy, $\\mathcal{E}_k$ and the potential energy, $\\mathcal{E}_p$ in the linear reduced and complete systems; if external loads are applied to the omitted nodes, equating virtual work gives the equivalent loads in the condensed model:</p> <p> </p>"},{"location":"theory/#intrinsic-modes","title":"Intrinsic modes:","text":"<p>Let $\\pmb{\\Phi}{a}$ be the solution of the eigenvalue problem using the condensed matrices, $\\pmb{M}_a$ and $\\pmb{K}_a$. $\\pmb{\\Phi}{a}$ includes the full set of modes in the condensed system written as displacement and linear rotations at the nodes along the load-paths. Those mode shapes also define velocity and strain distributions. Standard FE solvers yield results in the global reference frame while the intrinsic modes are defined in the initial local configuration (with the convention of the $x$-direction running along the local beam). Therefore, a matrix $\\pmb{\\Xi}_{0}(s) = [\\pmb{R}^{ba}(s,0), \\pmb{0} ; \\pmb{0} , \\pmb{R}^{ba}(s,0)]$ is introduced to rotate the 6-component vectors from the global to the local initial frame, $\\pmb{R}^{ba}(s,0)$ calculated from the structural nodes position.</p> <p>The discrete velocity mode is defined as $\\pmb{\\Phi}{1j} = \\pmb{\\Phi}{0j}$ and a linear interpolation is sought for the continuous displacement, $\\pmb{\\phi}_0(s)$, and velocities modes, $\\pmb{\\phi}_1(s)$:</p> <p> </p> <p>The corresponding distribution of linear and rotational momenta at the master nodes can be  obtained using the condensed inertia matrix, $\\pmb{\\Psi}{1j}  = \\pmb{M}_a \\pmb{\\Phi}{1j} = \\pmb{M}a \\pmb{\\Phi}{0j}$, expressed in their components in the global frame of reference. The introduction of this momentum mode allows the use of arbitrary mass models. Because the mass matrix is already calculated as an integral along the 3D domain and then condensed to a set of master nodes, the continuous momentum mode shapes, $\\pmb{\\psi}_1$, are considered lumped and defined using Dirac's delta function, $\\delta$ as,</p> <p> </p> <p>Each displacement mode also generates a corresponding internal stress state. This defines discrete force/moment modes, $\\pmb{\\Phi}{2}$, which are obtained from the displacement modes and the condensed stiffness matrix using a summation-of-forces approach  where $\\pmb{r}_i$ is the position vector of the nodes summed by $\\mathcal{S}$, and $\\pmb{r}{i+1/2}$ the mid position between nodes $s_i$ and $s_{i+1}$. The first term is the sum of forces due to modal displacements and the second one the sum of moments due to modal rotations and the cross product of the  position vector and the previous calculated force. The strain modes $\\pmb{\\psi}_{2}$ are obtained from spatial derivatives of the displacement modes along along the load paths, and interpolated as piece-wise constant too,</p> <p> </p>"},{"location":"theory/#nonlinear-couplings","title":"Nonlinear couplings:","text":"<p>After a Galerkin projection of the equations, the following tensors need to be approximated: - Alphas must equal the identity matrix  </p> <ul> <li>Gammas give the nonlinear inertia and strain couplings</li> </ul> <p> </p>"},{"location":"theory/#aeroelastic-system","title":"Aeroelastic system:","text":"<p>Systems of equations Different systems of equations are assembled depending on options: </p> <ul> <li>Structural dynamic:    </li> <li>(Clamped) Aeroelastic systems:    </li> </ul>"},{"location":"api/couplings/","title":"Nonlinear couplings","text":""},{"location":"api/couplings/#intrinsic.couplings.f_alpha1","title":"<code>f_alpha1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>alpha1 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        alpha1 tensor (NmxNm)\n\n    \"\"\"\n\n    alpha1 = jnp.einsum(\"isn,jsn-&gt;ij\", phi1, psi1)\n    return alpha1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_alpha2","title":"<code>f_alpha2(phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Alpha2 tensor (NmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_alpha2(phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Alpha2 tensor (NmxNm)\n\n    \"\"\"\n\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    alpha2 = jnp.einsum(\"isn,jsn,n-&gt;ij\", phi2i, psi2i, delta_si)\n    return alpha2\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma1","title":"<code>f_gamma1(phi1, psi1)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>array</code> <p>Velocity modal shapes (Nmx6xNn)</p> required <code>psi1</code> <code>array</code> <p>Momentum modal shapes (Nmx6xNn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma1 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma1(phi1: jnp.array, psi1: jnp.array) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    phi1 : jnp.array\n        Velocity modal shapes (Nmx6xNn)\n    psi1 : jnp.array\n        Momentum modal shapes (Nmx6xNn)\n    Returns\n    -------\n    jnp.array\n        Gamma1 tensor (NmxNmxNm)\n\n    \"\"\"\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L1(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L1 = f2(phi1, psi1)  # Nmx6xNmxNm\n    gamma1 = jnp.einsum(\"isn,jskn-&gt;ijk\", phi1, L1)\n    return gamma1\n</code></pre>"},{"location":"api/couplings/#intrinsic.couplings.f_gamma2","title":"<code>f_gamma2(phi1m, phi2, psi2, delta_s)</code>","text":"<p>Gamma1 tensor calculation.</p> <p>Parameters:</p> Name Type Description Default <code>psi1m</code> <code>array</code> <p>Velocity modal shapes at mid-points (Nmx6xNn)</p> required <code>phi2</code> <code>array</code> <p>Internal force modal shapes (Nmx6xNn)</p> required <code>psi2</code> <code>array</code> <p>Strain modal shapes (Nmx6xNn)</p> required <code>delta_s</code> <code>array</code> <p>1D differential path increments (Nn)</p> required <p>Returns:</p> Type Description <code>array</code> <p>Gamma2 tensor (NmxNmxNm)</p> Source code in <code>feniax/intrinsic/couplings.py</code> <pre><code>@jax.jit\ndef f_gamma2(\n    phi1m: jnp.array, phi2: jnp.array, psi2: jnp.array, delta_s: jnp.array\n) -&gt; jnp.array:\n    \"\"\"Gamma1 tensor calculation.\n\n    Parameters\n    ----------\n    psi1m : jnp.array\n        Velocity modal shapes at mid-points (Nmx6xNn)    \n    phi2 : jnp.array\n        Internal force modal shapes (Nmx6xNn)\n    psi2 : jnp.array\n        Strain modal shapes (Nmx6xNn)\n    delta_s : jnp.array\n        1D differential path increments (Nn)\n\n    Returns\n    -------\n    jnp.array\n        Gamma2 tensor (NmxNmxNm)\n\n    \"\"\"\n\n    phi1mi = phi1m[:, :, 1:]\n    phi2i = phi2[:, :, 1:]\n    psi2i = psi2[:, :, 1:]\n    delta_si = delta_s[1:]\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(functions.L2(u), v, axes=(1, 1)),\n        in_axes=(1, 2),\n        out_axes=2,\n    )  # iterate nodes\n    f2 = jax.vmap(f1, in_axes=(0, None), out_axes=0)  # modes in 1st tensor\n    L2 = f2(phi2i, psi2i)  # Nmx6xNmxNm\n    gamma2 = jnp.einsum(\"isn,jskn,n-&gt;ijk\", phi1mi, L2, delta_si)\n    # L2 = f2(phi2, psi2) # Nmx6xNmxNm\n    # gamma2 = jnp.einsum('isn,jskn,n-&gt;ijk', phi1m, L2, delta_s)\n    return gamma2\n</code></pre>"},{"location":"api/inputs/","title":"Input containers","text":""},{"location":"api/inputs/#intrinsic-modal-solution","title":"Intrinsic modal solution","text":"<p>Containers for the intrinsic modal solution settings</p>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DGustMc","title":"<code>DGustMc</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DGust</code></p> <p>1-cos gust settings (specialisation from DGust)</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>simulation_time</code> <code>Array</code> <code>dfield('', default=None)</code> <code>intensity</code> <code>float</code> <code>dfield('', default=None)</code> <code>step</code> <code>float</code> <code>dfield('', default=None)</code> <code>length</code> <code>float</code> <code>dfield('', default=None)</code> <code>shift</code> <code>float</code> <code>dfield('', default=0.0)</code> <code>panels_dihedral</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>collocation_points</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>shape</code> <code>str</code> <code>dfield('', default='const')</code> <p>Attributes:</p> Name Type Description <code>totaltime</code> <code>float</code> <code>x</code> <code>Array</code> <code>time</code> <code>Array</code> <code>ntime</code> <code>int</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DGustMc(DGust):\n    \"\"\"1-cos gust settings (specialisation from DGust)\n\n    Parameters\n    ----------\n    u_inf : float\n\n    simulation_time : Array\n    intensity : float\n    step : float\n    length : float\n    shift : float\n    panels_dihedral : str | jax.Array\n    collocation_points : str | jax.Array\n    shape : str\n\n    Attributes\n    ----------\n    totaltime : float\n    x : Array\n    time : Array\n    ntime : int\n\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    simulation_time: jnp.ndarray = dfield(\"\", default=None)\n    intensity: float = dfield(\"\", default=None)\n    step: float = dfield(\"\", default=None)\n    length: float = dfield(\"\", default=None)\n    shift: float = dfield(\"\", default=0.0)\n    panels_dihedral: str | jnp.ndarray = dfield(\"\", default=None)\n    collocation_points: str | jnp.ndarray = dfield(\"\", default=None)\n    shape: str = dfield(\"\", default=\"const\")\n    totaltime: float = dfield(\"\", init=False)\n    x: jnp.ndarray = dfield(\"\", init=False)\n    time: jnp.ndarray = dfield(\"\", init=False)\n    ntime: int = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        if isinstance(self.panels_dihedral, (str, pathlib.Path)):\n            object.__setattr__(self, \"panels_dihedral\", jnp.load(self.panels_dihedral))\n        if isinstance(self.collocation_points, (str, pathlib.Path)):\n            object.__setattr__(\n                self, \"collocation_points\", jnp.load(self.collocation_points)\n            )\n\n        gust_totaltime, xgust, time, ntime = self._set_gustDiscretization(\n            self.intensity,\n            self.panels_dihedral,\n            self.shift,\n            self.step,\n            self.simulation_time,\n            self.length,\n            self.u_inf,\n            jnp.min(self.collocation_points[:, 0]),\n            jnp.max(self.collocation_points[:, 0]),\n        )\n        object.__setattr__(self, \"totaltime\", gust_totaltime)\n        object.__setattr__(self, \"x\", xgust)\n        object.__setattr__(self, \"time\", time)\n        object.__setattr__(self, \"ntime\", ntime)\n        # del self.simulation_time\n\n    def _set_gustDiscretization(\n        self,\n        gust_intensity,\n        dihedral,\n        gust_shift,\n        gust_step,\n        simulation_time,\n        gust_length,\n        u_inf,\n        min_collocationpoints,\n        max_collocationpoints,\n    ):\n        #\n        gust_totaltime = gust_length / u_inf\n        xgust = jnp.arange(\n            min_collocationpoints,  # jnp.min(collocation_points[:,0]),\n            max_collocationpoints  # jnp.max(collocation_points[:,0]) +\n            + gust_length\n            + gust_step,\n            gust_step,\n        )\n        time_discretization = (gust_shift + xgust) / u_inf\n        if time_discretization[-1] &lt; simulation_time[-1]:\n            time = jnp.hstack(\n                [\n                    time_discretization,\n                    time_discretization[-1] + 1e-6,\n                    simulation_time[-1],\n                ]\n            )\n        else:\n            time = time_discretization\n        if time[0] != 0.0:\n            time = jnp.hstack([0.0, time[0] - 1e-6, time])\n        ntime = len(time)\n        # npanels = len(collocation_points)\n        return gust_totaltime, xgust, time, ntime\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Daero","title":"<code>Daero</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Modal aerodynamic settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>u_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>rho_inf</code> <code>float</code> <code>dfield('', default=None)</code> <code>q_inf</code> <code>float</code> <code>dfield('', init=False)</code> <code>c_ref</code> <code>float</code> <code>dfield('', default=None)</code> <code>time</code> <code>Array</code> <code>dfield('', default=None)</code> <code>qalpha</code> <code>Array</code> <code>dfield('', default=None)</code> <code>qx</code> <code>Array</code> <code>dfield('', default=None)</code> <code>elevator_index</code> <code>Array</code> <code>dfield('', default=None)</code> <code>elevator_link</code> <code>Array</code> <code>dfield('', default=None)</code> <code>approx</code> <code>str</code> <code>dfield('', default='Roger')</code> <code>Qk_struct</code> <code>list</code> <code>dfield('Sample frquencies and\\n    corresponding AICs for the structure', default=None, yaml_save=False)</code> <code>Qk_gust</code> <code>list</code> <code>dfield('', default=None, yaml_save=False)</code> <code>Qk_controls</code> <code>list</code> <code>dfield('', default=None, yaml_save=False)</code> <code>Q0_rigid</code> <code>Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>A</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>B</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>C</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>D</code> <code>str | Array</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_controls</code> <code>list</code> <code>dfield('', default=None)</code> <code>poles</code> <code>str | Array</code> <code>dfield('', default=None)</code> <code>num_poles</code> <code>int</code> <code>dfield('', default=None)</code> <code>gust_profile</code> <code>str</code> <code>dfield('', default='mc', options=['mc'])</code> <code>gust</code> <code>dict | DGust</code> <code>dfield('Gust settings', default=None)</code> <code>controller_name</code> <code>dict</code> <code>dfield('', default=None)</code> <code>controller_settings</code> <code>dict</code> <code>dfield('', default=None)</code> <code>controller</code> <code>DController</code> <code>dfield('', init=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Daero(DataContainer):\n    \"\"\"Modal aerodynamic settings for each system\n\n    Parameters\n    ----------\n    u_inf : float\n    rho_inf : float\n    q_inf : float\n    c_ref : float\n    time : Array\n    qalpha : Array\n    qx : Array\n    elevator_index : Array\n    elevator_link : Array\n    approx : str\n    Qk_struct : list\n    Qk_gust : list\n    Qk_controls : list\n    Q0_rigid : Array\n    A : str | jax.Array\n    B : str | jax.Array\n    C : str | jax.Array\n    D : str | jax.Array\n    _controls : list\n    poles : str | jax.Array\n    num_poles : int\n    gust_profile : str\n    gust : dict | __main__.DGust\n    controller_name : dict\n    controller_settings : dict\n    controller : DController\n\n    \"\"\"\n\n    u_inf: float = dfield(\"\", default=None)\n    rho_inf: float = dfield(\"\", default=None)\n    q_inf: float = dfield(\"\", init=False)\n    c_ref: float = dfield(\"\", default=None)\n    time: jnp.ndarray = dfield(\"\", default=None)\n    qalpha: jnp.ndarray = dfield(\"\", default=None)\n    qx: jnp.ndarray = dfield(\"\", default=None)\n    elevator_index: jnp.ndarray = dfield(\"\", default=None)\n    elevator_link: jnp.ndarray = dfield(\"\", default=None)\n    #\n    approx: str = dfield(\"\", default=\"Roger\")\n    Qk_struct: list[jnp.ndarray, jnp.ndarray] = dfield(\n        \"\"\"Sample frquencies and\n    corresponding AICs for the structure\"\"\",\n        default=None,\n        yaml_save=False,\n    )\n    Qk_gust: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None, yaml_save=False)\n    Qk_controls: list[jnp.ndarray, jnp.ndarray] = dfield(\n        \"\", default=None, yaml_save=False\n    )\n    Q0_rigid: jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    A: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    B: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    C: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    D: str | jnp.ndarray = dfield(\"\", default=None, yaml_save=False)\n    _controls: list[jnp.ndarray, jnp.ndarray] = dfield(\"\", default=None)\n    poles: str | jnp.ndarray = dfield(\"\", default=None)\n    num_poles: int = dfield(\"\", default=None)\n    gust_profile: str = dfield(\"\", default=\"mc\", options=[\"mc\"])\n    # gust_settings: dict = dfield(\"\", default=None, yaml_save=False)\n    gust: dict | DGust = dfield(\"Gust settings\", default=None)\n    controller_name: dict = dfield(\"\", default=None)\n    controller_settings: dict = dfield(\"\", default=None)\n    controller: DController = dfield(\"\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"approx\", self.approx.capitalize())\n        if self.gust is not None:\n            gust_class = globals()[f\"DGust{self.gust_profile.capitalize()}\"]\n            object.__setattr__(\n                self,\n                \"gust\",\n                # initialise_Dclass(self.gust, gust_class))\n                initialise_Dclass(\n                    self.gust, gust_class, u_inf=self.u_inf, simulation_time=self.time\n                ),\n            )\n\n        if self.controller_name is not None:\n            controller_class = globals()[f\"DController{self.controller_name.upper()}\"]\n            controller_obj = initialise_Dclass(\n                self.controller_settings, controller_class\n            )\n            object.__setattr__(self, \"controller\", controller_obj)\n        else:\n            object.__setattr__(self, \"controller\", None)\n        if isinstance(self.poles, (str, pathlib.Path)):\n            object.__setattr__(self, \"poles\", jnp.load(self.poles))\n        if self.elevator_link is not None:\n            object.__setattr__(self, \"elevator_link\", jnp.array(self.elevator_link))\n        if self.elevator_index is not None:\n            object.__setattr__(self, \"elevator_index\", jnp.array(self.elevator_index))\n        if self.poles is not None:\n            object.__setattr__(self, \"num_poles\", len(self.poles))\n        if self.u_inf is not None and self.rho_inf is not None:\n            q_inf = 0.5 * self.rho_inf * self.u_inf**2\n            object.__setattr__(self, \"q_inf\", q_inf)\n        if isinstance(self.A, (str, pathlib.Path)):\n            object.__setattr__(self, \"A\", jnp.load(self.A))\n        if isinstance(self.B, (str, pathlib.Path)):\n            object.__setattr__(self, \"B\", jnp.load(self.B))\n        if isinstance(self.C, (str, pathlib.Path)):\n            object.__setattr__(self, \"C\", jnp.load(self.C))\n        if isinstance(self.D, (str, pathlib.Path)):\n            object.__setattr__(self, \"D\", jnp.load(self.D))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dconst","title":"<code>Dconst</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Constants in the configuration</p> <p>Parameters:</p> Name Type Description Default <code>I3</code> <code>Array</code> <p>3x3 Identity matrix</p> <code>dfield('3x3 Identity matrix', default=eye(3))</code> <code>e1</code> <code>Array</code> <p>3-component vector with beam direction in local frame</p> <code>dfield('3-component vector with beam direction in local frame', default=array([1.0, 0.0, 0.0]))</code> <code>EMAT</code> <code>Array</code> <p>3x3 Identity matrix</p> <code>dfield('3x3 Identity matrix', default=array([[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, -1, 0, 0, 0], [0, 1, 0, 0, 0, 0]]))</code> <p>Attributes:</p> Name Type Description <code>EMATT</code> <code>Array</code> <p>Transpose EMAT</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dconst(DataContainer):\n    \"\"\"Constants in the configuration\n\n    Parameters\n    ----------\n    I3 : Array\n       3x3 Identity matrix\n    e1 : Array\n       3-component vector with beam direction in local frame\n    EMAT : Array\n       3x3 Identity matrix\n\n    Attributes\n    ----------\n    EMATT : Array\n       Transpose EMAT\n\n    \"\"\"\n\n    I3: jnp.ndarray = dfield(\"3x3 Identity matrix\", default=jnp.eye(3))\n    e1: jnp.ndarray = dfield(\n        \"3-component vector with beam direction in local frame\",\n        default=jnp.array([1.0, 0.0, 0.0]),\n    )\n    EMAT: jnp.ndarray = dfield(\n        \"3x3 Identity matrix\",\n        default=jnp.array(\n            [\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, -1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n            ]\n        ),\n    )\n    EMATT: jnp.ndarray = dfield(\"3x3 Identity matrix\", init=False)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"EMATT\", self.EMAT.T)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxNewton","title":"<code>DdiffraxNewton</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax Newton solver</p> <p>Parameters:</p> Name Type Description Default <code>rtol</code> <code>float</code> <code>dfield('', default=1e-07)</code> <code>atol</code> <code>float</code> <code>dfield('', default=1e-07)</code> <code>max_steps</code> <code>int</code> <code>dfield('', default=100)</code> <code>norm</code> <code>str</code> <code>dfield('', default='linalg_norm')</code> <code>kappa</code> <code>float</code> <code>dfield('', default=0.01)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DdiffraxNewton(Dlibrary):\n    \"\"\"Settings for Diffrax Newton solver\n\n    Parameters\n    ----------\n    rtol : float\n    atol : float\n    max_steps : int\n    norm : str\n    kappa : float\n\n    \"\"\"\n\n    rtol: float = dfield(\"\", default=1e-7)\n    atol: float = dfield(\"\", default=1e-7)\n    max_steps: int = dfield(\"\", default=100)\n    norm: str = dfield(\"\", default=\"linalg_norm\")\n    kappa: float = dfield(\"\", default=0.01)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"newton\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DdiffraxOde","title":"<code>DdiffraxOde</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for Diffrax ODE solvers</p> <p>Parameters:</p> Name Type Description Default <code>root_finder</code> <code>dict</code> <code>dfield('', default=None)</code> <code>stepsize_controller</code> <code>dict</code> <code>dfield('', default=None)</code> <code>solver_name</code> <code>str</code> <code>dfield('', default='Dopri5')</code> <code>save_at</code> <code>Array | list</code> <code>dfield('', default=None)</code> <code>max_steps</code> <code>int</code> <code>dfield('', default=20000)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DdiffraxOde(Dlibrary):\n    \"\"\"Settings for Diffrax ODE solvers\n\n    Parameters\n    ----------\n    root_finder : dict\n    stepsize_controller : dict\n    solver_name : str\n    save_at : jax.Array | list\n    max_steps : int\n\n    \"\"\"\n\n    root_finder: dict = dfield(\"\", default=None)\n    stepsize_controller: dict = dfield(\"\", default=None)\n    solver_name: str = dfield(\"\", default=\"Dopri5\")\n    save_at: jnp.ndarray | list = dfield(\"\", default=None)\n    max_steps: int = dfield(\"\", default=20000)\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"ode\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Ddriver","title":"<code>Ddriver</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Program initialisation settings and trigger of simulations </p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <code>dfield('Driver to manage the simulation', default=True, options=['intrinsic'])</code> <code>sol_path</code> <code>str | Path</code> <code>dfield('Folder path to save results', default='./')</code> <code>compute_fem</code> <code>bool</code> <code>dfield('Compute or load presimulation data', default=True)</code> <code>save_fem</code> <code>bool</code> <code>dfield('Save presimulation data', default=True)</code> <code>ad_on</code> <code>bool</code> <code>dfield('', default=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Ddriver(DataContainer):\n    \"\"\"Program initialisation settings and trigger of simulations \n\n    Parameters\n    ----------\n    typeof : str\n    sol_path : str | pathlib.Path\n    compute_fem : bool\n    save_fem : bool\n    ad_on : bool\n    \"\"\"\n\n    typeof: str = dfield(\n        \"Driver to manage the simulation\", default=True, options=[\"intrinsic\"]\n    )\n    sol_path: str | pathlib.Path = dfield(\"Folder path to save results\", default=\"./\")\n    compute_fem: bool = dfield(\"\"\"Compute or load presimulation data\"\"\", default=True)\n    save_fem: bool = dfield(\"\"\"Save presimulation data\"\"\", default=True)\n    ad_on: bool = dfield(\"\", default=False)\n\n    def __post_init__(self):\n        if self.sol_path is not None:\n            object.__setattr__(self, \"sol_path\", pathlib.Path(self.sol_path))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dfem","title":"<code>Dfem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Finite Element and discretisation model settings </p> <p>Parameters:</p> Name Type Description Default <code>connectivity</code> <code>dict | list</code> <code>dfield('Connectivities of components')</code> <code>folder</code> <code>str | Path</code> <code>dfield('Folder in which to find Ka, Ma,\\n    and grid data (with those names)', default=None)</code> <code>Ka_name</code> <code>str | Path</code> <code>dfield('Condensed stiffness matrix', default='Ka.npy')</code> <code>Ma_name</code> <code>str | Path</code> <code>dfield('Condensed mass matrix', default='Ma.npy')</code> <code>Ka</code> <code>Array</code> <code>dfield('Condensed stiffness matrix', default=None, yaml_save=False)</code> <code>Ma</code> <code>Array</code> <code>dfield('Condensed mass matrix', default=None, yaml_save=False)</code> <code>Ka0s</code> <code>Array</code> <code>dfield('Condensed stiffness matrix augmented with 0s', default=None, yaml_save=False)</code> <code>Ma0s</code> <code>Array</code> <code>dfield('Condensed mass matrix augmented with 0s', default=None, yaml_save=False)</code> <code>num_modes</code> <code>int</code> <code>dfield('Number of modes in the solution', default=None)</code> <code>eig_type</code> <code>str</code> <code>dfield('Calculation of eigenvalues/vectors', default='scipy', options=['scipy', 'jax_custom', 'inputs, input_memory'])</code> <code>eigenvals</code> <code>Array</code> <code>dfield('EigenValues', default=None, yaml_save=False)</code> <code>eigenvecs</code> <code>Array</code> <code>dfield('EigenVectors', default=None, yaml_save=False)</code> <code>eig_cutoff</code> <code>float</code> <code>dfield('cut-off frequency such that eigenvalues smaller than this are set to 0', default=0.01)</code> <code>eig_names</code> <code>list</code> <code>dfield('name to load\\n    eigenvalues/vectors in folder', default=['eigenvals.npy', 'eigenvecs.npy'])</code> <code>grid</code> <code>str | Path | Array | DataFrame</code> <code>dfield('Grid file or array with Nodes Coordinates, node ID in the FEM,\\n        and associated component', default='structuralGrid')</code> <code>Cab_xtol</code> <code>float</code> <code>dfield('Tolerance for building the local frame', default=0.0001)</code> <code>df_grid</code> <code>DataFrame</code> <code>dfield('Data Frame associated to Grid file', init=False)</code> <code>X</code> <code>Array</code> <code>dfield('Grid coordinates', default=None, yaml_save=False)</code> <p>Attributes:</p> Name Type Description <code>Xm</code> <code>Array</code> <code>fe_order</code> <code>list[int] | Array</code> <code>fe_order_start</code> <code>int</code> <code>component_vect</code> <code>list</code> <code>dof_vect</code> <code>list</code> <code>num_nodes</code> <code>int</code> <code>component_names</code> <code>list</code> <code>component_father</code> <code>dict</code> <code>component_nodes</code> <code>dict</code> <code>component_names_int</code> <code>tuple</code> <code>component_father_int</code> <code>tuple</code> <code>component_nodes_int</code> <code>tuple</code> <code>component_chain</code> <code>dict</code> <code>clamped_nodes</code> <code>list</code> <code>freeDoF</code> <code>dict</code> <code>clampedDoF</code> <code>dict</code> <code>total_clampedDoF</code> <code>int</code> <code>constrainedDoF</code> <code>int</code> <code>prevnodes</code> <code>list</code> <code>Mavg</code> <code>Array</code> <code>Mdiff</code> <code>Array</code> <code>Mfe_order</code> <code>Array</code> <code>Mfe_order0s</code> <code>Array</code> <code>Mload_paths</code> <code>Array</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dfem(DataContainer):\n    \"\"\"Finite Element and discretisation model settings \n\n    Parameters\n    ----------\n    connectivity : dict | list\n    folder : str | pathlib.Path\n    Ka_name : str | pathlib.Path\n    Ma_name : str | pathlib.Path\n    Ka : Array\n    Ma : Array\n    Ka0s : Array\n    Ma0s : Array\n    num_modes : int\n    eig_type : str\n    eigenvals : Array\n    eigenvecs : Array\n    eig_cutoff : float\n    eig_names : list\n    grid : str | pathlib.Path | jax.Array | pandas.core.frame.DataFrame\n    Cab_xtol : float\n    df_grid : DataFrame\n    X : Array\n\n    Attributes\n    ----------\n    Xm : Array\n    fe_order : list[int] | jax.Array\n    fe_order_start : int\n    component_vect : list\n    dof_vect : list\n    num_nodes : int\n    component_names : list\n    component_father : dict\n    component_nodes : dict\n    component_names_int : tuple\n    component_father_int : tuple\n    component_nodes_int : tuple\n    component_chain : dict\n    clamped_nodes : list\n    freeDoF : dict\n    clampedDoF : dict\n    total_clampedDoF : int\n    constrainedDoF : int\n    prevnodes : list\n    Mavg : Array\n    Mdiff : Array\n    Mfe_order : Array\n    Mfe_order0s : Array\n    Mload_paths : Array\n\n    Methods\n    -------\n\n\n    \"\"\"\n\n    connectivity: dict | list = dfield(\"Connectivities of components\")\n    folder: str | pathlib.Path = dfield(\n        \"\"\"Folder in which to find Ka, Ma,\n    and grid data (with those names)\"\"\",\n        default=None,\n    )  # yaml_save=False)\n    Ka_name: str | pathlib.Path = dfield(\"Condensed stiffness matrix\", default=\"Ka.npy\")\n    Ma_name: str | pathlib.Path = dfield(\"Condensed mass matrix\", default=\"Ma.npy\")\n    Ka: jnp.ndarray = dfield(\n        \"Condensed stiffness matrix\", default=None, yaml_save=False\n    )\n    Ma: jnp.ndarray = dfield(\"Condensed mass matrix\", default=None, yaml_save=False)\n    Ka0s: jnp.ndarray = dfield(\n        \"Condensed stiffness matrix augmented with 0s\", default=None, yaml_save=False\n    )\n    Ma0s: jnp.ndarray = dfield(\n        \"Condensed mass matrix augmented with 0s\", default=None, yaml_save=False\n    )\n    num_modes: int = dfield(\"Number of modes in the solution\", default=None)\n    eig_type: str = dfield(\n        \"Calculation of eigenvalues/vectors\",\n        default=\"scipy\",\n        options=[\"scipy\", \"jax_custom\", \"inputs, input_memory\"],\n    )\n    eigenvals: jnp.ndarray = dfield(\"EigenValues\", default=None, yaml_save=False)\n    eigenvecs: jnp.ndarray = dfield(\"EigenVectors\", default=None, yaml_save=False)\n    eig_cutoff: float = dfield(\n        \"cut-off frequency such that eigenvalues smaller than this are set to 0\",\n        default=1e-2,\n    )  # -jnp.inf?\n    eig_names: list[str | pathlib.Path] = dfield(\n        \"\"\"name to load\n    eigenvalues/vectors in folder\"\"\",\n        default=[\"eigenvals.npy\", \"eigenvecs.npy\"],\n    )\n    grid: str | pathlib.Path | jnp.ndarray | pd.DataFrame = dfield(\n        \"\"\"Grid file or array with Nodes Coordinates, node ID in the FEM,\n        and associated component\"\"\",\n        default=\"structuralGrid\",\n    )\n    Cab_xtol: float = dfield(\"Tolerance for building the local frame\", default=1e-4)    \n    df_grid: pd.DataFrame = dfield(\"\"\"Data Frame associated to Grid file\"\"\", init=False)\n    X: jnp.ndarray = dfield(\"Grid coordinates\", default=None, yaml_save=False)\n    Xm: jnp.ndarray = dfield(\n        \"Grid coordinates mid-points\", default=None, init=False\n    )\n    fe_order: list[int] | jnp.ndarray = dfield(\"node ID in the FEM\", default=None)\n    fe_order_start: int = dfield(\"fe_order starting with this index\", default=0)\n    component_vect: list[str] = dfield(\n        \"Array with component associated to each node\", default=None\n    )\n    dof_vect: list[str] = dfield(\n        \"Array with DoF associated to each node (for constrained systems)\", default=None\n    )\n    num_nodes: int = dfield(\"Number of nodes\", init=False)\n    num_nodes: int = dfield(\"Number of nodes\", init=False)\n    component_names: list = dfield(\n        \"Name of components defining the structure\", init=False\n    )\n    component_father: dict[str:str] = dfield(\n        \"Map between each component and its father\", init=False\n    )\n    component_nodes: dict[str : list[int]] = dfield(\n        \"Node indexes of the component\", init=False\n    )\n    component_names_int: tuple[int] = dfield(\n        \"Name of components defining the structure\", init=False\n    )\n    component_father_int: tuple[int] = dfield(\n        \"Map between each component and its father\", init=False\n    )\n    component_nodes_int: tuple[list[int]] = dfield(\n        \"Node indexes of the component\", init=False\n    )\n\n    component_chain: dict[str : list[str]] = dfield(\" \", init=False)\n    #\n    clamped_nodes: list[int] = dfield(\"List of clamped or multibody nodes\", init=False)\n    freeDoF: dict[str:list] = dfield(\"Grid coordinates\", init=False)\n    clampedDoF: dict[str:list] = dfield(\"Grid coordinates\", init=False)\n    total_clampedDoF: int = dfield(\"Grid coordinates\", init=False)\n    constrainedDoF: int = dfield(\n        \"whether the analysis presents nodes with some DoF clamped\", init=False\n    )\n    #\n    prevnodes: list[int] = dfield(\"\"\"Immediate previous node following \"\"\", init=False)\n    Mavg: jnp.ndarray = dfield(\"Matrix for tensor average between nodes\", init=False)\n    Mdiff: jnp.ndarray = dfield(\n        \"Matrix for tensor difference between nodes\", init=False\n    )\n    Mfe_order: jnp.ndarray = dfield(\n        \"\"\"Matrix with 1s and 0s that reorders quantities\n    such as eigenvectors in the FE model; nodes in horizontal arrangement.\"\"\",\n        init=False,\n    )\n    Mfe_order0s: jnp.ndarray = dfield(\n        \"\"\"Matrix with 1s and 0s that reorders quantities\n    such as eigenvectors in the FE model; nodes in horizontal arrangement.\"\"\",\n        init=False,\n    )\n    Mload_paths: jnp.ndarray = dfield(\n        \"\"\"Matrix with with 1s and 0s for the load paths\n    that each node, in vertical arrangement, need to transverse to sum up to a free-end.\"\"\",\n        init=False,\n    )\n\n    def __post_init__(self):\n        # set attributes in frozen instance\n        setobj = lambda k, v: object.__setattr__(self, k, v)\n        connectivity = geometry.list2dict(self.connectivity)\n        setobj(\"connectivity\", connectivity)\n        Ka_name, Ma_name, grid = geometry.find_fem(\n            self.folder, self.Ka_name, self.Ma_name, self.grid\n        )\n        setobj(\"Ka_name\", Ka_name)\n        setobj(\"Ma_name\", Ma_name)\n        setobj(\"grid\", grid)\n        if self.folder is not None:\n            setobj(\"folder\", pathlib.Path(self.folder).absolute())\n        if self.Ka is None:\n            if self.folder is None:\n                setobj(\"Ka\", load_jnp(self.Ka_name))\n            else:\n                setobj(\"Ka\", load_jnp(self.folder / self.Ka_name))\n        if self.Ma is None:\n            if self.folder is None:\n                setobj(\"Ma\", load_jnp(self.Ma_name))\n            else:\n                setobj(\"Ma\", load_jnp(self.folder / self.Ma_name))\n                # setobj(\"Ma\", load_jnp(self.Ma_name))\n        if self.num_modes is None:\n            # full set of modes in the solution\n            setobj(\"num_modes\", len(self.Ka))\n        if self.folder is None:\n            df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n                self.grid,\n                self.X,\n                self.fe_order,\n                self.fe_order_start,\n                self.component_vect,\n                self.dof_vect,\n            )\n        else:\n            df_grid, X, fe_order, component_vect, dof_vect = geometry.build_grid(\n                self.folder / self.grid,\n                self.X,\n                self.fe_order,\n                self.fe_order_start,\n                self.component_vect,\n                self.dof_vect,\n            )\n        setobj(\"df_grid\", df_grid)\n        setobj(\"X\", X)\n        setobj(\"fe_order\", fe_order)\n        setobj(\"component_vect\", component_vect)\n        setobj(\"dof_vect\", dof_vect)\n        num_nodes = len(self.X)\n        setobj(\"num_nodes\", num_nodes)\n        component_names, component_father = geometry.compute_component_father(\n            self.connectivity\n        )\n        setobj(\"component_names\", component_names)\n        setobj(\"component_father\", component_father)\n        setobj(\"component_nodes\", geometry.compute_component_nodes(self.component_vect))\n        setobj(\n            \"component_chain\",\n            geometry.compute_component_chain(self.component_names, self.connectivity),\n        )\n        clamped_nodes, freeDoF, clampedDoF, total_clampedDoF, constrainedDoF = (\n            geometry.compute_clamped(self.fe_order.tolist(), self.dof_vect)\n        )\n        setobj(\"clamped_nodes\", clamped_nodes)\n        setobj(\"freeDoF\", freeDoF)\n        setobj(\"clampedDoF\", clampedDoF)\n        setobj(\"total_clampedDoF\", total_clampedDoF)\n        setobj(\"constrainedDoF\", constrainedDoF)\n        if constrainedDoF:\n            Ka0s, Ma0s = geometry.compute_Mconstrained(\n                self.Ka, self.Ma, self.fe_order, clamped_nodes, clampedDoF\n            )\n            setobj(\"Ka0s\", Ka0s)\n            setobj(\"Ma0s\", Ma0s)\n        setobj(\n            \"prevnodes\",\n            geometry.compute_prevnode(\n                self.component_vect, self.component_nodes, self.component_father\n            ),\n        )\n        setobj(\"Mavg\", geometry.compute_Maverage(self.prevnodes, self.num_nodes))\n        setobj(\"Xm\", jnp.matmul(self.X.T, self.Mavg))\n        setobj(\"Mdiff\", geometry.compute_Mdiff(self.prevnodes, self.num_nodes))\n        Mfe_order, Mfe_order0s = geometry.compute_Mfe_order(\n            self.fe_order,\n            self.clamped_nodes,\n            self.freeDoF,\n            self.total_clampedDoF,\n            self.component_nodes,\n            self.component_chain,\n            self.num_nodes,\n        )\n        setobj(\"Mfe_order\", Mfe_order)\n        setobj(\"Mfe_order0s\", Mfe_order0s)\n        setobj(\n            \"Mload_paths\",\n            geometry.compute_Mloadpaths(\n                self.component_vect,\n                self.component_nodes,\n                self.component_chain,\n                self.num_nodes,\n            ),\n        )\n        (component_names_int, component_nodes_int, component_father_int) = (\n            geometry.convert_components(\n                self.component_names, self.component_nodes, self.component_father\n            )\n        )\n        setobj(\"component_names_int\", component_names_int)\n        setobj(\"component_nodes_int\", component_nodes_int)\n        setobj(\"component_father_int\", component_father_int)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dlibrary","title":"<code>Dlibrary</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Solution library</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Dlibrary(DataContainer):\n    \"\"\"Solution library\"\"\"\n    function: str = dfield(\"Function wrapper calling the library\", default=None)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DobjectiveArgs","title":"<code>DobjectiveArgs</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Settings for the objective function in the AD</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <code>dfield('Function wrapper calling the library', default=None)</code> <code>nodes</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>t</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>components</code> <code>tuple</code> <code>dfield('', default=None)</code> <code>axis</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numtime</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numnodes</code> <code>int</code> <code>dfield('', default=None)</code> <code>_numcomponents</code> <code>int</code> <code>dfield('', default=6)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, unsafe_hash=True, kw_only=True)\nclass DobjectiveArgs(Dlibrary):\n    \"\"\"Settings for the objective function in the AD\n\n    Parameters\n    ----------\n    function : str\n    nodes : tuple\n    t : tuple\n    components : tuple\n    axis : int\n    _numtime : int\n    _numnodes : int\n    _numcomponents : int\n\n    \"\"\"\n\n\n    nodes: tuple = dfield(\"\", default=None)\n    t: tuple = dfield(\"\", default=None)\n    components: tuple = dfield(\"\", default=None)\n    axis: int = dfield(\"\", default=None)\n    _numtime: int = dfield(\"\", default=None)\n    _numnodes: int = dfield(\"\", default=None)\n    _numcomponents: int = dfield(\"\", default=6)\n\n    def __post_init__(self):\n        if self.nodes is None:\n            object.__setattr__(self, \"nodes\", tuple(range(self._numnodes)))\n        if self.t is None:\n            object.__setattr__(self, \"t\", tuple(range(self._numtime)))\n        if self.components is None:\n            object.__setattr__(self, \"components\", tuple(range(self._numcomponents)))\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Drunge_kuttaOde","title":"<code>Drunge_kuttaOde</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Solution settings for Runge-Kutta in-house solvers</p> <p>Parameters:</p> Name Type Description Default <code>solver_name</code> <code>str</code> <code>dfield('', default='rk4')</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Drunge_kuttaOde(Dlibrary):\n    \"\"\"Solution settings for Runge-Kutta in-house solvers\n\n    Parameters\n    ----------\n    solver_name : str\n    \"\"\"\n    solver_name: str = dfield(\"\", default=\"rk4\")\n\n    def __post_init__(self):\n        object.__setattr__(self, \"function\", \"ode\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsimulation","title":"<code>Dsimulation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Simulation settings for the management the way each system is run </p> <p>Parameters:</p> Name Type Description Default <code>typeof</code> <code>str</code> <p>Type of simulation [\"single\", \"serial\", \"parallel\"]</p> <code>dfield('Type of simulation', default='single', options=['single', 'serial', 'parallel'])</code> <code>workflow</code> <code>dict</code> <p>Dictionary that defines which system is run after which. The default None implies systems are run in order of the input</p> <code>dfield('Dictionary that defines which system is run after which.\\n        The default None implies systems are run in order of the input', default=None)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dsimulation(DataContainer):\n    \"\"\"Simulation settings for the management the way each system is run \n\n    Parameters\n    ----------\n    typeof : str\n        Type of simulation [\"single\", \"serial\", \"parallel\"]\n    workflow : dict\n        Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\n    \"\"\"\n\n    typeof: str = dfield(\n        \"Type of simulation\", default=\"single\", options=[\"single\", \"serial\", \"parallel\"]\n    )\n    workflow: dict = dfield(\n        \"\"\"Dictionary that defines which system is run after which.\n        The default None implies systems are run in order of the input\"\"\",\n        default=None,\n    )\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystem","title":"<code>Dsystem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>System settings for the corresponding equations to be solved</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <code>dfield('System name')</code> <code>_fem</code> <code>Dfem</code> <code>dfield('', default=None, yaml_save=False)</code> <code>solution</code> <code>str</code> <code>dfield('Type of solution to be solved', options=['static', 'dynamic', 'multibody', 'stability'])</code> <code>target</code> <code>str</code> <code>dfield('The simulation goal of this system', default='Level', options=_member_names_)</code> <code>bc1</code> <code>str</code> <code>dfield('Boundary condition first node', default='clamped', options=_member_names_)</code> <code>save</code> <code>bool</code> <code>dfield('Save results of the run system', default=True)</code> <code>xloads</code> <code>dict | Dxloads</code> <code>dfield('External loads dataclass', default=None)</code> <code>aero</code> <code>dict | Daero</code> <code>dfield('Aerodynamic dataclass', default=None)</code> <code>t0</code> <code>float</code> <code>dfield('Initial time', default=0.0)</code> <code>t1</code> <code>float</code> <code>dfield('Final time', default=1.0)</code> <code>tn</code> <code>int</code> <code>dfield('Number of time steps', default=None)</code> <code>dt</code> <code>float</code> <code>dfield('Delta time', default=None)</code> <code>t</code> <code>Array</code> <code>dfield('Time vector', default=None)</code> <code>solver_library</code> <code>str</code> <code>dfield('Library solving our system of equations', default=None)</code> <code>solver_function</code> <code>str</code> <code>dfield('Name for the solver of the previously defined library', default=None)</code> <code>solver_settings</code> <code>str</code> <code>dfield('Settings for the solver', default=None)</code> <code>q0treatment</code> <code>int</code> <code>dfield('Modal velocities, q1, and modal forces, q2, are the main variables\\n        in the intrinsic structural description,\\n        but the steady aerodynamics part needs a displacement component, q0;\\n        proportional gain to q2 or  integration of velocities q1\\n        can be used to obtain this.', default=2, options=[2, 1])</code> <code>rb_treatment</code> <code>int</code> <code>dfield('Rigid-body treatment: 1 to use the first node quaternion to track the body\\n        dynamics (integration of strains thereafter; 2 to use quaternions at every node.)', default=1, options=[1, 2])</code> <code>nonlinear</code> <code>bool</code> <code>dfield('whether to include the nonlinear terms in the eqs. (Gammas)\\n        and in the integration', default=1, options=[1, 0, -1, -2])</code> <code>residualise</code> <code>bool</code> <code>dfield('average the higher frequency eqs and make them algebraic', default=False)</code> <code>residual_modes</code> <code>int</code> <code>dfield('number of modes to residualise', default=0)</code> <code>label</code> <code>str</code> <code>dfield('System label that maps to the solution functional', default=None)</code> <code>label_map</code> <code>dict</code> <code>dfield('label dictionary assigning ', default=None)</code> <code>states</code> <code>dict</code> <code>dfield('Dictionary with the state variables.', default=None)</code> <code>num_states</code> <code>int</code> <code>dfield('Total number of states', default=None)</code> <code>init_states</code> <code>dict</code> <code>dfield('Dictionary with initial conditions for each state', default=None)</code> <code>init_mapper</code> <code>dict</code> <code>dfield('Dictionary mapping states types to functions in initcond', default=dict(q1='velocity', q2='force'))</code> <code>ad</code> <code>DtoAD</code> <code>dfield('Dictionary for AD', default=None)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Dsystem(DataContainer):\n    \"\"\"System settings for the corresponding equations to be solved\n\n    Parameters\n    ----------\n    name : str\n    _fem : Dfem\n    solution : str\n    target : str\n    bc1 : str\n    save : bool\n    xloads : dict | __main__.Dxloads\n    aero : dict | __main__.Daero\n    t0 : float\n    t1 : float\n    tn : int\n    dt : float\n    t : Array\n    solver_library : str\n    solver_function : str\n    solver_settings : str\n    q0treatment : int\n    rb_treatment : int\n    nonlinear : bool\n    residualise : bool\n    residual_modes : int\n    label : str\n    label_map : dict\n    states : dict\n    num_states : int\n    init_states : dict\n    init_mapper : dict\n    ad : DtoAD\n\n    \"\"\"\n\n    name: str = dfield(\"System name\")\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n    solution: str = dfield(\n        \"Type of solution to be solved\",\n        options=[\"static\", \"dynamic\", \"multibody\", \"stability\"],\n    )\n    target: str = dfield(\n        \"The simulation goal of this system\",\n        default=\"Level\",\n        options=SimulationTarget._member_names_,\n    )\n    bc1: str = dfield(\n        \"Boundary condition first node\",\n        default=\"clamped\",\n        options=BoundaryCond._member_names_,\n    )\n    save: bool = dfield(\"Save results of the run system\", default=True)\n    xloads: dict | Dxloads = dfield(\"External loads dataclass\", default=None)\n    aero: dict | Daero = dfield(\"Aerodynamic dataclass\", default=None)\n    t0: float = dfield(\"Initial time\", default=0.0)\n    t1: float = dfield(\"Final time\", default=1.0)\n    tn: int = dfield(\"Number of time steps\", default=None)\n    dt: float = dfield(\"Delta time\", default=None)\n    t: jnp.ndarray = dfield(\"Time vector\", default=None)\n    solver_library: str = dfield(\n        \"Library solving our system of equations\", default=None\n    )\n    solver_function: str = dfield(\n        \"Name for the solver of the previously defined library\", default=None\n    )\n    solver_settings: str = dfield(\"Settings for the solver\", default=None)\n    q0treatment: int = dfield(\n        \"\"\"Modal velocities, q1, and modal forces, q2, are the main variables\n        in the intrinsic structural description,\n        but the steady aerodynamics part needs a displacement component, q0;\n        proportional gain to q2 or  integration of velocities q1\n        can be used to obtain this.\"\"\",\n        default=2,\n        options=[2, 1],\n    )\n    rb_treatment: int = dfield(\n        \"\"\"Rigid-body treatment: 1 to use the first node quaternion to track the body\n        dynamics (integration of strains thereafter; 2 to use quaternions at every node.)\"\"\",\n        default=1,\n        options=[1, 2],\n    )\n    nonlinear: bool = dfield(\n        \"\"\"whether to include the nonlinear terms in the eqs. (Gammas)\n        and in the integration\"\"\",\n        default=1,\n        options=[1, 0, -1, -2],\n    )\n    residualise: bool = dfield(\n        \"average the higher frequency eqs and make them algebraic\", default=False\n    )\n    residual_modes: int = dfield(\"number of modes to residualise\", default=0)\n    label: str = dfield(\n        \"\"\"System label that maps to the solution functional\"\"\", default=None\n    )\n    label_map: dict = dfield(\"\"\"label dictionary assigning \"\"\", default=None)\n\n    states: dict = dfield(\"\"\"Dictionary with the state variables.\"\"\", default=None)\n    num_states: int = dfield(\"\"\"Total number of states\"\"\", default=None)\n    init_states: dict[str:list] = dfield(\n        \"\"\"Dictionary with initial conditions for each state\"\"\", default=None\n    )\n    init_mapper: dict[str:str] = dfield(\n        \"\"\"Dictionary mapping states types to functions in initcond\"\"\",\n        default=dict(q1=\"velocity\", q2=\"force\"),\n    )\n    ad: DtoAD = dfield(\"\"\"Dictionary for AD\"\"\", default=None)\n\n    def __post_init__(self):\n        if self.t is not None:\n            object.__setattr__(self, \"t1\", self.t[-1])\n            if (len_t := len(self.t)) &lt; 2:\n                object.__setattr__(self, \"dt\", 0.0)\n            else:\n                object.__setattr__(self, \"dt\", self.t[1] - self.t[0])\n            object.__setattr__(self, \"tn\", len_t)\n        else:\n            if self.dt is not None and self.tn is not None:\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            elif self.tn is not None and self.t1 is not None:\n                object.__setattr__(self, \"dt\", (self.t1 - self.t0) / (self.tn - 1))\n            elif self.t1 is not None and self.dt is not None:\n                object.__setattr__(\n                    self, \"tn\", math.ceil((self.t1 - self.t0) / self.dt + 1)\n                )\n                object.__setattr__(self, \"t1\", self.t0 + (self.tn - 1) * self.dt)\n            object.__setattr__(self, \"t\", jnp.linspace(self.t0, self.t1, self.tn))\n\n        object.__setattr__(self, \"xloads\", initialise_Dclass(self.xloads, Dxloads))\n        if self.aero is not None:\n            object.__setattr__(\n                self, \"aero\", initialise_Dclass(self.aero, Daero, time=self.t)\n            )\n        # self.xloads = initialise_Dclass(self.xloads, Dxloads)\n        if self.solver_settings is None:\n            object.__setattr__(self, \"solver_settings\", dict())\n\n        libsettings_class = globals()[\n            f\"D{self.solver_library}{self.solver_function.capitalize()}\"\n        ]\n        object.__setattr__(\n            self,\n            \"solver_settings\",\n            initialise_Dclass(self.solver_settings, libsettings_class),\n        )\n        if self.ad is not None and isinstance(self.ad, dict):\n            libsettings_class = globals()[\"DtoAD\"]\n            object.__setattr__(\n                self,\n                \"ad\",\n                initialise_Dclass(\n                    self.ad,\n                    libsettings_class,\n                    _numtime=len(self.t),\n                    _numnodes=self._fem.num_nodes,\n                ),\n            )\n        if self.label is None:\n            self.build_label()\n\n    def build_states(self, num_modes: int, num_nodes: int):\n        tracker = StateTrack()\n        # TODO: keep upgrading/ add residualise\n        if self.solution == \"static\" or self.solution == \"staticAD\":\n            tracker.update(q2=num_modes)\n            if self.target.lower() == \"trim\":\n                tracker.update(qx=1)\n        elif self.solution == \"dynamic\" or self.solution == \"dynamicAD\":\n            tracker.update(q1=num_modes, q2=num_modes)\n            if self.label_map[\"aero_sol\"] and self.aero.approx.lower() == \"roger\":\n                tracker.update(ql=self.aero.num_poles * num_modes)\n            if self.q0treatment == 1:\n                tracker.update(q0=num_modes)\n            if self.bc1.lower() != \"clamped\":\n                if self.rb_treatment == 1:\n                    tracker.update(qr=4)\n                elif self.rb_treatment == 2:\n                    tracker.update(qr=4 * num_nodes)\n        # if self.solution == \"static\":\n        #     state_dict.update(m, kwargs)\n        object.__setattr__(self, \"states\", tracker.states)\n        object.__setattr__(self, \"num_states\", tracker.num_states)\n\n    def build_label(self):\n        # WARNING: order dependent for the label\n        # nonlinear and residualise should always come last as they are represented\n        # with letters\n        lmap = dict()\n        lmap[\"soltype\"] = SystemSolution[self.solution.upper()].value\n        lmap[\"target\"] = SimulationTarget[self.target.upper()].value - 1\n        if self.xloads.gravity_forces:\n            lmap[\"gravity\"] = \"G\"\n        else:\n            lmap[\"gravity\"] = \"g\"\n        lmap[\"bc1\"] = BoundaryCond[self.bc1.upper()].value - 1\n        lmap[\"aero_sol\"] = int(self.xloads.modalaero_forces)\n        if lmap[\"aero_sol\"] &gt; 0:\n            if self.aero.approx.lower() == \"roger\":\n                lmap[\"aero_sol\"] = 1\n            elif self.aero.approx.lower() == \"loewner\":\n                lmap[\"aero_sol\"] = 2\n            if self.aero.qalpha is None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 0\n            elif self.aero.qalpha is not None and self.aero.qx is None:\n                lmap[\"aero_steady\"] = 1\n            elif self.aero.qalpha is None and self.aero.qx is not None:\n                lmap[\"aero_steady\"] = 2\n            else:\n                lmap[\"aero_steady\"] = 3\n            #\n            if self.aero.gust is None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 0\n            elif self.aero.gust is not None and self.aero.controller is None:\n                lmap[\"aero_unsteady\"] = 1\n            elif self.aero.gust is None and self.aero.controller is not None:\n                lmap[\"aero_unsteady\"] = 2\n            else:\n                lmap[\"aero_unsteady\"] = 3\n        else:\n            lmap[\"aero_steady\"] = 0\n            lmap[\"aero_unsteady\"] = 0\n        if self.xloads.follower_forces and self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 3\n        elif self.xloads.follower_forces:\n            lmap[\"point_loads\"] = 1\n        elif self.xloads.dead_forces:\n            lmap[\"point_loads\"] = 2\n        else:\n            lmap[\"point_loads\"] = 0\n        if self.q0treatment == 2:\n            lmap[\"q0treatment\"] = 0\n        elif self.q0treatment == 1:\n            lmap[\"q0treatment\"] = 1\n        if self.nonlinear == 1:\n            lmap[\"nonlinear\"] = \"\"\n        elif self.nonlinear == -1:\n            lmap[\"nonlinear\"] = \"l\"\n        elif self.nonlinear == -2:\n            lmap[\"nonlinear\"] = \"L\"\n        if self.residualise:\n            lmap[\"residualise\"] = \"r\"\n        else:\n            lmap[\"residualise\"] = \"\"\n        labelx = list(lmap.values())\n        label = label_generator(labelx)\n\n        # TODO: label dependent\n        object.__setattr__(self, \"label_map\", lmap)\n        object.__setattr__(self, \"label\", label)  # f\"dq_{label}\")\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dsystems","title":"<code>Dsystems</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>Input setting for the range of systems in the simulation</p> <p>Parameters:</p> Name Type Description Default <code>sett</code> <code>dict</code> <code>dfield('Settings ', yaml_save=True)</code> <code>mapper</code> <code>dict</code> <code>dfield('Dictionary with systems in the simulation', init=False)</code> <code>borrow</code> <code>dict</code> <code>dfield('Borrow settings from another system:\\n    if there is only one system, then inactive; otherwise default to take settings from\\n    the first system unless specified.\\n    ', default=None)</code> <code>_fem</code> <code>Dfem</code> <code>dfield('', default=None, yaml_save=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dsystems(DataContainer):\n    \"\"\"Input setting for the range of systems in the simulation\n\n    Parameters\n    ----------\n    sett : dict\n    mapper : dict\n    borrow : dict\n    _fem : Dfem\n\n    Attributes\n    ----------\n\n\n    \"\"\"\n\n    sett: dict[str:dict] = dfield(\"Settings \", yaml_save=True)\n    mapper: dict[str:Dsystem] = dfield(\n        \"Dictionary with systems in the simulation\", init=False\n    )\n    borrow: dict[str:str] = dfield(\n        \"\"\"Borrow settings from another system:\n    if there is only one system, then inactive; otherwise default to take settings from\n    the first system unless specified.\n    \"\"\",\n        default=None,\n    )\n    _fem: Dfem = dfield(\"\", default=None, yaml_save=False)\n\n    def __post_init__(self):\n        mapper = dict()\n        counter = 0\n        for k, v in self.sett.items():\n            if self.borrow is None:\n                # pass self._fem to the system here, the others should already have\n                # a reference\n                mapper[k] = initialise_Dclass(v, Dsystem, name=k, _fem=self._fem)\n            elif isinstance(self.borrow, str):\n                assert self.borrow in self.sett.keys(), \"borrow not in system names\"\n                if k == self.borrow:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n                else:\n                    v0 = self.sett[self.borrow]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n            else:\n                if k in self.borrow.keys():\n                    v0 = self.sett[self.borrow[k]]\n                    mapper[k] = initialise_Dclass(v0, Dsystem, name=k, **v)\n                else:\n                    mapper[k] = initialise_Dclass(v, Dsystem, name=k)\n\n            counter += 1\n        object.__setattr__(self, \"mapper\", mapper)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.DtoAD","title":"<code>DtoAD</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dlibrary</code></p> <p>Algorithm differentiation settings</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <code>dfield('Function wrapper calling the library', default=None)</code> <code>inputs</code> <code>dict</code> <code>dfield('', default=None, yaml_save=False)</code> <code>input_type</code> <code>str</code> <code>dfield('', default=None, options=_member_names_)</code> <code>grad_type</code> <code>str</code> <code>dfield('', default=None, options=['jacrev', 'jacfwd', 'value'])</code> <code>objective_fun</code> <code>str</code> <code>dfield('', default=None)</code> <code>objective_var</code> <code>str</code> <code>dfield('', default=None)</code> <code>objective_args</code> <code>dict</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numnodes</code> <code>int</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numtime</code> <code>int</code> <code>dfield('', default=None, yaml_save=False)</code> <code>_numcomponents</code> <code>int</code> <code>dfield('', default=6, yaml_save=False)</code> <code>label</code> <code>str</code> <code>dfield('', default=None, init=False)</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass DtoAD(Dlibrary):\n    \"\"\"Algorithm differentiation settings\n\n    Parameters\n    ----------\n    function : str\n    inputs : dict\n    input_type : str\n    grad_type : str\n    objective_fun : str\n    objective_var : str\n    objective_args : dict\n    _numnodes : int\n    _numtime : int\n    _numcomponents : int\n    label : str\n\n    \"\"\"\n\n    inputs: dict = dfield(\"\", default=None, yaml_save=False)\n    input_type: str = dfield(\"\", default=None, options=ADinputType._member_names_)\n    grad_type: str = dfield(\n        \"\",\n        default=None,\n        options=[  # \"grad\", \"value_grad\",\n            \"jacrev\",\n            \"jacfwd\",\n            \"value\",\n        ],\n    )\n    objective_fun: str = dfield(\"\", default=None)\n    objective_var: str = dfield(\"\", default=None)\n    objective_args: dict | DobjectiveArgs  = dfield(\"\", default=None, yaml_save=False)\n    _numnodes: int = dfield(\"\", default=None, yaml_save=False)\n    _numtime: int = dfield(\"\", default=None, yaml_save=False)\n    _numcomponents: int = dfield(\"\", default=6, yaml_save=False)\n    label: str = dfield(\"\", default=None, init=False)\n\n    def __post_init__(self):\n        label = ADinputType[self.input_type.upper()].value\n        object.__setattr__(self, \"label\", label)\n\n        object.__setattr__(\n            self,\n            \"objective_args\",\n            initialise_Dclass(\n                self.objective_args,\n                DobjectiveArgs,\n                _numtime=self._numtime,\n                _numnodes=self._numnodes,\n                _numcomponents=self._numcomponents,\n            ),\n        )\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.Dxloads","title":"<code>Dxloads</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DataContainer</code></p> <p>External loads settings for each system</p> <p>Parameters:</p> Name Type Description Default <code>follower_forces</code> <code>bool</code> <code>dfield('Include point follower forces', default=False)</code> <code>dead_forces</code> <code>bool</code> <code>dfield('Include point dead forces', default=False)</code> <code>gravity_forces</code> <code>bool</code> <code>dfield('Include gravity in the analysis', default=False)</code> <code>modalaero_forces</code> <code>bool</code> <code>dfield('Include aerodynamic forces', default=False)</code> <code>x</code> <code>Array</code> <code>dfield('x-axis vector for interpolation', default=None)</code> <code>force_follower</code> <code>Array</code> <code>dfield('Point follower forces\\n    (len(x)x6xnum_nodes)', default=None)</code> <code>force_dead</code> <code>Array</code> <code>dfield('Point follower forces\\n    (len(x)x6xnum_nodes)', default=None)</code> <code>follower_points</code> <code>list</code> <code>dfield('Follower force points [Node, coordinate]', default=None)</code> <code>dead_points</code> <code>list</code> <code>dfield('Dead force points [Node, coordinate]', default=None)</code> <code>follower_interpolation</code> <code>list</code> <code>dfield('(Linear) interpolation of the follower forces on t         [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]', default=None)</code> <code>dead_interpolation</code> <code>list</code> <code>dfield('(Linear) interpolation of the dead forces on t         [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]', default=None)</code> <code>gravity</code> <code>float</code> <code>dfield('gravity force [m/s]', default=9.807)</code> <code>gravity_vect</code> <code>Array</code> <code>dfield('gravity vector', default=array([0, 0, -1]))</code> <p>Attributes:</p> Name Type Description <code>Methods</code> <code>-------</code> <code>build_point_follower</code> <code>build_point_dead</code> <code>build_gravity</code> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>@dataclass(frozen=True)\nclass Dxloads(DataContainer):\n    \"\"\"External loads settings for each system\n\n    Parameters\n    ----------\n    follower_forces : bool\n    dead_forces : bool\n    gravity_forces : bool\n    modalaero_forces : bool\n    x : Array\n    force_follower : Array\n    force_dead : Array\n    follower_points : list\n    dead_points : list\n    follower_interpolation : list\n    dead_interpolation : list\n    gravity : float\n    gravity_vect : Array\n\n    Attributes\n    ----------\n\n    Methods\n    -------\n    build_point_follower\n    build_point_dead\n    build_gravity\n\n    \"\"\"\n    follower_forces: bool = dfield(\"Include point follower forces\", default=False)\n    dead_forces: bool = dfield(\"Include point dead forces\", default=False)\n    gravity_forces: bool = dfield(\"Include gravity in the analysis\", default=False)\n    modalaero_forces: bool = dfield(\"Include aerodynamic forces\", default=False)\n    x: jnp.ndarray = dfield(\"x-axis vector for interpolation\", default=None)\n    force_follower: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    force_dead: jnp.ndarray = dfield(\n        \"\"\"Point follower forces\n    (len(x)x6xnum_nodes)\"\"\",\n        default=None,\n    )\n    follower_points: list[list[int, int]] = dfield(\n        \"Follower force points [Node, coordinate]\",\n        default=None,\n    )\n    dead_points: list[list[int, int]] = dfield(\n        \"Dead force points [Node, coordinate]\",\n        default=None,\n    )\n\n    follower_interpolation: list[list[float]] = dfield(\n        \"(Linear) interpolation of the follower forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n    dead_interpolation: list[list[int]] = dfield(\n        \"(Linear) interpolation of the dead forces on t \\\n        [[f0(t0)..f0(tn)]..[fm(t0)..fm(tn)]]\",\n        default=None,\n    )\n\n    gravity: float = dfield(\"gravity force [m/s]\", default=9.807)\n    gravity_vect: jnp.ndarray = dfield(\"gravity vector\", default=jnp.array([0, 0, -1]))\n\n    # gravity_steps: int = dfield(\"steps in which gravity is applied in trim simulation\",\n    #                                    default=1) manage by t\n    # label: str = dfield(\"\"\"Description of the loading type:\n    # '1001' = follower point forces, no dead forces, no gravity, aerodynamic forces\"\"\",\n    #                     init=False)\n    def __post_init__(self):\n        if self.x is not None:\n            object.__setattr__(self, \"x\", jnp.array(self.x))\n        else:\n            object.__setattr__(self, \"x\", jnp.linspace(0, 1, 2))\n        # self.label = f\"{int(self.follower_forces)}\\\n        # {int(self.dead_forces)}{self.gravity_forces}{self.aero_forces}\"\n\n    def build_point_follower(self, num_nodes, C06ab):\n        num_interpol_points = len(self.x)\n        forces = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.follower_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.follower_points[fi][0]\n                dim = self.follower_points[fi][1]\n                forces = forces.at[li, dim, fnode].set(\n                    self.follower_interpolation[fi][li]\n                )  # Nx_6_Nn\n        force_follower = coordinate_transform(forces, C06ab, jax.lax.Precision.HIGHEST)\n        object.__setattr__(self, \"force_follower\", force_follower)\n        # return self.force_follower\n\n    def build_point_dead(self, num_nodes):\n        # TODO: add gravity force, also in modes as M@g\n        num_interpol_points = len(self.x)\n        force_dead = jnp.zeros((num_interpol_points, 6, num_nodes))\n        num_forces = len(self.dead_interpolation)\n        for li in range(num_interpol_points):\n            for fi in range(num_forces):\n                fnode = self.dead_points[fi][0]\n                dim = self.dead_points[fi][1]\n                force_dead = force_dead.at[li, dim, fnode].set(\n                    self.dead_interpolation[fi][li]\n                )\n        object.__setattr__(self, \"force_dead\", force_dead)\n        # return self.force_dead\n\n    def build_gravity(self, Ma, Mfe_order):\n        num_nodes = Mfe_order.shape[1] // 6\n        num_nodes_out = Mfe_order.shape[0] // 6\n        if self.x is not None and len(self.x) &gt; 1:\n            len_x = len(self.x)\n        else:\n            len_x = 2\n        # force_gravity = jnp.zeros((2, 6, num_nodes))\n        gravity = self.gravity * self.gravity_vect\n        gravity_field = jnp.hstack([jnp.hstack([gravity, 0.0, 0.0, 0.0])] * num_nodes)\n        _force_gravity = jnp.matmul(Mfe_order, Ma @ gravity_field)\n        gravity_interpol = jnp.vstack(\n            [xi * _force_gravity for xi in jnp.linspace(0, 1, len_x)]\n        ).T\n        force_gravity = reshape_field(\n            gravity_interpol, len_x, num_nodes_out\n        )  # Becomes  (len_x, 6, Nn)\n        # num_forces = len(self.dead_interpolation)\n        # for li in range(num_interpol_points):\n        #     for fi in range(num_forces):\n        #         fnode = self.dead_points[fi][0]\n        #         dim = self.dead_points[fi][1]\n        #         force_dead = force_dead.at[li, dim, fnode].set(\n        #             self.dead_interpolation[fi][li])\n        object.__setattr__(self, \"force_gravity\", force_gravity)\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.generate_docstring","title":"<code>generate_docstring(cls)</code>","text":"<p>Generate a docstring for a data class based on its fields.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def generate_docstring(cls: Any) -&gt; Any:\n    \"\"\"\n    Generate a docstring for a data class based on its fields.\n    \"\"\"\n    if not is_dataclass(cls):\n        return cls\n\n    lines = [f\"{cls.__name__}:\\n\"]\n    for field in fields(cls):\n        field_type = field.type.__name__ if hasattr(field.type, '__name__') else str(field.type)\n        lines.append(f\"    {field.name} : {field_type}\")\n        # Here you could add more detailed documentation for each field if needed\n    cls.__doc__ = \"\\n\".join(lines)\n    return cls\n</code></pre>"},{"location":"api/inputs/#preprocessor.containers.intrinsicmodal.update_docstrings","title":"<code>update_docstrings(module)</code>","text":"<p>Update docstrings for all data classes in the given module.</p> Source code in <code>feniax/preprocessor/containers/intrinsicmodal.py</code> <pre><code>def update_docstrings(module: Any) -&gt; None:\n    \"\"\"Update docstrings for all data classes in the given module.\"\"\"\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj) and is_dataclass(obj):\n            obj = generate_docstring(obj)\n            print(obj.__doc__)\n</code></pre>"},{"location":"api/modes/","title":"Modes","text":""},{"location":"api/modes/#intrinsic.modes.axis_tilde","title":"<code>axis_tilde(tensor)</code>","text":"<p>Apply tilde0010 to a tensor</p> <p>The input tesor is iterated through axis 2 first, and axis 1 subsequently; tilde0010 is applied to axis 0.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>ndarray</code> <p>3xN1xN2 tensor</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6xN1xN2 tensor</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef axis_tilde(tensor: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Apply tilde0010 to a tensor\n\n    The input tesor is iterated through axis 2 first, and axis 1\n    subsequently; tilde0010 is applied to axis 0.\n\n    Parameters\n    ----------\n    tensor : jnp.ndarray\n        3xN1xN2 tensor\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6xN1xN2 tensor\n\n    \"\"\"\n\n    f1 = jax.vmap(tilde0010, in_axes=1, out_axes=2)\n    f2 = jax.vmap(f1, in_axes=2, out_axes=3)\n    f = f2(tensor)\n\n    return f\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.contraction","title":"<code>contraction(moments, loadpaths, precision)</code>","text":"<p>Sums the moments from the nodal forces along the corresponding load path</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) x num_nodes(moment at the previous index due to forces at this node)</p> required <code>loadpaths</code> <code>ndarray</code> <p>num_node x num_node such that [ni, nj] is 1 or 0 depending on whether ni is a node in the loadpath of nj respectively</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>num_modes x 6 x num_nodes(index) as the sum of moments due to forces at each node</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef contraction(moments: jnp.ndarray, loadpaths: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Sums the moments from the nodal forces along the corresponding load path\n\n    Parameters\n    ----------\n    moments : jnp.ndarray\n        num_modes x 6 x num_nodes(index) x num_nodes(moment at the\n        previous index due to forces at this node)\n    loadpaths : jnp.ndarray\n        num_node x num_node such that [ni, nj] is 1 or 0 depending on\n        whether ni is a node in the loadpath of nj respectively\n\n    Returns\n    -------\n    jnp.ndarray\n        num_modes x 6 x num_nodes(index) as the sum of moments\n        due to forces at each node\n\n    \"\"\"\n\n    f = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(2, 0), precision=precision),\n        in_axes=(2, 1),\n        out_axes=2,\n    )\n    fuv = f(moments, loadpaths)\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.coordinates_difftensor","title":"<code>coordinates_difftensor(X, Xm, precision)</code>","text":"<p>Computes coordinates</p> <p>The tensor represents the following: Coordinates, middle point of each element, minus the position of each node in the structure</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Grid coordinates</p> required <code>Mavg</code> <code>ndarray</code> <p>Matrix to calculate the averege point between nodes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required <p>Returns:</p> Name Type Description <code>X3</code> <code>jnp.ndarray: (3xNnxNn)</code> <p>Tensor, Xm1 -(X1)' : [Coordinates, Middle point of segment, Node]</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef coordinates_difftensor(X: jnp.ndarray, Xm: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Computes coordinates\n\n    The tensor represents the following: Coordinates, middle point of each element,\n    minus the position of each node in the structure\n\n    Parameters\n    ----------\n    X : jnp.ndarray\n        Grid coordinates\n    Mavg : jnp.ndarray\n        Matrix to calculate the averege point between nodes\n    num_nodes : int\n        Number of nodes\n\n    Returns\n    -------\n    X3 : jnp.ndarray: (3xNnxNn)\n        Tensor, Xm*1 -(X*1)' : [Coordinates, Middle point of segment, Node]\n\n\n    \"\"\"\n\n    # Xm = jnp.matmul(X, Mavg, precision=precision)\n    num_nodes = X.shape[1]\n    ones = jnp.ones(num_nodes)\n    Xm3 = jnp.tensordot(\n        Xm, ones, axes=0, precision=precision\n    )  # copy Xm along a 3rd dimension\n    Xn3 = jnp.transpose(\n        jnp.tensordot(X, ones, axes=0, precision=precision), axes=[0, 2, 1]\n    )  # copy X along the 2nd dimension\n    X3 = Xm3 - Xn3\n    return X3\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh","title":"<code>eigh(a, b)</code>","text":"<p>Compute the solution to the symmetrized generalized eigenvalue problem.</p> <p>a_s @ w = b_s @ w @ np.diag(v)</p> <p>where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the inputs and H is the Hermitian (conjugate transpose) operator.</p> <p>For self-adjoint inputs the solution should be consistent with <code>scipy.linalg.eigh</code> i.e.</p> <p>v, w = eigh(a, b) v_sp, w_sp = scipy.linalg.eigh(a, b) np.testing.assert_allclose(v, v_sp) np.testing.assert_allclose(w, standardize_angle(w_sp))</p> <p>Note this currently uses <code>jax.linalg.eig(jax.linalg.solve(b, a))</code>, which will be slow because there is no GPU implementation of <code>eig</code> and it's just a generally inefficient way of doing it. Future implementations should wrap cuda primitives. This implementation is provided primarily as a means to test <code>eigh_jvp_rule</code>.</p> <p>Args:     a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)     b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)</p> <p>Returns:     v: eigenvalues of the generalized problem in ascending order.     w: eigenvectors of the generalized problem, normalized such that         w.H @ b @ w = I.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jax.custom_jvp  # jax.scipy.linalg.eigh doesn't support general problem i.e. b not None\ndef eigh(a, b):\n    \"\"\"\n    Compute the solution to the symmetrized generalized eigenvalue problem.\n\n    a_s @ w = b_s @ w @ np.diag(v)\n\n    where a_s = (a + a.H) / 2, b_s = (b + b.H) / 2 are the symmetrized versions of the\n    inputs and H is the Hermitian (conjugate transpose) operator.\n\n    For self-adjoint inputs the solution should be consistent with `scipy.linalg.eigh`\n    i.e.\n\n    v, w = eigh(a, b)\n    v_sp, w_sp = scipy.linalg.eigh(a, b)\n    np.testing.assert_allclose(v, v_sp)\n    np.testing.assert_allclose(w, standardize_angle(w_sp))\n\n    Note this currently uses `jax.linalg.eig(jax.linalg.solve(b, a))`, which will be\n    slow because there is no GPU implementation of `eig` and it's just a generally\n    inefficient way of doing it. Future implementations should wrap cuda primitives.\n    This implementation is provided primarily as a means to test `eigh_jvp_rule`.\n\n    Args:\n        a: [n, n] float self-adjoint matrix (i.e. conj(transpose(a)) == a)\n        b: [n, n] float self-adjoint matrix (i.e. conj(transpose(b)) == b)\n\n    Returns:\n        v: eigenvalues of the generalized problem in ascending order.\n        w: eigenvectors of the generalized problem, normalized such that\n            w.H @ b @ w = I.\n    \"\"\"\n    a = symmetrize(a)\n    b = symmetrize(b)\n    b_inv_a = jax.scipy.linalg.cho_solve(jax.scipy.linalg.cho_factor(b), a)\n    v, w = jax.jit(jax.numpy.linalg.eig, backend=\"cpu\")(b_inv_a)\n    v = v.real\n    # with loops.Scope() as s:\n    #     for _ in s.cond_range(jnp.isrealobj)\n    if jnp.isrealobj(a) and jnp.isrealobj(b):\n        w = w.real\n    # reorder as ascending in w\n    order = jnp.argsort(v)\n    v = v.take(order, axis=0)\n    w = w.take(order, axis=1)\n    # renormalize so v.H @ b @ H == 1\n    norm2 = jax.vmap(lambda wi: (wi.conj() @ b @ wi).real, in_axes=1)(w)\n    norm = jnp.sqrt(norm2)\n    w = w / norm\n    w = standardize_angle(w, b)\n    return v, w\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.eigh_jvp_rule","title":"<code>eigh_jvp_rule(primals, tangents)</code>","text":"<p>Derivation based on Boedekker et al.</p> <p>https://arxiv.org/pdf/1701.00392.pdf</p> <p>Note diagonal entries of Winv dW/dt != 0 as they claim.</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@eigh.defjvp\ndef eigh_jvp_rule(primals, tangents):\n    \"\"\"\n    Derivation based on Boedekker et al.\n\n    https://arxiv.org/pdf/1701.00392.pdf\n\n    Note diagonal entries of Winv dW/dt != 0 as they claim.\n    \"\"\"\n    a, b = primals\n    da, db = tangents\n    if not all(jnp.isrealobj(x) for x in (a, b, da, db)):\n        raise NotImplementedError(\"jvp only implemented for real inputs.\")\n    da = symmetrize(da)\n    db = symmetrize(db)\n\n    v, w = eigh(a, b)\n\n    # compute only the diagonal entries\n    dv = jax.vmap(\n        lambda vi, wi: -wi.conj() @ db @ wi * vi + wi.conj() @ da @ wi,\n        in_axes=(0, 1),\n    )(v, w)\n\n    dv = dv.real\n\n    E = v[jnp.newaxis, :] - v[:, jnp.newaxis]\n\n    # diagonal entries: compute as column then put into diagonals\n    diags = jnp.diag(-0.5 * jax.vmap(lambda wi: wi.conj() @ db @ wi, in_axes=1)(w))\n    # off-diagonals: there will be NANs on the diagonal, but these aren't used\n    off_diags = jnp.reciprocal(E) * (_H(w) @ (da @ w - db @ w * v[jnp.newaxis, :]))\n\n    dw = w @ jnp.where(jnp.eye(a.shape[0], dtype=np.bool), diags, off_diags)\n\n    return (v, w), (dv, dw)\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.make_C6","title":"<code>make_C6(v1)</code>","text":"<p>Given a 3x3xNn tensor, make the diagonal 6x6xNn</p> <p>It iterates over a third dimension in the input tensor</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>A tensor of the form (3x3xNn)</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef make_C6(v1) -&gt; jnp.ndarray:\n    \"\"\"Given a 3x3xNn tensor, make the diagonal 6x6xNn\n\n    It iterates over a third dimension in the input tensor\n\n    Parameters\n    ----------\n    v1 : jnp.ndarray\n        A tensor of the form (3x3xNn)\n\n    \"\"\"\n    f = jax.vmap(\n        lambda v: jnp.vstack(\n            [jnp.hstack([v, jnp.zeros((3, 3))]), jnp.hstack([jnp.zeros((3, 3)), v])]\n        ),\n        in_axes=2,\n        out_axes=2,\n    )\n    fv = f(v1)\n    return fv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.moment_force","title":"<code>moment_force(force, X3t, precision)</code>","text":"<p>Yields moments associated to each node due to the forces</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>ndarray</code> <p>Force tensor (Nmx6xNn) for which we want to obtain the resultant moments</p> required <code>X3t</code> <code>ndarray</code> <p>Tilde positions tensor (6x6xNnxNn)</p> required <p>Returns:</p> Type Description <code>jnp.ndarray: (Nmx6xNnxNn)</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"precision\"])\ndef moment_force(force: jnp.ndarray, X3t: jnp.ndarray, precision) -&gt; jnp.ndarray:\n    \"\"\"Yields moments associated to each node due to the forces\n\n    Parameters\n    ----------\n    force : jnp.ndarray\n        Force tensor (Nmx6xNn) for which we want to obtain the\n        resultant moments\n    X3t : jnp.ndarray\n        Tilde positions tensor (6x6xNnxNn)\n\n    Returns\n    -------\n    jnp.ndarray: (Nmx6xNnxNn)\n\n    \"\"\"\n\n    f1 = jax.vmap(\n        lambda u, v: jnp.tensordot(u, v, axes=(1, 1), precision=precision),\n        in_axes=(None, 2),\n        out_axes=2,\n    )  # tensordot along coordinate axis (len=6)\n    f2 = jax.vmap(f1, in_axes=(2, 3), out_axes=3)\n    fuv = f2(force, X3t)\n\n    return fuv\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.reshape_modes","title":"<code>reshape_modes(_phi, num_modes, num_nodes)</code>","text":"<p>Reshapes vectors in the input matrix to form a 3rd-order tensor</p> <p>Each vector is made into a 6xNn matrix</p> <p>Parameters:</p> Name Type Description Default <code>_phi</code> <code>ndarray</code> <p>Matrix as in the output of eigenvector analysis (6NnxNm)</p> required <code>num_modes</code> <code>int</code> <p>Number of modes</p> required <code>num_nodes</code> <code>int</code> <p>Number of nodes</p> required Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@partial(jit, static_argnames=[\"num_modes\", \"num_nodes\"])\ndef reshape_modes(_phi: jnp.ndarray, num_modes: int, num_nodes: int):\n    \"\"\"Reshapes vectors in the input matrix to form a 3rd-order tensor\n\n    Each vector is made into a 6xNn matrix\n\n    Parameters\n    ----------\n    _phi : jnp.ndarray\n        Matrix as in the output of eigenvector analysis (6NnxNm)\n    num_modes : int\n        Number of modes\n    num_nodes : int\n        Number of nodes\n\n\n    \"\"\"\n\n    phi = jnp.reshape(_phi, (num_nodes, 6, num_modes), order=\"C\")\n    return phi.T\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.scale","title":"<code>scale(phi1, psi1, phi2, phi1l, phi1ml, psi1l, phi2l, psi2l, omega, X_xdelta, C0ab, C06ab, *args, **kwargs)</code>","text":"<p>Sacales the intrinsic modes</p> <p>The porpuse is that the integrals alpha1 and alpha2 are the identity</p> <p>Parameters:</p> Name Type Description Default <code>phi1</code> <code>ndarray</code> required <code>psi1</code> <code>ndarray</code> required <code>phi2</code> <code>ndarray</code> required <code>phi1l</code> <code>ndarray</code> required <code>phi1ml</code> <code>ndarray</code> required <code>psi1l</code> <code>ndarray</code> required <code>phi2l</code> <code>ndarray</code> required <code>psi2l</code> <code>ndarray</code> required <code>omega</code> <code>ndarray</code> required <code>X_xdelta</code> <code>ndarray</code> required <code>C0ab</code> <code>ndarray</code> required <code>C06ab</code> <code>ndarray</code> required <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>def scale(\n    phi1: jnp.ndarray,\n    psi1: jnp.ndarray,\n    phi2: jnp.ndarray,\n    phi1l: jnp.ndarray,\n    phi1ml: jnp.ndarray,\n    psi1l: jnp.ndarray,\n    phi2l: jnp.ndarray,\n    psi2l: jnp.ndarray,\n    omega: jnp.ndarray,\n    X_xdelta: jnp.ndarray,\n    C0ab: jnp.ndarray,\n    C06ab: jnp.ndarray,\n    *args,\n    **kwargs,\n):\n    \"\"\"Sacales the intrinsic modes\n\n    The porpuse is that the integrals alpha1 and alpha2 are the\n    identity\n\n    Parameters\n    ----------\n    phi1 : jnp.ndarray\n    psi1 : jnp.ndarray\n    phi2 : jnp.ndarray\n    phi1l : jnp.ndarray\n    phi1ml : jnp.ndarray\n    psi1l : jnp.ndarray\n    phi2l : jnp.ndarray\n    psi2l : jnp.ndarray\n    omega : jnp.ndarray\n    X_xdelta : jnp.ndarray\n    C0ab : jnp.ndarray\n    C06ab : jnp.ndarray\n    *args :\n    **kwargs :\n\n\n    \"\"\"\n\n    alpha1 = couplings.f_alpha1(phi1, psi1)\n    alpha2 = couplings.f_alpha2(phi2l, psi2l, X_xdelta)\n    num_modes = len(alpha1)\n    # Broadcasting in division\n    alpha1_diagonal = alpha1.diagonal()\n    alpha2_diagonal = alpha2.diagonal()\n    # filter for rigid-body modes\n    alpha2d_filtered = jnp.where(alpha2_diagonal &gt; 1e-4, alpha2_diagonal, 1.0)\n    phi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1 /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi1ml /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    psi1l /= jnp.sqrt(alpha1_diagonal).reshape(num_modes, 1, 1)\n    phi2 /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    phi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n    psi2l /= jnp.sqrt(alpha2d_filtered).reshape(num_modes, 1, 1)\n\n    return (\n        phi1,\n        psi1,\n        phi2,\n        phi1l,\n        phi1ml,\n        psi1l,\n        phi2l,\n        psi2l,\n        omega,\n        X_xdelta,\n        C0ab,\n        C06ab,\n    )\n</code></pre>"},{"location":"api/modes/#intrinsic.modes.tilde0010","title":"<code>tilde0010(vector)</code>","text":"<p>Tilde matrix for cross product (moments due to forces)</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>A 3-element array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>6x6 matrix with (3:6 x 0:3) tilde operator</p> Source code in <code>feniax/intrinsic/modes.py</code> <pre><code>@jit\ndef tilde0010(vector: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Tilde matrix for cross product (moments due to forces)\n\n    Parameters\n    ----------\n    vector : jnp.ndarray\n        A 3-element array\n\n    Returns\n    -------\n    jnp.ndarray\n        6x6 matrix with (3:6 x 0:3) tilde operator\n\n    \"\"\"\n\n    vector_tilde = jnp.vstack(\n        [jnp.zeros((3, 6)), jnp.hstack([tilde(vector), jnp.zeros((3, 3))])]\n    )\n    return vector_tilde\n</code></pre>"}]}