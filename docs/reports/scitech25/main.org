# #+TITLE: Aircraft Nonlinear Dynamic Loads at Large Scale Using an Accelerator-Based Distributed Solution 
#+TITLE: Nonlinear Aircraft Loads at Large Scale Using an Accelerator-Based Concurrent Solution

# #+TITLE: Parallelized Aeroelastic Solution for Large Scale Simulation of Nonlinear Dynamic Loads on Accelerators
# #+AUTHOR: Alvaro Cea and Rafael Palacios
#+AUTHOR: Alvaro Cea\footnote{Research Associate, CAGB 308, South Kensington Campus. (alvaro.cea-esteban15@imperial.ac.uk)}, and Rafael Palacios\footnote{Professor in Computational Aeroelasticity, CAGB 338, South Kensington Campus. AIAA Associate Fellow (r.palacios@imperial.ac.uk)}
#+DATE:
#+BIBLIOGRAPHY:/home/acea/Documents/Engineering.bib
:LATEX_PROPERTIES:
#+OPTIONS: toc:nil
#+OPTIONS: broken-links:mark
#+LATEX_HEADER: \synctex=1
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amsmath,bm}
# +LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage[ruled,vlined]{algorithm2e}
#+LATEX_HEADER: \usepackage[version=4]{mhchem}
#+LATEX_HEADER: \usepackage{siunitx}
#+LATEX_HEADER: \usepackage{longtable,tabularx}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{tabularx,longtable,multirow,subfigure,caption}
#+LATEX_HEADER: \setlength\LTleft{0pt} 
#+LATEX_HEADER: \usepackage{mathrsfs}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \usepackage{mathalpha}
#+LATEX_HEADER: \renewcommand{\figurename}{\bf \small Figure}
#+LATEX_HEADER: \renewcommand{\tablename}{\bf \small Table}
#+LATEX_HEADER: \newcommand{\de}{\delta}
#+LATEX_HEADER: \newcommand{\ve}{\text{v}}
#+LATEX_HEADER: \newcommand{\lo}{\mathcal{L}}
#+LATEX_HEADER: \newcommand{\vt}{\overline{\delta\bm{\theta}}}
#+LATEX_HEADER: \newcommand{\vu}{\overline{\delta\bm{u}}}
#+LATEX_HEADER: \newcommand{\e}{\bm{\mathfrak{e}}}
#+LATEX_HEADER: \newcommand{\E}{\bm{\mathbb{E}}}
#+LATEX_HEADER: \newcommand{\T}{\bm{\mathcal{T}}}
#+LATEX_HEADER: \newcommand{\fra}{(\mathtt{1})}
#+LATEX_HEADER: \newcommand{\frb}{(\mathtt{2})}
#+LATEX_HEADER: \newcommand{\fri}{(\mathfrak{i})}
#+LATEX_HEADER: \newcommand{\bs}[1]{\boldsymbol{#1}}
#+LATEX_HEADER: \newcommand{\rhoinf}{\rho}	
#+LATEX_HEADER: \newcommand{\Vinf}{U}
#+LATEX_HEADER: \newcommand{\Cl}[1]{c_{l_{#1}}}
#+LATEX_HEADER: \newcommand{\barCl}[1]{\bar{c}_{l_{#1}}}
#+LATEX_HEADER: \newcommand{\Cm}[1]{c_{m_{#1}}}
#+LATEX_HEADER: \newcommand{\barCm}[1]{\bar{c}_{m_{#1}}}
#+LATEX_HEADER: \newcommand{\AIC}{\bs{\mathcal{A}}}

:END:

#+begin_abstract
A novel methodology is presented in this paper for the structural and aeroelastic analysis of large engineering systems with slender components, such as aircraft.
Leveraging on the numerical library JAX, a nonlinear formulation based on velocities and strains enables a highly vectorised codebase that is especially suitable for the integration of aerodynamic loads which naturally appear as follower forces. On top of that, JAX automatic differentiation capabilities lead to a differentiable software that can be embedded into broader multidisciplinary frameworks. 
The general solution starts from a linear Finite-Element (FE) model of arbitrary complexity, on which a structural model order reduction is performed. A nonlinear description of the reduced model follows, with the corresponding reconstruction of the full 3D dynamics. Both highly accurate and efficient solutions for representative aircraft models are shown. An extensive verification has been carried out by comparison with MSC Nastran full-FE linear and nonlinear solutions.
Furthermore the nonlinear gust response of an industrial configuration with over half a million degrees-of-freedom is computed, and it is faster than its frequency-based, linear equivalent as implemented by the commercial package. Therefore this could be harnessed by aircraft loads engineers to add geometrically nonlinear effects to their existing workflows at no extra computational effort.
Finally, automatic differentiation on both static and dynamic problems is validated against finite-differences, which combined with a near real-time performance of the solvers opens new possibilities for aeroelastic studies and design optimisation.

We propose a non-intrusive framework to enhance complex FE structural and aeroelastic models with geometric nonlinearities -including follower aerodynamic forces, geometric stiffening of the structure and shortening effects-, and the ability to perform time-domain dynamic analysis in near-real time. 

Bring parallelisation on distributed accelerators into our solution process, thus applying the state-of-the-art techniques in used for the large problems in deep-learning. Combined with our already fast simulations times, this could allow the prediction of those sizing aeroelastic loads that include thousands of cases in commercial aircraft, the computation of their gradients with respect to design variables, with geometrically nonlinear effects accounted for, and at such performance that the framework could be integrated into a larger multidisciplinary optimization.

#+end_abstract


* House keeping  :noexport: 
#+begin_src elisp :results none :tangle no :exports none
  (add-to-list 'org-structure-template-alist
  '("sp" . "src python :session (print pythonShell)"))
  (add-to-list 'org-structure-template-alist
  '("se" . "src elisp"))
  (setq org-confirm-babel-evaluate nil)
  (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
  (setq org-latex-pdf-process
    '("latexmk -pdflatex='pdflatex --syntex=1 -interaction nonstopmode' -pdf -bibtex -f %f"))
  ;; (setq org-latex-pdf-process (list "latexmk -f -pdf -interaction=nonstopmode -output-directory=%o %f"))
  (pyvenv-workon "fem4inas")
  (require 'org-tempo)
  ;; Veval_blocks -> eval blocks of latex
  ;; Veval_blocks_run -> eval blocks to obtain results
  (setq Veval_blocks "yes") ;; yes, no, no-export 
  (setq Veval_blocks_run "no")
  (setq pythonShell "py1org")
  ;; export_blocks: code, results, both, none
  (setq export_blocks  "results")  
#+end_src

* Load modules :noexport: 
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes  :eval (print Veval_blocks) :exports (print export_blocks) :comments both
:END:

#+begin_src python  :results none 
  import plotly.express as px
  import pyNastran.op4.op4 as op4
  import matplotlib.pyplot as plt
  import pdb
  import datetime
  import os
  import shutil
  REMOVE_RESULTS = False
  #   for root, dirs, files in os.walk('/path/to/folder'):
  #       for f in files:
  #           os.unlink(os.path.join(root, f))
  #       for d in dirs:
  #           shutil.rmtree(os.path.join(root, d))
  # 
  if os.getcwd().split('/')[-1] != 'results':
      if not os.path.isdir("./figs"):
          os.mkdir("./figs")
      if REMOVE_RESULTS:
          if os.path.isdir("./results"):
              shutil.rmtree("./results")
      if not os.path.isdir("./results"):
          print("***** creating results folder ******")
          os.mkdir("./results")
      os.chdir("./results")
#+end_src

#+NAME: PYTHONMODULES
#+begin_src python  :results none  :tangle ./results/run.py
  import pathlib
  import plotly.express as px
  import pickle
  import jax.numpy as jnp
  import jax
  import pandas as pd
  import numpy as np
  import feniax.preprocessor.configuration as configuration  # import Config, dump_to_yaml
  from feniax.preprocessor.inputs import Inputs
  import feniax.feniax_main
  import feniax.plotools.uplotly as uplotly
  import feniax.plotools.utils as putils
  import feniax.preprocessor.solution as solution
  import feniax.unastran.op2reader as op2reader
  import feniax.plotools.nastranvtk.bdfdef as bdfdef
  from tabulate import tabulate

#+end_src

* Run models :noexport:  
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes :tangle ./results/run.py :eval (print Veval_blocks_run) :exports (print export_blocks) :comments both
:END:

#+begin_src python :results none

  import time

  TIMES_DICT = dict()
  SOL = dict()
  CONFIG = dict()

  def run(input1, **kwargs):
      jax.clear_caches()
      label = kwargs.get('label', 'default')
      t1 = time.time()
      config =  configuration.Config(input1)
      sol = feniax.feniax_main.main(input_obj=config)
      t2 = time.time()
      TIMES_DICT[label] = t2 - t1      
      SOL[label] = sol
      CONFIG[label] = config

  def save_times():
      pd_times = pd.DataFrame(dict(times=TIMES_DICT.values()),
                              index=TIMES_DICT.keys())
      pd_times.to_csv("./run_times.csv")

#+end_src

- Models run on this exercise:

* Plotting :noexport: 
:PROPERTIES:
:header-args:  :session (print pythonShell) :noweb yes :tangle ./results/examples.py :eval (print Veval_blocks_run) :exports (print export_blocks) :comments both
:END:
** Helper functions

* Introduction
Aeroelastic analysis are expected to become critical in the very early phases of the wing design process: while the field was more important in post-design stages to ensure in-flight integrity, it now becomes paramount to capture the cross-couplings between disciplines.
As highlighted in cite:&LIVNE2018, formulations that include nonlinear effects should be developed that not only enhance current modelling techniques  but that also allow rapid data turnaround for the industry. Real-time, hardware-in-the-loop flight simulators would also benefit of actively controlled, deformable airplane models. This leads to a more nonlinear landscape, where the overall aerodynamic performance needs to be calculated around a flight shape with large deformations cite:&GRAY2021; the input for efficient control laws account for the steady state and nonlinear couplings cite:&Artola2021; and the loads ultimately sizing the wings are atmospheric disturbances computed in the time-domain cite:&CESNIK2014a.
This is also the case for more radical configurations that may or may not exhibit high flexibility but whose aeroelastic behaviour is more uncertain.
A more holistic approach to the design also increases the complexity of the processes exponentially, and the trade-offs and cost-benefit analysis may not be possible until robust computational tools are in-place to simulate the different assumptions.
 Certification of new air vehicles is another important aspect that requires 100,000s of load cases simulations cite:&Kier2017, as it considers manoeuvres and gust loads at different velocities and altitudes, and for a range of mass cases and configurations. This poses another challenge for new methods that aim to include new physics since they normally incur in prohibitively expensive computational times. 
Lastly, the mathematical representation of the airframe, embodied in the complex Finite-Element Models (FEMs) built by organizations, encompasses a level of knowledge that is to be preserved when including the new physics mentioned above. 

Those previous considerations set the goals for our previous work [[cite:&CEA2023;&CEA2024]]: 1) to be able to perform geometrically nonlinear aeroelastic analysis, 2) to work with generic FEMs in a non-intrusive manner, and 3) to achieve a computational efficiency that is equivalent to present linear methods (if not faster).
\\

In this work we explore the latest advances on accelerator's parallelisation and how to integrate them into our solution process to enable large scale aeroelastic simulations under geometrically nonlinear assumptions.
Specifically, we set out to characterise the dynamics of highly flexible aircraft in response to the very large envelopes of in-flight loads encountered in the certification process. 
In our latest developments we have leveraged the numerical library JAX cite:&jax2018github to build a new simulation environment for time-domain nonlinear aeroelastic analysis that achieves two orders of magnitude speed-ups with respect to standard implementations [[cite:&CEA2024]],  is suitable for modern hardware architectures such as GPUs [[cite:&ALVAROCEA2024]], and that is also capable of computing derivatives via algorithmic differentiation [[cite:&ALVAROCEA2024a]]. The power of JAX for scientific computation has been proved recently in fluid dynamics cite:&BEZGIN2023 and solid mechanics cite:&XUE2023 applications. 
We want to go one step further by adding parallelisation and distributed computational capabilities to the codebase to tackle the very demanding task of calculating load envelopes while introducing new physics to account for the large displacements and rotations ultra-high-aspect-ratio wings undergo. 
In this multi-process environment, a Single Program Multiple Data (SPMD) paradigm is employed with the main computation spanning as many devices as available in the cluster and performing collective operations to communicate between devices. 
By addressing in one program a substantial part of scenarios during flight (manoeuvres and gust responses at different velocities and altitudes, and for a range of mass cases and configurations), we will be able to produce the critical loading characteristics of the aircraft at a fraction of time. Moreover, as future work we aim to differentiate the boundaries of these critical cases  using AD, thereby providing gradients for optimization studies as well as additional insights to the designer.  

A representative configuration of an ultra-high-aspect-ratio aircraft is studied under various loading scenarios that have been parallelised, namely structural static loads, manoeuvre cases for varying flow conditions and dynamic loads with multiple gusts run concurrently. This application of modern hardware architectures to aircraft nonlinear load analysis is novel and could potentially be introduced inside current industrial processes. 
The paper is organised as follows: [[Theory and implementation]]
[[Results]]

[[Conclusions]]

* Theoretical and computational background
In this section we briefly describe the backbone theory of the proposed methods for nonlinear aeroelastic modelling as continuation of the work in [[cite:&CEA2021b;&CEA2023]]. A summary of the main formulation and its integration into an aeroelastic framework are presented next, along with some implementation details. 

The approach is built on a non-intrusive reduction order process combined with a nonlinear description of the dominant dimension in slender structures. It achieves a nonlinear representation of linear aeroelastic models of arbitrary complexity in a very efficient manner and without losing the characteristics of the linear model.  


** Nonlinear aeroelastic system
The approach is built on a non-intrusive reduction order process combined with a nonlinear description of the dominant dimension in slender structures. It achieves a nonlinear representation of linear aeroelastic models of arbitrary complexity in a very efficient manner and without losing the characteristics of the linear model.  

With those characteristics a reduced model can be obtained from a static or dynamic condensation that captures well the stiffness and inertia properties in the condensed matrices, $\pmb{K}_a$ and $\pmb{M}_a$ (Step 1 in Fig. [[workflow]]). The eigenvalue solution of the FEM yields the modal shapes, $\pmb \Phi_0$, and frequencies $\pmb \omega$ (Step 2, however, $\pmb \Phi_0$ is defined on the master nodes and the figure shows the full reconstructed modal shapes). The dynamics of this reduced model are described by a system on nonlinear equations [[cite:&HODGES2003]] written in material velocities, $\bm x_1$,  and stresses, $\bm x_2$, as state variables. A modal expansion of those is a key step in seamlessly mapping the global FEM into the nonlinear description. The intrinsic modes are introduced and the projection of the state variables is such  $\pmb{x}_1 = \pmb{\Phi}_1\pmb{q}_1$ and $\pmb{x}_2 = \pmb{\Phi}_2\pmb{q}_2$.

After the intrinsic modes have been computed, a dynamic system is obtained after a Galerkin projection of the equations of motion \cite[Ch. 8]{PALACIOS2023}:

\begin{equation}
\label{eq2:sol_qs}
\begin{split}
\dot{\pmb{q}}_{1} &=  \pmb{\omega} \odot  \pmb{q}_{2} - \pmb{\Gamma}_{1} \pmb{:} \left(\pmb{q}_{1} \otimes \pmb{q}_{1} \right) - \pmb{\Gamma}_{2} \pmb{:} \left( \pmb{q}_{2} \otimes  \pmb{q}_{2} \right) + \bm{\eta}  \\
\dot{\pmb{q}}_{2} &= -\pmb{\omega} \odot \pmb{q}_{1} + \pmb{\Gamma}_{2}^{\top} \pmb{:} \left( \pmb{q}_{2} \otimes  \pmb{q}_{1} \right)
\end{split}
\end{equation}
where $\odot$ is the  Hadamard product (element-wise multiplication), $\otimes$ is the tensor product operation and $\pmb{:}$ is the double dot product.

The form of the equations in compact tensorial notation is in fact the way they have been implemented and vectorised. This description is geometrically-exact, with nonlinearities encapsulated in the modal couplings of the third-order tensors $\pmb{\Gamma}_{1}$ and $\pmb{\Gamma}_{2}$ (the former introduces the gyroscopic terms in the dynamics and the latter introduces the strain-force nonlinear relation). $\pmb{\eta}$ is the modal projection of the external forcing terms. They are computed as integrals along the load-paths as an inner product: $\langle \pmb{u},\pmb{v}  \rangle = \int_\Gamma \pmb{u}^\top \pmb{v} ds$, for any $\pmb{u}\in\mathbb{R}^6$ and $\pmb{v}\in\mathbb{R}^6$: 
# ?? messy in tensorial notation (computation is via vmap)
\begin{align}\label{eq2:gammas12}
\Gamma_{1}^{ijk} & = \langle \pmb{\Phi}_{1i}, \lo_1(\pmb{\Phi}_{1j})\pmb{\Psi}_{1k}\rangle, \nonumber \\
\Gamma_{2}^{ijk} & = \langle \pmb{\Phi}_{1i}, \lo_2(\pmb{\Phi}_{2j})\pmb{\Psi}_{2k}\rangle,  \\
\eta_{i} & = \langle \pmb{\Phi}_{1i}, \pmb{f}_1\rangle  \nonumber
\end{align}
with $\lo_1$ and $\lo_2$ linear operators.  and can be extended to form the full aeroelastic system with gravity forces, $\bm{\eta}_g$, aerodynamic forces and gust disturbances, $\bm{v}_g$. Control states can also be included [[cite:&CEA2021a]], but they are not necessary for this work. For a set of reduced frequencies and a given Mach number, the DLM (or a higher fidelity aerodynamic method) yields the Generalised Aerodynamic Forces (GAFs). The current implementation uses Roger's rational function approximation to those GAFs [[cite:&Roger1977]], which results in the follower modal forces:

\begin{equation}\label{eq3:eta_full}
\begin{split}
\bm{\eta}_a = \tfrac12\rho_\infty U_\infty^2 & \left(\vphantom{\sum_{p=1}^{N_p}} \pmb{\mathcal{A}}_0\bm{q}_0 +\frac{c}{2U_\infty}\pmb{\mathcal{A}}_1 \bm{q}_1 +\left(\frac{c}{2U_\infty}\right)^2 \pmb{\mathcal{A}}_2\dot{\bm{q}}_1   \right.  \\
& \left. + \pmb{\mathcal{A}}_{g0}\bm{v}_g +\frac{c}{2U_\infty}\pmb{\mathcal{A}}_{g1} \dot{\bm{v}}_g +\left(\frac{c}{2U_\infty}\right)^2 \pmb{\mathcal{A}}_{g2}\ddot{\bm{v}}_g +  \sum_{p=1}^{N_p} \pmb{\lambda}_p  \right) 
\end{split}
\end{equation}
Where the $\pmb{\mathcal{A}}_is$ are real matrices, $c$ is the reference chord, $\tfrac12\rho_\infty U_\infty^2$, $\pmb{\lambda}_p$ the aerodynamic states and $N_p$ the number of lags. 
The coupling of the structure and aerodynamic equations combined with the aerodynamic lags gives the final ODE system: 

\begin{equation}
\label{eq2:sol_qs}
\begin{split}
\dot{\pmb{q}}_{1} &=  \hat{\pmb{\Omega}}  \pmb{q}_{2} - \hat{\pmb{\Gamma}}_{1} \pmb{:} \left(\pmb{q}_{1} \otimes \pmb{q}_{1} \right) - \hat{\pmb{\Gamma}}_{2} \pmb{:} \left( \pmb{q}_{2} \otimes  \pmb{q}_{2} \right) + \hat{\bm{\eta}}  \\
\dot{\pmb{q}}_{2} &= -\pmb{\omega} \odot \pmb{q}_{1} + \pmb{\Gamma}_{2}^{\top} \pmb{:} \left( \pmb{q}_{2} \otimes  \pmb{q}_{1} \right) \\
\dot{\bm{\lambda}}_{p} &= Q_{\infty}\bm{\mathcal{A}}_{p+2}\pmb{q}_{1}
                       + Q_{\infty}\bm{\mathcal{A}}_{p+2}\dot{\pmb{v}}_g
                       -\frac{2U_\infty\gamma_p}{c}\bm{\lambda}_{p}
\end{split}
\end{equation}
in this system the aerodynamic added-mass effect has been moved to the left hand side such that $\bm{\mathrm{A}}_2 = (\pmb{I} - \frac{\rho c^2}{8}\pmb{\mathcal{A}}_2)^{-1}$, and it couples all DoF in $\pmb q_1$. Thus the natural frequency terms become $\hat{\pmb{\Omega}} = \bm{\mathrm{A}}_2 \textup{diag}(\pmb{\omega})$ and the nonlinear terms $\hat{\pmb{\Gamma}} = \bm{\mathrm{A}}_2 \bm{\Gamma}$. The effect of all external forces, aero, $\bm{\eta}_a$, gravity, $\bm{\eta}_g$, and others, $\bm{\eta}_f$, are combined in such that $\hat{\bm{\eta}} = \bm{\mathrm{A}}_2 \left( \left( \bm{\eta}_a - \frac{\rho c^2}{8} \pmb{\mathcal{A}}_2\dot{\bm{q}}_1 \right) +  \bm{\eta}_g + \bm{\eta}_f \right)$.
The aerodynamic matrices $\hat{\bm{\mathcal{A}}}_{p+2}$ have also been scaled accordingly.
\\
Once the nonlinear solution of the condensed model is computed, the corresponding full 3D state is calculated via a two postprocessing steps: firstly the displacements of the cross-sectional nodes linked to the reduced model via the interpolation elements are computed using the positions and rotations of the latter; secondly, Radial Basis Functions (RBFs) kernels are placed on those cross-sections, thus building an intermediate model that is utilised to extrapolate the positions of the remaining nodes in the full model.
This paves the way for a broader multidisciplinary analysis where CFD-based aerodynamic loading could be used for the calculation of the nonlinear static equilibrium, and also with the transfer of the full deformed state back to the original FE solver to study other phenomena such as local buckling. 

** Computational implementation

Bring parallelisation on distributed accelerators into our solution process, thus applying the state-of-the-art techniques in used for the large problems in deep-learning. Combined with our already fast simulations times, this could allow the prediction of those sizing aeroelastic loads that include thousands of cases in commercial aircraft, the computation of their gradients with respect to design variables, with geometrically nonlinear effects accounted for, and at such performance that the framework could be integrated into a larger multidisciplinary optimization.
  
One of the main contribution of this work is a new computational implementation that achieves accelerations of over 2 orders of magnitude with respect to its predecessor\footnote{Both the new implementation and the examples of this paper can be found at \url{https://github.com/ACea15/FENIAX}}. In addition, a highly modular, flexible architecture based on software design patterns has been put in place, which was further described in \cite{CEA2024}. Moreover, the resulting nonlinear aeroelastic framework is suitable for modern hardware architectures and able to compute sensitivities via algorithmic differentiation (AD), as will be demonstrated herein.
The key enabler was moving from standard Python to a highly vectorised, JAX-based numerical implementation. JAX is a Python library designed for high-performance numerical computing with focus on machine learning activities \cite{jax2018github}. It combines XLA (accelerated linear algebra) and Autograd, the former being a compiler that optimises models for different hardware platforms, the latter is an Automatic Differentiation (AD) tool in Python.

In JAX, you need to only specify how you want the input and output of your code to be partitioned, and the compiler will figure out how to: 1) partition everything inside; and 2) compile inter-device communications.

The XLA compiler behind jit includes heuristics for optimizing computations across multiple devices. In the simplest of cases, those heuristics boil down to computation follows data.

To demonstrate how auto-parallelization works in JAX, below is an example that uses a jax.jit()-decorated staged-out function: it’s a simple element-wise function, where the computation for each shard will be performed on the device associated with that shard, and the output is sharded in the same way:


\begin{algorithm*}[h!]
\DontPrintSemicolon
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{Input file: settings.yaml; FE model: $\bm{K}_a$, $\bm{M}_a$, $\bm{X}_a$; Aerodynamic matrices: $\bm{\mathcal{A}}$}
\Output{Nonlinear aeroelastic solution}
\Begin{
 \BlankLine
$\bm{\phi}$, $\bm{\psi}$  $\longleftarrow$ modes($\bm{K}_a$, $\bm{M}_a$, $\bm{X}_a$) \Comment{Intrinsic modes: O($N_n^2 \times N_m$)}  \;
$\bm{\Gamma}$  $\longleftarrow$ couplings($\bm{\phi}$, $\bm{\psi}$) \Comment{Nonlinear couplings O($N_n \times N_m^3$)} \;
$\bm{q}$  $\longleftarrow$ system($\bm{\Gamma}$, $\bm{\mathcal{A}}$, $\bm{\phi}$, $\bm{X}_a$) \Comment{Modal coordinates: O($N_t \times N_m^3$)}  \;
$\bm{X}_1$, $\bm{X}_{2}$, $\bm{X}_{3}$   $\longleftarrow$ ivars($\bm{q}$, $\bm{\phi}$, $\bm{\psi}$) \Comment{velocity/strain fields: O($N_t \times N_m$)} \;
$\bm{r}_a$, $\bm{R}_{a}$   $\longleftarrow$ integration($\bm{X}_{3}$, $\bm{X}_a$) \Comment{Positional/rotational fields: O($N_f \times N_t \times N_n$)}  \;
\BlankLine
}
\caption{Main components in solution process for parallel multiple load cases}
\label{orgef66755}
\end{algorithm*}


* Results
The following results show the strength of the approach in problems with large geometric nonlinearities, the ability to run on CPUs and GPUs and to automatically compute gradients of dynamic problems, and the edge in performance when compare with commercial toolbox Nastran.  

The next step is to characterise the geometrically nonlinear aeroelastic response of the BUG High-Aspect-Ratio aircraft [[cite:&STODIECK2018a]] shown in Fig. [[fig:BUG]]. We aim to achieve the following points:

#+NAME: fig:BUG
#+CAPTION: BUG model main components
#+ATTR_LATEX: :width 0.8\textwidth 
[[file:figs_ext/BUGmodel2.png]]

** Structural static analysis

#+NAME: fig:BUG_tip
#+CAPTION: Loading scenario
#+ATTR_LATEX: :width 0.8\textwidth 


*** Extremely large deformations under discrete loads

#+NAME: fig:BUG_tip
#+CAPTION: Static equilibrium for tip loads
#+ATTR_LATEX: :width 0.8\textwidth 

*** Uncertainty quantification of nonlinear response

#+NAME: fig:BUG_UQ
#+CAPTION: Static equilibrium for load distribution, first and last loads
#+ATTR_LATEX: :width 0.8\textwidth 


** Steady manoeuvre loads

#+NAME: fig:BUG_manoeuvre
#+CAPTION: Aeroelastic steady equilibrium for increasing angle of attack
#+ATTR_LATEX: :width 0.8\textwidth 

** Dynamic loads at large scale

#+NAME: fig:BUG_Gust
#+CAPTION: Dynamic response to 1-cos gust excitation with  
#+ATTR_LATEX: :width 0.8\textwidth 


* Conclusions
A modal-based formulation has been enhanced with multiple load cases parallelism 
data parallelism capabilities for Single-Program Multi-Data (SPMD) computations 

parallel compu for the dynamics of flexible aircraft that accounts for both geometrically nonlinear deformations and rigid-body motions -as well as the nonlinear interaction between them-.

evice parallelism for Single-Program Multi-Data (SPMD) code in JAX. SPMD is a parallelism technique where the same computation, such as the forward pass of a neural network, can be run on different input data (for example, different inputs in a batch) in parallel on different devices, such as several GPUs or Google TPUs.

the numerical library JAX as the engine powering the computations.


This has allowed time-domain computations in near real-time with two orders of magnitude speed-ups compared to conventional implementations.
This has allowed time-domain computations in near real-time with two orders of magnitude speed-ups compared to conventional implementations.
On all of these cases we have shown how the program running the computations can be deployed on standard CPUs but also on modern hardware architectures such as GPUs that can lead to performance gains of over 30 times faster.



- Fine-tune the aeroelastic solvers to introduce an updating mechanism of the normal of the aerodynamic panels to account for the nonlinear effect around deformed configurations such as trimmed flight. 
- Build manoeuvre and dynamic load envelopes that can also be differentiated via AD.
- 

bibliographystyle:unsrt
# bibliography:/home/acea/Documents/Engineering.bib
bibliography:~/Documents/Engineering.bib
