* Load modules :noexport: 
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes  :eval (print Veval_blocks) :exports (print export_blocks) :comments both :tangle ./results/run.py
:END:

** Helper functions

#+begin_comment
https://plotly.com/python/subplots/
#+end_comment

#+begin_src python :results none  :var name=(org-element-property :name (org-element-context)) :tangle ./results/run.py

  def fig_out(name, figformat="png", update_layout=None):
      def inner_decorator(func):
          def inner(*args, **kwargs):
              fig = func(*args, **kwargs)
              if update_layout is not None:
                  fig.update_layout(**update_layout)
              fig.show()
              figname = f"figs/{name}.{figformat}"
              fig.write_image(f"../{figname}")
              return fig, figname
          return inner
      return inner_decorator


  def fig_background(func):

      def inner(*args, **kwargs):
          fig = func(*args, **kwargs)
          # if fig.data[0].showlegend is None:
          #     showlegend = True
          # else:
          #     showlegend = fig.data[0].showlegend

          fig.update_xaxes(
                         titlefont=dict(size=14),
                         tickfont = dict(size=14),
                         mirror=True,
                         ticks='outside',
                         showline=True,
                         linecolor='black',
              #zeroline=True,
          #zerolinewidth=2,
              #zerolinecolor='LightPink',
                         gridcolor='lightgrey')
          fig.update_yaxes(tickfont = dict(size=14),
                         titlefont=dict(size=14),
                         zeroline=True,
                         mirror=True,
                         ticks='outside',
                         showline=True,
                         linecolor='black',
                         gridcolor='lightgrey')
          fig.update_layout(plot_bgcolor='white',
                            yaxis=dict(zerolinecolor='lightgrey'),
                            showlegend=True, #showlegend,
                            margin=dict(
                                autoexpand=True,
                                l=0,
                                r=0,
                                t=2,
                                b=0
                            ))
          return fig
      return inner

  @fig_background
  def xrf1_wingtip2(t, ra, dim, labels=None, node=150):
      scale = 100./33.977
      fig=None
      x1, y1 = putils.pickIntrinsic2D(t,
                                      ra,
                                      fixaxis2=dict(node=node, dim=dim))
      x2, y2 = putils.pickIntrinsic2D(t,
                                      ra,
                                      fixaxis2=dict(node=node, dim=dim))

      fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,
                            dict(name=f"NMROM-G{labels[0]}",
                                 line=dict(color="orange")
                                 ))
      fig = uplotly.lines2d(x2[1:], (y2[:-1]-y2[0])*scale, fig,
                            dict(name=f"NMROM-G{labels[1]}",
                                 line=dict(color="steelblue")
                                 ))

      dim_dict = {0:'x', 1:'y', 2:'z'}
      fig.update_yaxes(title=r'\large $\hat{u}%s$'%dim_dict[dim])
      fig.update_xaxes(range=[0, 4], title='time [s]')
      return fig

  def subplots_wtips(fun, *args, **kwargs):

      fig1 = fun(*args, dim=0, **kwargs)
      fig2 = fun(*args, dim=1, **kwargs)
      fig3 = fun(*args, dim=2, **kwargs)
      fig3.update_xaxes(title=None)
      fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.135, vertical_spacing=0.1,
                          specs=[[{"colspan": 2}, None],
                                 [{}, {}]])
      for i, f3i in enumerate(fig3.data):
          fig.add_trace(f3i,
                        row=1, col=1
                        )
      for i, f1i in enumerate(fig1.data):
          f1inew = f1i
          f1inew.showlegend = False          
          fig.add_trace(f1inew,
                        row=2, col=1
                        )
      for i, f2i in enumerate(fig2.data):
          f2inew = f2i
          f2inew.showlegend = False          
          fig.add_trace(f2inew,
                        row=2, col=2
                        )

      fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)
      fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)
      fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)
      fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)
      fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)
      fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)
      fig.update_layout(plot_bgcolor='white',
                        yaxis=dict(zerolinecolor='lightgrey'),
                        showlegend=True, #showlegend,
                        margin=dict(
                            autoexpand=True,
                            l=0,
                            r=0,
                            t=2,
                            b=0
                            ))
      #fig.update_layout(showlegend=False,row=2, col=1)
      # fig.update_layout(showlegend=False,row=2, col=2)
      #fig.update_layout(fig1.layout)
      return fig

  @fig_background
  def plot_ffb_times(modes, y1, y2, label1, label2):

      fig = None
      fig = uplotly.lines2d(modes, y1, fig,
                                dict(name=label1,
                                     line=dict(color="blue")
                                     ),
                                dict())

      fig = uplotly.lines2d(modes, y2, fig,
                            dict(name=label2,
                                 line=dict(color="red")
                                 ),
                            dict())          
      fig.update_yaxes(type="log", tickformat= '.0e', nticks=8)
      fig.update_layout(legend=dict(x=0.7, y=0.95),
                        height=650,
                        xaxis_title='Num. modes',
                        yaxis_title='Computational times [s]')
      return fig

  @fig_background
  def plot_ffb_error(modes, y1, label1):

      fig = None
      fig = uplotly.lines2d(modes, y1, fig,
                                dict(name=label1,
                                     line=dict(color="blue")
                                     ),
                                dict())
      fig.update_yaxes(type="log", tickformat= '.0e', nticks=8)
      fig.update_layout(showlegend=False,
                        #height=800,
                        xaxis_title='Num. modes',
                        yaxis_title='Cg error')
      return fig

  def get_trimaoa(ti, q, omega, phi1):
      q2= q[ti, 0:-1]
      q0i = - q2[2:]/ omega[2:]
      q0 = jnp.hstack([q2[:2], q0i])
      X0 = jnp.tensordot(phi1, q0, axes=(0, 0))
      return X0
  
#+end_src


* Results
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes :tangle ./results/examples.py :eval (print Veval_blocks) :exports (print export_blocks) :comments both
:END:

** Canonical case: unsupported dynamics of very flexible structure
This example exemplifies the ability of our solvers to turn a generic linear free-free finite-element model into a fully nonlinear solution that accounts for the rigid-body dynamics coupled with large elastic deformations. It has already been presented in [[cite:&PALACIOS2019]], though the novelties introduced herein are the new optimised implementation that can run on accelerators and the approach to recover the full 3D state from the reduced model.
The beam version of this structure was first studied by Simo and Vu-Quoc [[cite:&SIMO1988]] and has served to verify several implementations of nonlinear beam dynamics with rigid body motions [[cite:&HESSE2014]].
A straight structure of constant square cross section (side = 3, wall thickness = 3/10) is built consisting of 784 shell elements linked to 50 spanwise nodes via interpolation elements as depicted in Fig. [[fig:FFS]] together with the material properties and two types of loading: firstly, a dead-force in the x-direction and dead-moment in the z-direction that yield a planar motion in the x-y plane; and secondly, the addition of a moment in the y-direction which produces a three dimensional motion.

#+NAME: fig:FFS
#+CAPTION: FFS geometry, material properties and load cases
#+ATTR_LATEX: :width 0.7\textwidth 
[[file:figs_ext/ffbw10.pdf]]

The free-flying evolution of the 3D model is shown in Fig. [[fig:FFB_2D]] for the planar motion and Fig. [[fig:FFB_3D]] for the loads giving rise to the full 3D deformations. It worth remarking the latter motion also exhibits large torsional deformations which are combined with the also large bending displacements and rigid-body modes.

#+NAME: fig:FFB_2D
#+CAPTION: Free-flying structure in the 2D plane
#+ATTR_LATEX: :width 0.8\textwidth 
[[file:figs_ext/FFB_2D3.pdf]]


#+NAME: fig:FFB_3D
#+CAPTION: Free-flying structure in the 3D plane
#+ATTR_LATEX: :width 1.\textwidth 
[[file:figs_ext/FFB_3D3.pdf]]


Because the applied load is a dead force we can track the position of the center-of-gravity (CG) analytically as a verification exercise. Furthermore, the highly nonlinear nature of this problem makes it a good example to showcase the strength of accelerators for large problems and to gain insights as to when it might be better to deploy the codes in standard CPUs instead. Therefore we perform a sweep with the number of modes kept in the solution from 50 to 300, which determines the size of the system to be solved. The full modal basis is employed at 300 modes and due to the nonlinear cubic term this entails operations of the order of $O(10^7)$ at every time step of the solution, making it a good case for accelerators. The increase in the number of modes also restricts the incremental time step used in the explicit solver to preserve stability. Table [[table:FFB_times]] shows both computational time and CG error for the planar case in two scenarios: linking  the integration time-step to the largest eigenvalue $\lambda$ in the solution $dt=\lambda^{-0.5}$; and fixing it to $dt=10^{-3}$.
The error metric is defined as the L-2 norm divided by the time steps.
Computations have been carried out in AMD EPYC 7742 CPU processors and Nvidia GPU RTX 6000 at the Imperial College cluster.

# time steps = 0.001, 0.0028, 0.0061

#+NAME: table:FFB_times
#+CAPTION: FFB computational times in seconds and CG error
#+ATTR_LATEX: :center t
| Nmodes      | CPU (time/err) | GPU (time/err) | CPU (time/err) | GPU (time/err) |
|-------------+----------------+----------------+----------------+----------------|
| 50          | 7/1.3e-1       | 9.9/1.3e-1     | 42/2.1e-2      | 58/2.1e-2      |
| 100         | 9.3/5.7e-2     | 10.4/5.7e-2    | 184/1.2e-2     | 65/1.2e-2      |
| 150         | 34/2.2e-2      | 14/2.2e-2      | 287/5.6e-3     | 67/5.6e-3      |
| 200         | 79/2e-3        | 22/2e-3        | 421/7.2e-4     | 76/7.2e-4      |
| 250         | 474/5.3e-4     | 38/5.3e-4      | 893/2.7e-4     | 94/2.7e-4      |
| 300         | 1869/2.54e-5   | 111/2.54e-5    | 1869/2.54e-5   | 111/2.54e-5    |
|-------------+----------------+----------------+----------------+----------------|

Fig. [[fig:FFBtimes2]] and [[fig:FFBerror2]] illustrate the times and error results in the table for the second case with fixed time step. The gain in performance from the GPU is is more impressive the larger the system to solve, and for the full modal basis the CPU takes more than 31 minutes versus the less than 2 minutes in the GPU. Computational times in the 3D problem are similar and the error on the CG position is slightly higher: for the 300 modes case, the error is $6.9e-5$ versus the $2.54e-5$ of the planar case.  

#+NAME: FFBtimes1
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  modes = [50,100,150,200,250,300]
  err1 = [1.3e-1, 5.7e-2, 2.2e-2, 2e-3, 5.3e-4, 2.54e-5]
  err2 = [2.1e-2, 1.2e-2, 5.6e-3, 7.2e-4, 2.7e-4, 2.54e-5]
  gpu_times1 = [9.9, 10.4, 14, 22, 38, 111]
  cpu_times1 = [7, 9.3, 34, 79, 474, 1869]
  gpu_times2 = [58, 65, 67, 76, 94, 111]
  cpu_times2 = [42, 184, 287, 421, 893, 1869]
  fig, figname = fig_out(name)(plot_ffb_times)(modes, gpu_times1, cpu_times1, "GPU", "CPU")
  #figname
#+end_src

#+RESULTS: FFBtimes1
[[file:]]

#+NAME: FFBtimes2
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  fig, figname = fig_out(name)(plot_ffb_times)(modes, gpu_times2, cpu_times2, "GPU", "CPU")
  figname
#+end_src

#+NAME: fig:FFBtimes2
#+CAPTION: Performance CPU vs GPU comparison in free-flying structure (fixed time step)
#+ATTR_LATEX: :width 0.5\textwidth 
#+RESULTS: FFBtimes2
[[file:figs/FFBtimes2.png]]

#+NAME: FFBerror1
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  fig, figname = fig_out(name)(plot_ffb_error)(modes, err1, 'L2-norm Error')
  figname
#+end_src

#+RESULTS: FFBerror1
[[file:figs/FFBerror1.png]]

#+NAME: FFBerror2
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  fig, figname = fig_out(name, update_layout=dict(showlegend=False))(plot_ffb_error)(modes, err2, 'L2-norm Error')
  figname
#+end_src

#+NAME: fig:FFBerror2
#+CAPTION: Error metric CG position for planar case
#+ATTR_LATEX: :width 0.5\textwidth 
#+RESULTS: FFBerror2
[[file:figs/FFBerror2.png]]


** XRF1


*** Trim flight

#+NAME: TrimXRF1
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context)) :tangle ./results/run.py
  sol1= solution.IntrinsicReader("./xrf1trim_1")
  X0 = [get_trimaoa(i,
                   sol1.data.staticsystem_s1.q,
                   sol1.data.modes.omega,
                   sol1.data.modes.phi1) for i in range(len(sol1.data.staticsystem_s1.q))]
  #sol2= solution.IntrinsicReader("./XRF2")
  #fig, figname = fig_out(name)(subplots_wtips)(xrf1_wingtip2, sol1.data.dynamicsystem_s2.t, #sol1.data.dynamicsystem_s2.ra, labels=[1,2], node=0)
  #figname
#+end_src

#+NAME: TrimXRF1l
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context)) :tangle ./results/run.py
  sol1= solution.IntrinsicReader("./xrf1trim_1l")
  X0 = [get_trimaoa(i,
                   sol1.data.staticsystem_s1.q,
                   sol1.data.modes.omega,
                   sol1.data.modes.phi1) for i in range(len(sol1.data.staticsystem_s1.q))]
  #sol2= solution.IntrinsicReader("./XRF2")
  #fig, figname = fig_out(name)(subplots_wtips)(xrf1_wingtip2, sol1.data.dynamicsystem_s2.t, #sol1.data.dynamicsystem_s2.ra, labels=[1,2], node=0)
  #figname
#+end_src


*** Gust response
