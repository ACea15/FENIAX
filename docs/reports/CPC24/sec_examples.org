#+setupfile: ./config.org
# https://stackoverflow.com/questions/44414584/how-to-export-a-org-mode-table-to-latex-with-the-correct-placement-h
* House keeping  :noexport: 
#+begin_src elisp :results none :tangle no :exports none
  (add-to-list 'org-structure-template-alist
  '("sp" . "src python :session (print pythonShell)"))
  (add-to-list 'org-structure-template-alist
  '("se" . "src elisp"))
  (setq org-confirm-babel-evaluate nil)
  (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='pdflatex --syntex=1 -shell-escape -interaction nonstopmode' -pdf -bibtex -f %f"
          "latexmk -pdflatex='pdflatex --syntex=1 -shell-escape -interaction nonstopmode' -pdf -bibtex -f %f"))
  ;; (setq org-latex-pdf-process (list "latexmk -f -pdf -interaction=nonstopmode -output-directory=%o %f"))
  (pyvenv-workon "fem4inas")
  (require 'org-tempo)
  ;; Veval_blocks -> eval blocks of latex
  ;; Veval_blocks_run -> eval blocks to obtain results
  (setq Veval_blocks "yes") ;; yes, no, no-export 
  (setq Veval_blocks_run "no-export")
  (setq pythonShell "py2")
  ;; export_blocks: code, results, both, none
  (setq export_blocks  "results")  
#+end_src

* Load modules :noexport: 
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes  :eval (print Veval_blocks) :exports (print export_blocks) :comments both
:END:

#+begin_src python  :results none 
  import plotly.express as px
  import pyNastran.op4.op4 as op4
  import matplotlib.pyplot as plt
  import pdb
  import datetime
  import os
  import shutil
  REMOVE_RESULTS = False
  #   for root, dirs, files in os.walk('/path/to/folder'):
  #       for f in files:
  #           os.unlink(os.path.join(root, f))
  #       for d in dirs:
  #           shutil.rmtree(os.path.join(root, d))
  # 
  if os.getcwd().split('/')[-1] != 'results':
      if not os.path.isdir("./figs"):
          os.mkdir("./figs")
      if REMOVE_RESULTS:
          if os.path.isdir("./results"):
              shutil.rmtree("./results")
      if not os.path.isdir("./results"):
          print("***** creating results folder ******")
          os.mkdir("./results")
      os.chdir("./results")
#+end_src

#+NAME: PYTHONMODULES
#+begin_src python  :results none  :tangle ./results/run.py
  import pathlib
  import plotly.express as px
  import pickle
  import jax.numpy as jnp
  import jax
  import pandas as pd
  from plotly.subplots import make_subplots
  import numpy as np
  import fem4inas.preprocessor.configuration as configuration  # import Config, dump_to_yaml
  from fem4inas.preprocessor.inputs import Inputs
  import fem4inas.fem4inas_main
  import fem4inas.plotools.uplotly as uplotly
  import fem4inas.plotools.utils as putils
  import fem4inas.preprocessor.solution as solution
  import fem4inas.unastran.op2reader as op2reader
  import fem4inas.plotools.nastranvtk.bdfdef as bdfdef
  from tabulate import tabulate

#+end_src

* Plotting                                                         :noexport: 
:PROPERTIES:
:header-args:  :session (print pythonShell) :noweb yes :tangle ./results/examples.py :eval (print Veval_blocks) :exports (print export_blocks) :comments both
:END:
** Helper functions

#+begin_comment
https://plotly.com/python/subplots/
#+end_comment

#+begin_src python :results none  :var name=(org-element-property :name (org-element-context))

  def fig_out(name, figformat="png", update_layout=None):
      def inner_decorator(func):
          def inner(*args, **kwargs):
              fig = func(*args, **kwargs)
              if update_layout is not None:
                  fig.update_layout(**update_layout)
              fig.show()
              figname = f"figs/{name}.{figformat}"
              fig.write_image(f"../{figname}")
              return fig, figname
          return inner
      return inner_decorator


  def fig_background(func):

      def inner(*args, **kwargs):
          fig = func(*args, **kwargs)
          # if fig.data[0].showlegend is None:
          #     showlegend = True
          # else:
          #     showlegend = fig.data[0].showlegend

          fig.update_xaxes(
                         titlefont=dict(size=14),
                         tickfont = dict(size=14),
                         mirror=True,
                         ticks='outside',
                         showline=True,
                         linecolor='black',
              #zeroline=True,
          #zerolinewidth=2,
              #zerolinecolor='LightPink',
                         gridcolor='lightgrey')
          fig.update_yaxes(tickfont = dict(size=14),
                         titlefont=dict(size=14),
                         zeroline=True,
                         mirror=True,
                         ticks='outside',
                         showline=True,
                         linecolor='black',
                         gridcolor='lightgrey')
          fig.update_layout(plot_bgcolor='white',
                            yaxis=dict(zerolinecolor='lightgrey'),
                            showlegend=True, #showlegend,
                            margin=dict(
                                autoexpand=True,
                                l=0,
                                r=0,
                                t=2,
                                b=0
                            ))
          return fig
      return inner

  @fig_background
  def xrf1_wingtip(sol, dim, nast_scale=None, nast_load=None):
      scale = 100./33.977
      fig=None
      x, y = putils.pickIntrinsic2D(sol.data.dynamicsystem_s1.t,
                                    sol.data.dynamicsystem_s1.ra,
                                    fixaxis2=dict(node=150, dim=dim))

      fig = uplotly.lines2d(x[1:], (y[:-1]-y[0])*scale, fig,
                            dict(name="NMROM",
                                 line=dict(color="navy")
                                 ))
      if nast_scale is not None:
          offset = 0. #u111m[nast_load,0,-1, dim]
          fig = uplotly.lines2d(t111m[nast_load], (u111m[nast_load,:,-1, dim] -
                                                   offset) * nast_scale*scale, fig,
                                dict(name="NASTRAN",
                                     line=dict(color="grey",
                                               dash="dot")
                                     ))
      dim_dict = {0:'x', 1:'y', 2:'z'}
      fig.update_yaxes(title='$\hat{u}'+f'_{dim_dict[dim]}$')
      fig.update_xaxes(range=[0, 4], title='time [s]')
      #fig.update_yaxes(range=[-0.1, 0.2])
      fig.update_layout(yaxis=dict(zerolinecolor='black'))      
      return fig

  @fig_background
  def xrf1_wingtip2(sol1, sol2, dim, labels=None,nast_scale=None, nast_load=None):
      scale = 1./33.977
      fig=None
      x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,
                                    sol1.data.dynamicsystem_s1.ra,
                                    fixaxis2=dict(node=150, dim=dim))
      x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,
                                    sol2.data.dynamicsystem_s1.ra,
                                    fixaxis2=dict(node=150, dim=dim))

      fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,
                            dict(name=f"NMROM-G{labels[0]}",
                                 line=dict(color="orange")
                                 ))
      fig = uplotly.lines2d(x2[1:], (y2[:-1]-y2[0])*scale, fig,
                            dict(name=f"NMROM-G{labels[1]}",
                                 line=dict(color="steelblue")
                                 ))

      if nast_scale is not None:
          offset = 0. #u111m[nast_load[0],0,-1, dim]
          fig = uplotly.lines2d(t111m[nast_load[0]], (u111m[nast_load[0],:,-1, dim] - offset)*nast_scale*scale, fig,
                                dict(name=f"NASTRAN-G{labels[0]}",
                                     line=dict(color="black",
                                               dash="dash",
                                               width=1.5)
                                     ))
          offset2 = 0. #u111m[nast_load[1],0,-1, dim]
          fig = uplotly.lines2d(t111m[nast_load[1]], (u111m[nast_load[1],:,-1, dim] - offset2)*nast_scale*scale, fig,
                                dict(name=f"NASTRAN-G{labels[1]}",
                                     line=dict(color="red",
                                               dash="dot",
                                               width=1.5)
                                     ))
      dim_dict = {0:'x', 1:'y', 2:'z'}
      fig.update_yaxes(title=r'\large $\hat{u}%s$'%dim_dict[dim])
      fig.update_xaxes(range=[0, 4], title='time [s]')
      return fig

  def subplots_wtips(fun, *args, **kwargs):

      fig1 = fun(*args, dim=0, **kwargs)
      fig2 = fun(*args, dim=1, **kwargs)
      fig3 = fun(*args, dim=2, **kwargs)
      fig3.update_xaxes(title=None)
      fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.135, vertical_spacing=0.1,
                          specs=[[{"colspan": 2}, None],
                                 [{}, {}]])
      for i, f3i in enumerate(fig3.data):
          fig.add_trace(f3i,
                        row=1, col=1
                        )
      for i, f1i in enumerate(fig1.data):
          f1inew = f1i
          f1inew.showlegend = False          
          fig.add_trace(f1inew,
                        row=2, col=1
                        )
      for i, f2i in enumerate(fig2.data):
          f2inew = f2i
          f2inew.showlegend = False          
          fig.add_trace(f2inew,
                        row=2, col=2
                        )

      fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)
      fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)
      fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)
      fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)
      fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)
      fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)
      fig.update_layout(plot_bgcolor='white',
                        yaxis=dict(zerolinecolor='lightgrey'),
                        showlegend=True, #showlegend,
                        margin=dict(
                            autoexpand=True,
                            l=0,
                            r=0,
                            t=2,
                            b=0
                            ))
      #fig.update_layout(showlegend=False,row=2, col=1)
      # fig.update_layout(showlegend=False,row=2, col=2)
      #fig.update_layout(fig1.layout)
      return fig


  def subplots_xrf1wtips(sol1, sol2, labels=None, nast_scale=None, nast_load=None):

      fig1 = xrf1_wingtip2(sol1, sol2, 0, labels,nast_scale, nast_load)
      fig2 = xrf1_wingtip2(sol1, sol2, 1, labels,nast_scale, nast_load)
      fig3 = xrf1_wingtip2(sol1, sol2, 2, labels,nast_scale, nast_load)
      fig = make_subplots(rows=2, cols=2, horizontal_spacing=0.1, vertical_spacing=0.1,
                          specs=[[{"colspan": 2}, None],
                                 [{}, {}]])
      for i, f3i in enumerate(fig3.data):
          fig.add_trace(f3i,
                        row=1, col=1
                        )
      for i, f1i in enumerate(fig1.data):
          f1inew = f1i
          f1inew.showlegend = False          
          fig.add_trace(f1inew,
                        row=2, col=1
                        )
      for i, f2i in enumerate(fig2.data):
          f2inew = f2i
          f2inew.showlegend = False          
          fig.add_trace(f2inew,
                        row=2, col=2
                        )

      fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)
      fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)
      fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)
      fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)
      fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)
      fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)
      fig.update_layout(plot_bgcolor='white',
                        yaxis=dict(zerolinecolor='lightgrey'),
                        showlegend=True, #showlegend,
                        margin=dict(
                            autoexpand=True,
                            l=0,
                            r=0,
                            t=2,
                            b=0
                            ))
      #fig.update_layout(showlegend=False,row=2, col=1)
      # fig.update_layout(showlegend=False,row=2, col=2)
      #fig.update_layout(fig1.layout)
      return fig

  @fig_background
  def xrf1_wingtip4(sol1, sol2, sol3, sol4, dim, labels=None,nast_scale=None, nast_load=None):
      scale = 100./33.977
      fig=None
      x1, y1 = putils.pickIntrinsic2D(sol1.data.dynamicsystem_s1.t,
                                      sol1.data.dynamicsystem_s1.ra,
                                      fixaxis2=dict(node=150, dim=dim))
      x2, y2 = putils.pickIntrinsic2D(sol2.data.dynamicsystem_s1.t,
                                      sol2.data.dynamicsystem_s1.ra,
                                      fixaxis2=dict(node=150, dim=dim))
      x3, y3 = putils.pickIntrinsic2D(sol3.data.dynamicsystem_s1.t,
                                      sol3.data.dynamicsystem_s1.ra,
                                      fixaxis2=dict(node=150, dim=dim))
      x4, y4 = putils.pickIntrinsic2D(sol4.data.dynamicsystem_s1.t,
                                      sol4.data.dynamicsystem_s1.ra,
                                      fixaxis2=dict(node=150, dim=dim))

      fig = uplotly.lines2d(x1[1:], (y1[:-1]-y1[0])*scale, fig,
                            dict(name=f"NMROM-{labels[0]}",
                                 line=dict(color="orange",
                                           dash="solid")
                                 ))
      fig = uplotly.lines2d(x2[:], (y2[:]-y2[0])*scale, fig,
                            dict(name=f"NMROM-{labels[1]}",
                                 line=dict(color="blue", dash="dot")
                                 ))
      fig = uplotly.lines2d(x3[:], (y3[:]-y3[0])*scale, fig,
                            dict(name=f"NMROM-{labels[2]}",
                                 line=dict(color="red")
                                 ))
      fig = uplotly.lines2d(x4[:], (y4[:]-y4[0])*scale, fig,
                            dict(name=f"NMROM-{labels[3]}",
                                 line=dict(color="grey", dash="dash")
                                 ))

      dim_dict = {0:'x', 1:'y', 2:'z'}
      fig.update_yaxes(title='$\hat{u}' + f'_{dim_dict[dim]}$')
      fig.update_xaxes(range=[0, 4], title='time [s]')
      return fig

  @fig_background
  def wsp_wingtip(sol_list, dim, labels=None, nast_load=None, axes=None):
      scale = 1./28.8
      fig = None
      colors=["red", "darkgreen",
              "blue", "magenta", "steelblue"]
      dash = ['dash', 'dot', 'dashdot']
      modes = [5, 15, 30, 50, 100]
      for i, si in enumerate(sol_list):
          x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,
                                        si.data.dynamicsystem_s1.ra,
                                        fixaxis2=dict(node=23, dim=dim))
          if i != len(sol_list) - 1:
            fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,
                                  dict(name=f"NMROM-{modes[i]}",
                                       line=dict(color=colors[i],
                                                 dash=dash[i % 3])
                                       ),
                                  dict())
          else:
            fig = uplotly.lines2d(x, (y - y[0]) * scale, fig,
                                  dict(name=f"NMROM-{modes[i]}",
                                       line=dict(color=colors[i])
                                       ),
                                  dict())              
      if nast_load is not None:
          fig = uplotly.lines2d(t_wsp[nast_load], u_wsp[nast_load,:,-4, dim]* scale, fig,
                                dict(name="NASTRAN-400",
                                     line=dict(color="black",
                                               dash="dash")
                                     ))
          fig = uplotly.lines2d(t_wspl[nast_load], u_wspl[nast_load,:,-4, dim]* scale, fig,
                                dict(name="NASTRAN-109",
                                     line=dict(color="orange",
                                               #dash="dash"
                                               )
                                     ))
      dim_dict = {0:'x', 1:'y', 2:'z'}
      if axes is None:
          fig.update_yaxes(title=r'\large $\hat{u}_%s$'%dim_dict[dim])
          fig.update_xaxes(range=[0, 15], title='time [s]')
      else:
          fig.update_yaxes(range=axes[1], title=r'\large $\hat{u}_%s$'%dim_dict[dim])
          fig.update_xaxes(range=axes[0], title='time [s]')

      return fig

  def subplots_wsp(sol_list, labels=None, nast_load=None, axes=None):

      fig1 = wsp_wingtip(sol_list, 0, labels, nast_load, axes)
      fig2 = wsp_wingtip(sol_list, 1, labels, nast_load, axes)
      fig3 = wsp_wingtip(sol_list, 2, labels, nast_load, axes)
      fig = make_subplots(rows=2, cols=2, horizontal_spacing=1, vertical_spacing=5,
                          specs=[[{"colspan": 2}, None],
                                 [{}, {}]])
      for i, f3i in enumerate(fig3.data):
          fig.add_trace(f3i,
                        row=1, col=1
                        )
      for i, f1i in enumerate(fig1.data):
          f1inew = f1i
          f1inew.showlegend = False          
          fig.add_trace(f1inew,
                        row=2, col=1
                        )
      for i, f2i in enumerate(fig2.data):
          f2inew = f2i
          f2inew.showlegend = False          
          fig.add_trace(f2inew,
                        row=2, col=2
                        )

      fig.update_xaxes(fig1.layout.xaxis,row=2, col=1)
      fig.update_yaxes(fig1.layout.yaxis,row=2, col=1)
      fig.update_xaxes(fig2.layout.xaxis,row=2, col=2)
      fig.update_yaxes(fig2.layout.yaxis,row=2, col=2)
      fig.update_xaxes(fig3.layout.xaxis,row=1, col=1)
      fig.update_yaxes(fig3.layout.yaxis,row=1, col=1)
      fig.update_layout(plot_bgcolor='white',
                        yaxis=dict(zerolinecolor='lightgrey'),
                        showlegend=True, #showlegend,
                        margin=dict(
                            autoexpand=True,
                            l=0,
                            r=0,
                            t=2,
                            b=0
                            ))
      #fig.update_layout(showlegend=False,row=2, col=1)
      # fig.update_layout(showlegend=False,row=2, col=2)
      #fig.update_layout(fig1.layout)
      return fig

  def fn_spErrorold(sol_list, config, print_info=True):

    sol_sp= [solution.IntrinsicReader(f"./SP{i}") for i in range(1,6)]
    err = {f"M{i}_L{j}": 0. for i in range(1,6) for j in range(6)}
    for li in range(6): # loads
      for mi in range(1,6):  # modes
        count = 0  
        for index, row in config.fem.df_grid.iterrows():
          r_spn = u_sp[li, row.fe_order,:3] + config.fem.X[index]
          r_sp = sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index]
          err[f"M{mi}_L{li}"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)
          # print(f"nas = {r_spn}  ,  {r_sp}")
          count += 1
        err[f"M{mi}_L{li}"] /= count
        if print_info:
            print(f"**** LOAD: {li}, NumModes: {mi} ****")
            print(err[f"M{mi}_L{li}"])
    return err

  def fn_spError(sol_list, config, print_info=True):

      sol_sp= [solution.IntrinsicReader(f"./SP{i}") for i in range(1,6)]
      err = {f"M{i}_L{j}": 0. for i in range(1,6) for j in range(6)}
      for li in range(6): # loads
        for mi in range(1,6):  # modes
          count = 0
          r_spn = []
          r_sp = []
          for index, row in config.fem.df_grid.iterrows():
            r_spn.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])
            r_sp.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])
            # print(f"nas = {r_spn}  ,  {r_sp}")
            # count += 1
          r_spn = jnp.array(r_spn)
          r_sp = jnp.array(r_sp)        
          err[f"M{mi}_L{li}"] += jnp.linalg.norm(r_spn - r_sp) #/ jnp.linalg.norm(r_spn)
          err[f"M{mi}_L{li}"] /= len(r_sp)
          if print_info:
              print(f"**** LOAD: {li}, NumModes: {mi} ****")
              print(err[f"M{mi}_L{li}"])
      return err

  def fn_spWingsection(sol_list, config):

      sol_sp= [solution.IntrinsicReader(f"./SP{i}") for i in range(1,6)]
      r_spn = []
      r_spnl = []
      r_sp = []
      for li in range(6): # loads
        for mi in [4]:#range(1,6):  # modes
          r_spni = []
          r_spnli = []
          r_spi = []
          r_sp0 = []
          for index, row in config.fem.df_grid.iterrows():
            if row.fe_order in list(range(20)):
              r_sp0.append(config.fem.X[index])  
              r_spni.append(u_sp[li, row.fe_order,:3] + config.fem.X[index])
              r_spnli.append(u_spl[li, row.fe_order,:3] + config.fem.X[index])
              r_spi.append(sol_sp[mi - 1].data.staticsystem_s1.ra[li,:,index])
            # print(f"nas = {r_spn}  ,  {r_sp}")
            # count += 1

          r_spn.append(jnp.array(r_spni))
          r_spnl.append(jnp.array(r_spnli))
          r_sp.append(jnp.array(r_spi))
      r_sp0 = jnp.array(r_sp0)
      return r_sp0, r_sp, r_spn, r_spnl

  @fig_background
  def plot_spWingsection(r0, r, rn, rnl):
      fig = None
      # colors=["darkgrey", "darkgreen",
      #         "blue", "magenta", "orange", "black"]
      # dash = ['dash', 'dot', 'dashdot']
      modes = [5, 15, 30, 50, 100]
      for li in range(6):
        if li == 0:   
            fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,
                                  dict(name=f"NMROM",
                                       line=dict(color="blue",
                                                 dash="solid")
                                       ),
                                    dict())
            fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,
                                  dict(name=f"NASTRAN-400",
                                       line=dict(color="black",
                                                 dash="dash")
                                       ),
                                  dict())
            fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,
                                  dict(name=f"NASTRAN-101",
                                       line=dict(color="orange",
                                                 dash="solid")
                                       ),
                                  dict())

        else:
            fig = uplotly.lines2d((r[li][:,0]**2 + r[li][:,1]**2)**0.5, r[li][:,2]-r0[:,2], fig,
                                  dict(showlegend=False,
                                       line=dict(color="blue",
                                                 dash="solid")
                                       ),
                                    dict())
            fig = uplotly.lines2d((rn[li][:,0]**2 + rn[li][:,1]**2)**0.5, rn[li][:,2]-r0[:,2], fig,
                                  dict(showlegend=False,
                                       line=dict(color="black",
                                                 dash="dash")
                                       ),
                                  dict())
            fig = uplotly.lines2d((rnl[li][:,0]**2 + rnl[li][:,1]**2)**0.5, rnl[li][:,2]-r0[:,2], fig,
                                  dict(showlegend=False,
                                       line=dict(color="orange",
                                                 dash="solid")
                                       ),
                                  dict())            
      fig.update_yaxes(title='Uz [m]')
      fig.update_xaxes(title='S [m]', range=[6.81,36])

      # fig = uplotly.lines2d((rnl[:,0]**2 + rnl[:,1]**2)**0.5, rnl[:,2], fig,
      #                       dict(name=f"NASTRAN-101",
      #                            line=dict(color="grey",
      #                                      dash="solid")
      #                                  ),
      #                             dict())
      return fig

  @fig_background
  def fn_spPloterror(error):

      loads = [200, 250, 300, 400, 480, 530]
      num_modes = [5, 15, 30, 50, 100]
      e250 = jnp.array([error[f'M{i}_L1'] for i in range(1,6)])
      e400 = jnp.array([error[f'M{i}_L3'] for i in range(1,6)])
      e530 = jnp.array([error[f'M{i}_L5'] for i in range(1,6)])
      fig = None
      fig = uplotly.lines2d(num_modes, e250 , fig,
                                dict(name="Error, F = 250 KN",
                                     line=dict(color="red")
                                     ),
                                dict())
      fig = uplotly.lines2d(num_modes, e400, fig,
                                dict(name="Error, F = 400 KN",
                                     line=dict(color="green", dash="dash")
                                     ),
                                dict())
      fig = uplotly.lines2d(num_modes, e530, fig,
                                dict(name="Error, F = 530 KN",
                                     line=dict(color="black", dash="dot")
                                     ),
                                dict())
      fig.update_xaxes(title="Number of modes", tickfont = dict(size=13))
      fig.update_yaxes(title=r"$\large \epsilon$",type="log", tickformat= '.0e',tickfont = dict(size=13), tickvals=[2e-2, 1e-2, 7e-3,5e-3,3e-3, 2e-3, 1e-3,7e-4, 5e-4,3e-4, 2e-4, 1e-4, 7e-5, 5e-5])
      fig.update_layout(height=650)
      return fig

  @fig_background
  def fn_spPloterror3D(error, error3d):

      loads = [200, 250, 300, 400, 480, 530]
      fig = None
      if error is not None:
        fig = uplotly.lines2d(loads, error, fig,
                                  dict(name="Error ASET",
                                       line=dict(color="red"),
                                       marker=dict(symbol="square")
                                       ),
                                  dict())

      fig = uplotly.lines2d(loads, error3d, fig,
                                dict(name="Error full 3D",
                                     line=dict(color="green")
                                     ),
                                dict())

      fig.update_yaxes(type="log", tickformat= '.0e')
      fig.update_layout(height=700,
                        showlegend=False,
                        xaxis_title='Loading [KN]',
                        yaxis_title=r'\large $\epsilon$')

      return fig

  @fig_background
  def plot_spAD(rn, r0):

      loads = [200, 250, 300, 400, 480, 530]
      fig = None
      x = list(range(1,7))
      y = [rn[i-1][-1, 2] - r0[-1,2] for i in x]
      fig = uplotly.lines2d(x, y, fig,
                                  dict(#name="Error ASET",
                                       #line=dict(color="red"),
                                       #marker=dict(symbol="square")
                                       ),
                                  dict())


      #fig.update_yaxes(type="log", tickformat= '.0e')
      fig.update_layout(#height=700,
                        showlegend=False,
                        xaxis_title=r'$\Large{\tau}$',
                        yaxis_title='Uz [m]'
      )

      return fig

  def fn_wspError(sol_list):
      error_dict = dict()
      for i, si in enumerate(sol_list):
          for di in range(3):
              x, y = putils.pickIntrinsic2D(si.data.dynamicsystem_s1.t,
                                            si.data.dynamicsystem_s1.ra,
                                            fixaxis2=dict(node=23, dim=di))
              yinterp = jnp.interp(t_wsp, x, y)
              ynastran = u_wsp[0,:,-4, di] + y[0]
              n = 10000
              error = jnp.linalg.norm((yinterp[1,:n] - ynastran[:n]) / ynastran[:n]) / len(ynastran[:n])
              label = f"M{i}x{di}"
              error_dict[label] = error

      return error_dict

  @fig_background
  def fn_wspPloterror(error):

      loads = [200, 250, 300, 400, 480, 530]
      num_modes = [5, 15, 30, 50, 100]
      ex1 = [error[f'M{i}x0'] for i in range(5)]
      ex2 = [error[f'M{i}x1'] for i in range(5)]
      ex3 = [error[f'M{i}x2'] for i in range(5)]
      fig = None
      fig = uplotly.lines2d(num_modes, ex1, fig,
                                dict(name="Error - x1",
                                     line=dict(color="red")
                                     ),
                                dict())
      fig = uplotly.lines2d(num_modes, ex2, fig,
                                dict(name="Error - x2",
                                     line=dict(color="green")
                                     ),
                                dict())
      fig = uplotly.lines2d(num_modes, ex3, fig,
                                dict(name="Error - x3",
                                     line=dict(color="black")
                                     ),
                                dict())

      fig.update_yaxes(type="log", tickformat= '.0e')
      return fig

  @fig_background
  def fn_wspPloterror3D(time, error):

      fig = None
      fig = uplotly.lines2d(time, error, fig,
                                dict(name="Error",
                                     line=dict(color="blue")
                                     ),
                                dict())

      fig.update_yaxes(type="log", tickformat= '.0e', nticks=7)
      fig.update_layout(
                        #height=700,
                        xaxis_title='Time [s]',
                        yaxis_title=r'$\large \epsilon$')
      return fig

#+end_src

** NASTRAN data
Read data from Nastran simulations
#+begin_src python  :results none 

  <<PYTHONMODULES>>

  examples_path = pathlib.Path("../../../../examples")
  ####### SailPlane ###########
  SP_folder = examples_path / "SailPlane"
  #nastran_path = wingSP_folder / "NASTRAN/"

  op2model = op2reader.NastranReader(SP_folder / "NASTRAN/static400/run.op2",
                                     SP_folder / "NASTRAN/static400/run.bdf",
                                   static=True)

  op2model.readModel()
  t_sp, u_sp = op2model.displacements()

  op2modell = op2reader.NastranReader(SP_folder / "NASTRAN/static400/run_linear.op2",
                                     SP_folder / "NASTRAN/static400/run_linear.bdf",
                                   static=True)

  op2modell.readModel()
  t_spl, u_spl = op2modell.displacements()

  ####### wingSP ###########
  wingSP_folder = examples_path / "wingSP"
  nastran_path = wingSP_folder / "NASTRAN/"
  nas_wspl = op2reader.NastranReader(op2name=(nastran_path / "wing_109d.op2"),
                                     bdfname=(nastran_path / "wing_109b.bdf"))
  nas_wspl.readModel()
  t_wspl, u_wspl = nas_wspl.displacements()  
  # ###
  nas_wsp = op2reader.NastranReader(op2name=(nastran_path / "wing400d.op2"),
                                     bdfname=(nastran_path / "wing_109b.bdf"))
  nas_wsp.readModel()
  t_wsp, u_wsp = nas_wsp.displacements()
  ####### XRF1 ###########
  nastran_path = examples_path / "XRF1/NASTRAN/146-111/"
  nas111 = op2reader.NastranReader(op2name=(nastran_path / "XRF1-146run.op2"))
  nas111.readModel()
  t111, u111 = nas111.displacements()

  nastran_pathm = examples_path / "XRF1/NASTRAN/146-111_081"
  nas111m = op2reader.NastranReader(op2name=(nastran_pathm / "XRF1-146run.op2"))
  nas111m.readModel()
  t111m, u111m = nas111m.displacements()

  sp_error3d = jnp.load(examples_path/ "SailPlane/sp_err.npy")
  wsp_error3d = jnp.load(examples_path/ "wingSP/wsp_err.npy")

#+end_src

* Examples
:PROPERTIES:
:header-args: :mkdirp yes  :session (print pythonShell) :noweb yes :tangle ./results/examples.py :eval (print Veval_blocks) :exports (print export_blocks) :comments both
:END:
The cases presented are a demonstration of our solution approach to manage geometric nonlinearities, the accuracy of the solvers when compared to full FE simulations, and the computational gains that can be achieved.
All computations are carried out on a single core of the same CPU, an i7-6700 with 3.4 GHz clock speed.
# The previous version of the code based on Python was not optimised and made heavy use of for-loops instead of vectorised operations. The main reason to show those previous results is to highlight the potential improvements in scientific software when paying attention to the implementation solely.
** Structural verification of a representative configuration
\label{sec:representative_aircraft}

A representative FE model of a full aircraft without engines is used to demonstrate  a versatile solution that accounts for geometric nonlinearities in a very efficient manner and only needs modal shapes and linear FE matrices from a generic FE solver as inputs. Another of the goals set for this work was to achieve an equally flexible strategy in the automatic calculation of derivatives across the various solvers in the code. The structural static and dynamic responses and their sensitivities with respect to input parameters are verified against MSC Nastran and finite differences respectively.
\\
The aircraft’s main wing is composed of wing surfaces, rear and front spars, wing box and ribs with composite materials employed in the construction. Flexible tail and rear stabiliser are rigidly attached to the wing (28.8 m of span), as  shown in Fig. [[fig:SailPlane2]]. This aircraft was first used in [[cite:&CEA2021a]] and is a good test case as it is not very complex yet representative of aircraft FE models and it is available open source.  

#+NAME: fig:SailPlane2
#+CAPTION: Representative engineless aeroplane structural FE model
#+ATTR_LATEX: :width 0.7\textwidth 
[[file:figs_ext/SailPlaneRef.png]]

A Guyan reduction is employed in the reduction process and Fig. [[fig:modes]] illustrates the accuracy of the condensed model by comparing the 3D modal shapes. No differences can be appreciated for the first few modes (the lowest frequency corresponding to a bending mode agrees in both models at $\omega_1=4.995$ rads/s) so we show higher frequency modes: a high order bending mode ($\omega_{10}=60.887/60.896$ rads/s in full versus reduced models) and a torsional mode ($\omega_{20}=107.967/107.969$ rads/s). This very good preservation of the full model leads to an excellent accuracy in the static and dynamic results presented below. It is important to remark this aircraft model is typical of previous generations airliners and does not feature high-aspect ratio wings. Therefore while this modelling strategy would not be suitable for every engineering structure, as long as there is a dominant dimension and deformations in the other two remain small (as is the case in high level descriptions of aircraft, bridges or wind turbines) it has been found to produce very good approximations when compared with full dimensional solutions.
The computations in this section were carried out on a single CPU with a i7-6700 processor. 

#+NAME: fig:modes2
#+CAPTION: Full VS reduced order models on the 10th modal shape $\omega_{10}=60.887/60.896$ rads/s
#+ATTR_LATEX: :width 0.6\textwidth 
[[file:figs_ext/SPM7af2.pdf]]

#+NAME: fig:modes
#+CAPTION: Full VS reduced order models on the 20th modal shape, $\omega_{20}=107.97$ rads/s
#+ATTR_LATEX: :width 0.6\textwidth 
[[file:figs_ext/SPM19af2.pdf]]

*** Geometrically nonlinear static response
The static equilibrium of the aircraft under prescribed loads is first studied with follower loads normal to the wing applied at the tip of each wing. The response for an increasing load stepping of 200, 300, 400, 480 and 530 KN is computed. Nonlinear static simulations on the original full model (before condensation) are also carried out in MSC Nastran and are included. The interpolation elements in Nastran are used to output the displacements at the condensation nodes for direct comparison with the NMROM results.
Geometric nonlinearities are better illustrated by representing a sectional view of the wing as in Fig. [[fig:SPWingsection]], where deformations in the z-direction versus the metric $S = \sqrt{x^2+y^2}$ are shown. MSC Nastran linear solutions (Solution 101) are also included to appreciate more clearly the shortening and follower force effects in the nonlinear computations.

\begin{minted}[
    gobble=2,
    frame=single,
    linenos
  ]{yaml}
  Ka_name: Ka.npy
  # Condensed mass matrix
  Ma_name: Ma.npy
  # Number of modes in the solution
  num_modes: 50
  # Calculation of eigenvalues/vectors
  eig_type: input_memory
  # cut-off frequency such that eigenvalues smaller than this are set to 0
  eig_cutoff: 0.01
  # Tolerance for building the local frames
  Cab_xtol: 0.0001
  # System name
  name: s1
  # Type of solution to be solved
  solution: dynamic
  # The simulation goal of this system
  target: Level
  # Boundary condition first node
  bc1: clamped
  # Save results of the run system
  save: true
  xloads:
    # Include gravity in the analysis
    gravity_forces: true
    # Include aerodynamic forces
    modalaero_forces: true
    # gravity force [m/s]
    gravity: 9.807
    # gravity vector
    gravity_vect:
    - 0
    - 0
    - -1
  aero:
    u_inf: 200.0
    rho_inf: 1.225
    c_ref: 7.271
    approx: Roger
    num_poles: 8
    gust_profile: mc
    gust:
      intensity: 28.1464623124
      step: 1.0
      length: 67.0
      shift: 0.0
  # Library solving our system of equations
  solver_library: diffrax
  # Name for the solver of the previously defined library
  solver_function: ode
  # Settings for the solver
  solver_settings:
    solver_name: Dopri5
\end{minted}


#+NAME: fig:SPWingsection
#+CAPTION: Static geometrically-nonlinear effects on the aircraft main wing 
#+ATTR_LATEX: :width 0.5\textwidth 
#+RESULTS: SPWingsection
[[file:figs/SPWingsection.png]]

The tolerance in the Newton solver was set to $10^{-6}$ in all cases.
A convergence analysis with the number of modes in the solution is presented in Fig. [[SPstatic_convergence]].
5, 15, 30, 50, 100 modes are used to build the corresponding NMROMs.
The error metric is defined as the $\ell^2$ norm divided by the total number of nodes (only the condenses ones in this case): $\epsilon = ||u_{NMROM} - u_{NASTRAN}||/N_{nodes}$. It can be seen the solution with 50 modes already achieves a very good solution even for the largest load which produces a 25.6$\%$ tip deformation of the wing semi-span, $b = 28.8$ m. The displacement difference with the full FE solution at the tip in this case is less than 0.2$\%$.

#+NAME: SPstatic_convergence
#+CAPTION: Modal convergence static solution of representative aircraft
#+ATTR_LATEX: :width 0.45\textwidth 
#+RESULTS: SPerror
[[file:figs/SPerror.png]]

The 3D structural response has been reconstructed using the approach in Fig. [[workflow]].
The nodes connected by the interpolation elements (RBE3s) to the ASET solution are reconstructed first and subsequently a model with RBFs kernels is used to extrapolate to the rest of the nodes in the full FE.
A very good agreement is found against the geometrically-nonlinear Nastran solution (SOL 400). 
Fig. [[SPstatic_3D]]  shows the overlap in the Nastran solution (in red) and the NMROM (in blue) for the 530 KN loading.

#+NAME: SPstatic_3D
#+CAPTION: Static 3D solution for a solution with 50 modes and 530 KN loading (Full NASTRAN solution in red versus the NMROM in blue). 
#+ATTR_LATEX: :width 0.7\textwidth 
[[./figs_ext/SP_3Dloading-front2.png]]
[[./figs_ext/SP_3Dloading-side.png]]
The error metric of this 3D solution is also assessed in Fig. [[fig:SPerror3D]], for the solution with 50 modes. The discrepancy metric is of the same order than the previously shown at the reduction points. This conveys an important point, that there is no significant accuracy loss in the process of reconstructing the 3D solution.

#+NAME: fig:SPerror3D
#+CAPTION: Relative error between full FE and NMROM solutions
#+ATTR_LATEX: :width 0.4\textwidth 
#+RESULTS: SPerror3D
[[file:figs/SPerror3D.png]]

Next we compare the computational times for the various solutions presented in this section in Table [[table:SP_times]]. Computations of the six load steps in Fig. [[fig:SPWingsection]] are included in the assessment. A near 50 times speed-up is achieved with our solvers compared to Nastran nonlinear solution, which is one of the main strengths of the proposed method. As expected, the linear static solution in Nastran is the fastest of the results, given it only entails solving a linear, very sparse system of equations.

#+NAME: table:SP_times
#+CAPTION: Computational times static solution
#+ATTR_LATEX: :center t  
#+RESULTS: SP_times
|          | NMROM (modes: 5, 15, 30, 50, 100) | NASTRAN 400 | NASTRAN 101 |
|----------+-----------------------------------+-------------+-------------|
| Time [s] | 6.7, 6.63, 6.79, 7.06, 9.55       |         345 |        1.02 |

*** Differentiation of static response
The AD for the static solvers is first verified as follows: the load stepping shown above becomes a pseudo-time interpolation load such that a variable $\tau$ controls the amount of loading and we look at the variation of the wing-tip displacement as a function of this $\tau$. If \(f(\tau=[1, 2, 3, 4, 5, 6]) = [200, 250, 300, 400, 480, 530]\) KN, with a linear interpolation between points, the derivative of the z-component of the tip of the wing displacements is computed at \(\tau= 1.5, 3.5, 5.5 \), as show in Fig. [[fig:sp_ad]] with red points. 

#+NAME: fig:sp_ad
#+CAPTION: Static tip displacement with pseudo-time stepping load
#+ATTR_LATEX: :width 0.5\textwidth 
file:figs_ext/sp_ad.pdf
Table [[table:SP_AD]] shows a very good agreement against finite-differences (FD) with an epsilon of $10^{-3}$. Note how the derivative at each of the marked points corresponds approximately to the slope in the graph at those very points, which varies as the load steps are not of equal length. And the biggest slope occurs precisely in between \(\tau\) of 4 and 5 when the prescribed loading undergoes the biggest change from 300 to 400 KN.

#+NAME: table:SP_AD
#+CAPTION: AD verification in static problem
#+ATTR_LATEX: :center t
| $\tau$ | $f(\tau)$ [m] | $f'(\tau)$ (AD) | $f'(\tau)$ (FD) |
|--------+---------------+-----------------+-----------------|
|    1.5 |          2.81 |           0.700 |           0.700 |
|    3.5 |         4.527 |           1.344 |           1.344 |
|    5.5 |         6.538 |           0.623 |           0.623 |

*** Large-amplitude nonlinear dynamics
This test case demonstrates the accuracy of the NMROM approach for  dynamic geometrically-nonlinear calculations and was first introduced in [[cite:&CEA2021b]]. The right wing of Fig. [[fig:SailPlane2]] is considered and dynamic nonlinear simulations are carried out and compared to MSC Nastran linear and nonlinear analysis (SOL 109 and 400, respectively) on the full FE model.
A force is applied at the wing tip with a triangular loading profile, followed by a sudden release of the applied force to heavily excite the wing. The force profile is given in Fig. [[fig:ramping_load]]. The applied force is then \(f_{tip} = \alpha \textup{\pmb{f}}_{max} f(0.05, 4)\) with  \(\textup{\pmb{f}}_{max} = [-2\times 10^5, 0., 6\times 10^5]\) where $\alpha$ has been set to $1$.

#+NAME: fig:ramping_load
#+CAPTION: Ramping load profile for dynamic simulation of representative wing 
#+ATTR_LATEX: :width 0.6\textwidth 
[[./figs_ext/ramping_load.pdf]]
The dynamic response is presented in Fig. [[fig:wsp_3d]], where results have been normalised with the wing semi-span ($l=28.8$ m). As expected, linear analysis over-predicts vertical displacements and does not capture displacements in the $x$ and $y$ directions. NMROMs were built with 5, 15, 30, 50 and 100 modes. A Runge-Kutta four is used to march the equation in time with time steps corresponding to the inverse of the largest eigenvalue in the NMROM, i.e. $\Delta t = [27.34, 6.62, 2.49, 1.27, 0.575] \times 10^{-3}$ s. 

#+NAME: fig:wsp_3d
#+ATTR_LATEX: :width 1\textwidth 
#+CAPTION: Span-normalised wing-tip displacements in the response to an initially ramped load
#+RESULTS: WSPsubplots
[[file:figs/WSPsubplots.png]]


As in the previous example, the 3D shape of the model is retrieved and compared against the full nonlinear dynamic solution, as illustrated in Fig. [[wsp_3d]] (Nastran solution in yellow and NMROM with 50 modes in blue). The times at positive and negative peaks are displayed. Even though a wing of such characteristics would never undergo in practice this level of deformations, these results further support the viability of the methodology to solve highly geometrically nonlinear dynamics, on complex models and with minimal computational effort. 
#+NAME: wsp_3d
#+CAPTION: Snapshots of wing 3D dynamic response comparing NMROM (blue) and NLFEM3D (yellow)
#+ATTR_LATEX: :width 1\textwidth 
[[./figs_ext/WSP_3D-front.png]]

Next we look at the differences of the dynamic simulations with the same metric employed above that now evolves in time. Integration errors accumulate and discrepancies grow with time but still remain small. In fact the differences between Nastran and our dynamic solvers are comparable to the static example with the highest load (around the $5\times 10^{-5}$ mark). Both cases displaying maximum deformations around 25\% of the wing semi-span.

#+NAME: WSP_error
#+CAPTION: $\ell^2$ norm per node differences between Nastran full FE solution and NMROM with 50 modes
#+ATTR_LATEX: :width 0.7\textwidth 
#+RESULTS: WSP_error
[[file:figs/WSP_error.png]]

An impressive reduction of computational time is achieved by our solvers as highlighted in Table [[table:WSP_times]]. The nonlinear response of the full model in Nastran took 1 hour 22 minutes, which is over two orders of magnitude slower than the NMROM with 50 modes resolution, which proved very accurate. The significant increase in computational effort when moving from a solution with 50 modes to 100 modes is due to various factors: vectorised operations are limited and the quadratic nonlinearities ultimately lead to O($N_m^3$) algorithms; the time-step needs to be decreased for the Runge-Kutta integration to remain stable; the additional overheads that come with saving and moving larger tensors, from the modal shapes, the cubic modal couplings, to the system states (note times shown account for all the steps from start to end of the simulation, including saving all the data for postprocessing).

#+NAME: table:WSP_times
#+CAPTION: Computational times representative wing dynamic solution
#+ATTR_LATEX: :center t
#+RESULTS: WSP_times
|          | NMROM (modes: 5, 15, 30, 50, 100) | NASTRAN 400 | NASTRAN 109 |
|----------+-----------------------------------+-------------+-------------|
| Time [s] | 2.79, 2.92, 4.85, 12.14, 155.3    |        4920 |        33.6 |

*** Differentiation of dynamic response
We move now to a novel feature of this work, i.e. the ability to compute gradients via automatic differentiation in geometrically nonlinear dynamic problems.
We note that this was not in the original work plan yet was attained without additional resources leveraging the capabilities of JAX. This approach brought constraints on the software development but if these are considered early on, the result is a fully-differentiated solution process.
The maximum root loads occurring in a wing subjected to dynamic loads is a good test case as it can be a critical metric in sizing the aircraft wings, especially high-aspect ratio ones. Thus we look at the variation of the maximum z-component of the vertical internal forces as a function of \(\alpha\) in the loading profile of Fig. [[fig:ramping_load]]. Effectively, the slope of the loading increases with \(\alpha\). Table [[table:AD_WSP]] shows the derivatives computed using FD with an epsilon of $10^{-4}$ and AD in reverse-mode on the example with 50 modes resolution. In this case the FD needed tweaking of epsilon while application of AD was straight forward with no need for checkpoints and took around three times the speed of a single calculation. 

#+NAME: table:AD_WSP
#+CAPTION: Automatic differentiation in dynamic problem
#+ATTR_LATEX: :center t
| $\alpha$ | $f(\alpha)$ [KN/m] | $f'(\alpha)$ (AD) | $f'(\alpha)$ (FD) |
|----------+--------------------+-------------------+-------------------|
|      0.5 | 1706.7             | 3587.71         | 3587.77         |
|      1.0 | 3459.9             | 3735.26         | 3735.11         |
|      1.5 | 5398.7             | 3957.81         | 3958.31         |

The increase in the internal loading, $f(\alpha)$, above the linear correlation with $\alpha$ is a consequence of high frequency dynamics being excited after the ramping load is suddenly released. In fact in the \(z\)-component of the wing-tip evolution in Fig. [[fig:wsp_adz]] we can see a maximum tip displacement of 4.36 m, 7.91 m and 10.83 m, for $\alpha = 0.5, 1, 1.5$ i.e smaller than the proportional linear response. On the other hand, in Fig. [[fig:wsp_adx2]] the evolution of the root loads show a response with much higher frequencies and the maximum occurs in the free dynamical response of the wing, which is higher as we increase $\alpha$.

#+NAME: fig:wsp_adz
#+ATTR_LATEX: :width 0.55\textwidth 
#+CAPTION: Span-normalised wing-tip \(z\)-displacement for load profiles with $\alpha = 0.5, 1, 1.5$
#+RESULTS: WSP_adz
[[file:figs/WSP_adz.png]]

#+NAME: fig:wsp_adx2
#+ATTR_LATEX: :width 0.55\textwidth 
#+CAPTION: Wing root loads, vertical force
#+RESULTS: WSP_adx2
[[file:figs/WSP_adx2.png]]

\newpage

** Aeroelastic dynamic loads on an industrial configuration
The studies presented in this section are based on a reference configuration developed to industry standards known as XRF1, which is representative of a long-range wide-body transport airplane. The version with a wing-tip extension in \cite{CEA2023} is employed to verify a gust response against NASTRAN linear solution.
Fig. [[fig:xrf1_modalshapes]] shows the reference FE model with three modal shapes. The FE model contains a total of around 177400 nodes, which are condensed into 176 active nodes along the reference load axes through interpolation elements. A Guyan or static condensation approach is used for the reduction. The aerodynamic model contains \(\sim 1,500\) aerodynamic panels. The simulations are carried out with a modal resolution of 70 modes and a time step in the Runge-Kutta solver of 0.005. 

\begin{minted}[
    gobble=2,
    frame=single,
    linenos
  ]{yaml}
  Ka_name: Ka.npy
  # Condensed mass matrix
  Ma_name: Ma.npy
  # Number of modes in the solution
  num_modes: 50
  # Calculation of eigenvalues/vectors
  eig_type: input_memory
  # cut-off frequency such that eigenvalues smaller than this are set to 0
  eig_cutoff: 0.01
  # Tolerance for building the local frames
  Cab_xtol: 0.0001
  # System name
  name: s1
  # Type of solution to be solved
  solution: dynamic
  # The simulation goal of this system
  target: Level
  # Boundary condition first node
  bc1: clamped
  # Save results of the run system
  save: true
  xloads:
    # Include gravity in the analysis
    gravity_forces: true
    # Include aerodynamic forces
    modalaero_forces: true
    # gravity force [m/s]
    gravity: 9.807
    # gravity vector
    gravity_vect:
    - 0
    - 0
    - -1
  aero:
    u_inf: 200.0
    rho_inf: 1.225
    c_ref: 7.271
    approx: Roger
    num_poles: 8
    gust_profile: mc
    gust:
      intensity: 28.1464623124
      step: 1.0
      length: 67.0
      shift: 0.0
  # Library solving our system of equations
  solver_library: diffrax
  # Name for the solver of the previously defined library
  solver_function: ode
  # Settings for the solver
  solver_settings:
    solver_name: Dopri5
\end{minted}



#+NAME: fig:xrf1_modalshapes
#+CAPTION: Modified XRF1 reference configuration with characteristic modal shapes
#+ATTR_LATEX: :width 0.8\textwidth 
[[file:figs/xrf1_modalshapes.pdf]]

To verify the accuracy of the reduction method we show now a comparison of some of the most relevant natural frequencies in Table \ref{table8:xrf1-frequencies} (normalized with the lowest frequency). It is common practice in this industrial aeroelastic models to represent the mass model as lumped masses along the load axis (provided by the mass department which thoroughly tracks the multiple components and combines them into sectional lumped points with inertia). As explained above, this makes the Guyan reduction match an exact condensation and explains the accuracy of the results. 
\begin{table}[h!]
\begin{center}
\caption{Normalised natural frequencies of the modified XRF1 clamped model}
\label{table8:xrf1-frequencies}
\begin{tabular}{c c c c}
\toprule
%\hline
\textbf{Mode Type}  & $ \pmb{\omega_{full}}$  &$ \pmb{\omega_{condensation}}$ & \textbf{Error} (\%) \\
First out-of-plane wing bending (1) &1.0              &1.0        &    0.0001   \\ 
First out-of-plane wing bending (2) &1.04948    &1.04949  &    0.0004   \\ 
First fuselage bending  (3)  &1.4285     &1.4288       &    0.025     \\ 
Fuselage lateral bending + wing out-of-plane bending (4) &1.5093      &1.5099       &    0.038     \\ 
Wing and pylon lateral roll bending (5)&2.1449      &2.1449       &    0.0007   \\ 
%&2.23018    &2.23018   &    0.0002   \\ 
%&2.316        &2.315            &    0.07     \\ 
%&2.4107      &2.4102        &    0.035    \\ 
%&2.45487   &2.45495  &    0.007    \\ 
%&2.506       &2.5052         &    0.06     \\
\vdots &  &        &       \\
First in-plane wing bending (13) &   3.156  &  3.155  &0.03  \\
Second in-plane wing bending (14) & 3.25655&  3.2566  &  0.0016  \\
\vdots &  &        &       \\
First wing torsion (28)   & 7.675 & 7.676&  0.01   \\
Second wing torsion (29) &   7.7368 & 7.7366   &0.002 \\
%\hline
\bottomrule
\end{tabular}
\end{center}
\end{table}

While the previous results where purely structural, now the dynamic response to an atmospheric disturbance or gust is computed. This aeroelastic analysis is a requirement for certification purposes and it is one of the main drivers in sizing the wings of high aspect ratio wings. Furthermore, the previous examples showed the advantage of our approach in terms of computational speed, but other than that results could be obtained with commercial software. The geometrically nonlinear aeroelastic response, however, it is not currently available in commercial solutions that are bounded to linear analysis in the frequency domain. Other research codes feature those additional physics, yet are limited to simple models. Thus the added value in the proposed approach comes at the intersection between the nonlinear physics arising from large integrated displacements, computational efficiency and the ability to enhance the models already built for industrial use.
\newpage
A verification exercise is introduced first by applying two 1-cos gust shapes at a very low intensity, thus producing small deformations and a linear response. The flow Mach number is 0.81. A first gust is applied that we name as G1 of length 67 m and peak velocity 0.141 m/s, and a second gust, G2, of 165 m and peak velocity of 0.164 m/s.
Fig. [[fig:GustXRF12]] shows the normalised wing-tip response with our NMROM that accurately reproduces the Nastran 146 solution based on the full FE model.

#+NAME: GustXRF12
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  sol1= solution.IntrinsicReader("./XRF1")
  sol2= solution.IntrinsicReader("./XRF2")
  fig, figname = fig_out(name)(subplots_wtips)(xrf1_wingtip2,sol1, sol2, labels=[1,2], nast_scale=0.01, nast_load=[2,6])
  figname
#+end_src

#+NAME: fig:GustXRF12
#+CAPTION: Wing-tip response to low intensity gust
#+ATTR_LATEX: :width 0.8\textwidth :placement [!h]
#+RESULTS: GustXRF12
[[file:figs/GustXRF12.png]]

# #+NAME: GustXRF12_x
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   sol1= solution.IntrinsicReader("./XRF1")
#   sol2= solution.IntrinsicReader("./XRF2")
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6], dim=0, nast_scale=0.01, nast_load=[2,6])
#   figname
# #+end_src

# #+NAME: fig:GustXRF12_x
# #+CAPTION: Wing-tip response to low intensity gust
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF12_x
# [[file:figs/GustXRF12_x.png]]

# #+NAME: GustXRF12_y
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6],dim=1, nast_scale=0.01, nast_load=[2,6])
#   figname
# #+end_src

# #+NAME: fig:GustXRF12_y
# #+CAPTION: $y$ Wing-tip response to low intensity gust
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF12_y
# [[file:figs/GustXRF12_y.png]]

# #+NAME: GustXRF12_z
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6],dim=2, nast_scale=0.01, nast_load=[2,6])
#   figname
# #+end_src

# #+NAME: fig:GustXRF12_z
# #+CAPTION: $z$ Wing-tip response to low intensity gust
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF12_z
# [[file:figs/GustXRF12_z.png]]

Next we increase the gust intensity by a factor of 200 in order to show the effects of geometric nonlinearities that are only captured by the nonlinear solver. As seen in Fig. [[fig:GustXRF34]], there are major differences in the $x$ and $y$ components of the response due to follower and shortening effects, and a slight reduction in the $z$-component. These are well known geometrically nonlinear effects that are added to the analysis with no significant overhead.

#+NAME: GustXRF34
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  sol1= solution.IntrinsicReader("./XRF3")
  sol2= solution.IntrinsicReader("./XRF4")
  fig, figname = fig_out(name)(subplots_wtips)(xrf1_wingtip2, sol1, sol2, labels=[1,2], nast_scale=2., nast_load=[2,6])
  figname
#+end_src

#+NAME: fig:GustXRF34
#+CAPTION: Wing-tip response to high intensity gust
#+ATTR_LATEX: :width 0.8\textwidth 
#+RESULTS: GustXRF34
[[file:figs/GustXRF34.png]]

# #+NAME: GustXRF34_x
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   sol1= solution.IntrinsicReader("./XRF3")
#   sol2= solution.IntrinsicReader("./XRF4")
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6],dim=0, nast_scale=2, nast_load=[2,6])
#   figname
# #+end_src

# #+NAME: fig:GustXRF34_x
# #+CAPTION: Wing-tip response to high intensity gust, $x-$ component
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF34_x
# [[file:figs/GustXRF34_x.png]]

# #+NAME: GustXRF34_y
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6],dim=1, nast_scale=2, nast_load=[2,6])
#   figname
# #+end_src

# #+CAPTION: Wing-tip response to high intensity gust, $y-$ component
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF34_y
# [[file:figs/GustXRF34_y.png]]

# #+NAME: GustXRF34_z
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip2)(sol1, sol2, labels=[2,6],
#                                               dim=2, nast_scale=2, nast_load=[2,6])
#   figname
# #+end_src

# #+CAPTION: Wing-tip response to high intensity gust, $z-$component
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF34_z
# [[file:figs/GustXRF34_z.png]]

Snapshots of the 3D response are reconstructed for the G1 gust using the method verified above at the time points where tip displacement are maximum and minimum, i.e. 0.54 and 0.84 seconds. The front and side views together with the aircraft reference configuration are shown in Fig. [[fig:xrf1gust3D]]. 
#+NAME: fig:xrf1gust3D
#+CAPTION: 3D XRF1 Nonlinear gust response 
#+ATTR_LATEX: :width 0.8\textwidth 
[[file:figs/xrf1gust3D.pdf]]

In previous examples the same Runge-Kutta 4 (RK4) time-marching scheme is used and now we explore the dynamic solution with other solvers to assess their accuracy and also their computational performance. Two explicit ODE solvers, RK4 and Dormand-Prince's 5/4 method (labelled S1 and S2), and two implicit, Euler first order and Kvaerno's 3/2 method ((labelled S3 and S4)), are compared in Fig. [[fig:GustXRF3578]] . In order to justify the use of implicit solvers we reduce the time step from 0.005 to 0.02 seconds, at which point both explicit solvers diverge. Kvaerno's implicit solver remain stable and accurate despite the larger time step while the Euler implicit method is stable but do not yield accurate results.

#+NAME: GustXRF3578
#+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
  sol3= solution.IntrinsicReader("./XRF3")
  sol5= solution.IntrinsicReader("./XRF5")
  sol7= solution.IntrinsicReader("./XRF7")
  sol8= solution.IntrinsicReader("./XRF8")

  fig, figname = fig_out(name)(subplots_wtips)(xrf1_wingtip4, sol1=sol3, sol2=sol5, sol3=sol7, sol4=sol8,
                                              labels=["S1","S2","S3","S4"])
  figname
#+end_src

#+NAME: fig:GustXRF3578
#+CAPTION: Wing-tip response to high intensity gust using implicit solvers
#+ATTR_LATEX: :width 0.8\textwidth 
#+RESULTS: GustXRF3578
[[file:figs/GustXRF3578.png]]


# #+NAME: GustXRF56_x
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   sol3= solution.IntrinsicReader("./XRF3")
#   sol5= solution.IntrinsicReader("./XRF5")
#   sol7= solution.IntrinsicReader("./XRF7")
#   sol8= solution.IntrinsicReader("./XRF8")
#   fig, figname = fig_out(name)(xrf1_wingtip4)(sol3, sol5, sol7, sol8,
#                                               labels=["l3","l5","l7","l8"],
#                                               dim=0)
#   figname
# #+end_src

# #+NAME: fig:GustXRF56_x
# #+CAPTION: Comparison of solvers
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF56_x
# [[file:]]

# #+NAME: GustXRF56_y
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip4)(sol3, sol5, sol7, sol8, labels=["l3","l5","l7","l8"],
#                                               dim=1)
#   figname
# #+end_src

# #+NAME: fig:GustXRF56_y
# #+CAPTION: Comparison of solvers
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF56_y
# [[file:figs/GustXRF56_y.png]]

# #+NAME: GustXRF56_z
# #+begin_src python :results value file  :var name=(org-element-property :name (org-element-context))
#   fig, figname = fig_out(name)(xrf1_wingtip4)(sol3, sol5, sol7, sol8, labels=["l3","l5","l7","l8"],dim=2)
#   figname
# #+end_src

# #+NAME: fig:GustXRF56_z
# #+CAPTION: Comparison of solvers
# #+ATTR_LATEX: :width 0.6\textwidth 
# #+RESULTS: GustXRF56_z
# [[file:figs/GustXRF56_z.png]]

The computational times of the different solvers are shown in Table [[table:XRF1_times]]. The implicit solvers have taken one order of magnitude more time to run despite the reduction in time step. Therefore the main take away this is that for moderately large frequency dynamics, the explicit solvers offer a much efficient solution. The turning point for using implicit solvers would be when the largest eigenvalue in Eqs. \ref{eq2:sol_qs} led to prohibitly small time steps. In terms of the Nastran solution, we are not showing the whole simulation time because that would include the time to sample the DLM aerodynamics which are input into the NMROM as a post-processing step. Instead, the increase in time when adding an extra gust subcase to an already existing analysis is shown, i.e. the difference between one simulation that only computes one gust response and another with two. It is remarkable that the explicit solvers are faster on the nonlinear solution than the linear solution by a commercial software. Besides our highly efficient implementation, the main reason for this might be the Nastran solution involves first a frequency domain analysis and then an inverse Fourier transform to obtain the time-domain results.

#+NAME: XRF1_times
#+begin_src python  :results raw
  dfruns = pd.read_csv('./run_times.csv',index_col=0).transpose()
  values = ["Time [s]"]
  values += [', '.join([str(round(dfruns[f'XRF{i}'].iloc[0], 2)) for i in [3,5,7,8]])]
  values += [0*60*60 + 1*60 + 21]
  header = ["NMROM [S1, S2, S3, S4]" ]
  header += ["$\Delta$ NASTRAN 146"]
  # df_sp = pd.DataFrame(dict(times=TIMES_DICT.values()),
  #                         index=TIMES_DICT.keys())

  # df_ = results_df['shift_conm2sLM25']
  # df_ = df_.rename(columns={"xlabel": "%Chord"})
  tabulate([values], headers=header, tablefmt='orgtbl')
#+end_src

#+CAPTION: Computational times XRF1 gust solution.
#+NAME: table:XRF1_times
#+ATTR_LATEX:  :center t :placement [h]
#+RESULTS: XRF1_times
|          | NMROM [S1, S2, S3, S4]       | $\Delta$ NASTRAN 146 |
|----------+------------------------------+----------------------|
| Time [s] | 22.49, 18.94, 273.95, 847.89 |                   81 |

Similarly to the examples above, we now verify the AD implementation for the nonlinear aeroelastic response to the gust $G1$. The sensitivity of the six components of the wing root loads are computed with respect to the gust parameters $w_g$ and $L_g$, and the flow parameters $u_{\inf}$ and $\rho_{\inf}$. The results are presented in [[table:XRF1_AD]]. A very good agreement with the finite differences is found with $\epsilon=10^{-4}$, except for $u_{\inf}$ which was found to be rather unstable and giving negative values, which is not very sensible. This is a common problem about using finite differences to approximate derivatives and another argument in favour of AD techniques. Reducing to $\epsilon=5\times 10^{-2}$ produces more stable results which are the ones shown in the comparison.

#+CAPTION: AD verification for the response to gust
#+NAME: table:XRF1_AD
\begin{table} [h!]
\begin{center}
\begin{tabular}{lllll}
\toprule
 & $w_g$ & $L_g$ & $u_{\inf}$ & $\rho_{\inf}$ \\
\midrule
$f_1$ (AD) & 12.180 & -0.690 & 6.666 & 477.208 \\
$f_1$ (FD)  & 12.180 & -0.690  & 6.190  & 477.198  \\
$\Delta$ \% & -1.1941E-5 & -2.8929E-3 & -7.1417E+0 & -2.1560E-3 \\
\hline
$f_2 (AD)$ & 19.088 & -1.015 & 6.122 & 712.485 \\
$f_2 (FD)$ & 19.088 & -1.015 & 7.045 & 712.514  \\
$\Delta$ \% & -8.0605E-5  & 1.6081E-2  & 1.5074E+1  & 4.1813E-3  \\
\hline
$f_3 (AD)$ & 65.574 & 18.764 & 8.218 & 1464.910 \\
$f_3 (FD)$ & 65.574  & 18.764  & 7.813 & 1464.909  \\
$\Delta$ \% & 5.1097E-6  & -5.0153E-5  & -4.9240E+0  & -1.0196E-4  \\
\hline
$f_4 (AD)$ & 126.648 & 6.961 & 21.598 & 2883.370 \\
$f_4 (FD)$ & 126.648  & 6.961 & 19.736  & 2883.371  \\
$\Delta$ \% & 6.2554E-6  & -2.2226E-3  & -8.6195E+0  & 5.2262E-5  \\
\hline
$f_5 (AD)$ & 330.759 & 84.098 & 85.224 & 5931.723 \\
$f_5 (FD)$ & 330.759 & 84.099  & 97.188  & 5930.027  \\
$\Delta$ \% & -1.3673E-5  & 2.0601E-3  & 1.4038E+1  & -2.8595E-2  \\
\hline
$f_6$ (AD) & 252.128 & 24.212 & 48.423 & 7179.735 \\
$f_6$ (FD) & 252.128  & 24.211  & 14.980  & 7180.023  \\
$\Delta$ \% & 4.4897E-5  & -5.4566E-3  & -6.9065E+1  & 4.0120E-3  \\
\bottomrule
\end{tabular}
\end{center}
  \end{table}

